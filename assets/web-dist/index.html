<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="./vite.svg" />
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- 引入样式 -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@nutui/nutui/dist/style.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@nutui/icons-vue/dist/style_icon.css" />
    <!-- 引入Vue -->
    <!--<script src="https://cdn.jsdelivr.net/npm/vue"></script>
    &lt;!&ndash; 引入NutUI组件库 &ndash;&gt;
    <script src="https://cdn.jsdelivr.net/npm/@nutui/nutui/dist/nutui.umd.js"></script>-->
    <title>Vite + Vue + TS</title>

    <script src="https://unpkg.com/vconsole@latest/dist/vconsole.min.js"></script>
    <script>
        // VConsole will be exported to `window.VConsole` by default.
        var vConsole = new window.VConsole();
    </script>
    <script type="module" crossorigin>(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity) fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
    else fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
/**
* @vue/shared v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function makeMap(str) {
  const map = /* @__PURE__ */ Object.create(null);
  for (const key of str.split(",")) map[key] = 1;
  return (val) => val in map;
}
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
(key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el) => {
  const i2 = arr.indexOf(el);
  if (i2 > -1) {
    arr.splice(i2, 1);
  }
};
const hasOwnProperty$1 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$1.call(val, key);
const isArray$1 = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isFunction$1 = (val) => typeof val === "function";
const isString = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject$2 = (val) => val !== null && typeof val === "object";
const isPromise$1 = (val) => {
  return (isObject$2(val) || isFunction$1(val)) && isFunction$1(val.then) && isFunction$1(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize$1 = cacheStringFunction(
  (str) => {
    return str.replace(camelizeRE, (_, c2) => c2 ? c2.toUpperCase() : "");
  }
);
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction(
  (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
);
const capitalize = cacheStringFunction((str) => {
  return str.charAt(0).toUpperCase() + str.slice(1);
});
const toHandlerKey = cacheStringFunction(
  (str) => {
    const s = str ? `on${capitalize(str)}` : ``;
    return s;
  }
);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, ...arg) => {
  for (let i2 = 0; i2 < fns.length; i2++) {
    fns[i2](...arg);
  }
};
const def = (obj, key, value, writable = false) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    writable,
    value
  });
};
const looseToNumber = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
const toNumber = (val) => {
  const n = isString(val) ? Number(val) : NaN;
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
function normalizeStyle(value) {
  if (isArray$1(value)) {
    const res = {};
    for (let i2 = 0; i2 < value.length; i2++) {
      const item = value[i2];
      const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString(value) || isObject$2(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*[^]*?\*\//g;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString(value)) {
    res = value;
  } else if (isArray$1(value)) {
    for (let i2 = 0; i2 < value.length; i2++) {
      const normalized = normalizeClass(value[i2]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$2(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props) {
  if (!props) return null;
  let { class: klass, style } = props;
  if (klass && !isString(klass)) {
    props.class = normalizeClass(klass);
  }
  if (style) {
    props.style = normalizeStyle(style);
  }
  return props;
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
const isRef$1 = (val) => {
  return !!(val && val["__v_isRef"] === true);
};
const toDisplayString = (val) => {
  return isString(val) ? val : val == null ? "" : isArray$1(val) || isObject$2(val) && (val.toString === objectToString || !isFunction$1(val.toString)) ? isRef$1(val) ? toDisplayString(val.value) : JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (isRef$1(val)) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce(
        (entries, [key, val2], i2) => {
          entries[stringifySymbol(key, i2) + " =>"] = val2;
          return entries;
        },
        {}
      )
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()].map((v2) => stringifySymbol(v2))
    };
  } else if (isSymbol(val)) {
    return stringifySymbol(val);
  } else if (isObject$2(val) && !isArray$1(val) && !isPlainObject(val)) {
    return String(val);
  }
  return val;
};
const stringifySymbol = (v2, i2 = "") => {
  var _a;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    isSymbol(v2) ? `Symbol(${(_a = v2.description) != null ? _a : i2})` : v2
  );
};
/**
* @vue/reactivity v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this._isPaused = false;
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
        this
      ) - 1;
    }
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = true;
      let i2, l2;
      if (this.scopes) {
        for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) {
          this.scopes[i2].pause();
        }
      }
      for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) {
        this.effects[i2].pause();
      }
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active) {
      if (this._isPaused) {
        this._isPaused = false;
        let i2, l2;
        if (this.scopes) {
          for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) {
            this.scopes[i2].resume();
          }
        }
        for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) {
          this.effects[i2].resume();
        }
      }
    }
  }
  run(fn) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    activeEffectScope = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      this._active = false;
      let i2, l2;
      for (i2 = 0, l2 = this.effects.length; i2 < l2; i2++) {
        this.effects[i2].stop();
      }
      this.effects.length = 0;
      for (i2 = 0, l2 = this.cleanups.length; i2 < l2; i2++) {
        this.cleanups[i2]();
      }
      this.cleanups.length = 0;
      if (this.scopes) {
        for (i2 = 0, l2 = this.scopes.length; i2 < l2; i2++) {
          this.scopes[i2].stop(true);
        }
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
    }
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
let activeSub;
const pausedQueueEffects = /* @__PURE__ */ new WeakSet();
class ReactiveEffect {
  constructor(fn) {
    this.fn = fn;
    this.deps = void 0;
    this.depsTail = void 0;
    this.flags = 1 | 4;
    this.next = void 0;
    this.cleanup = void 0;
    this.scheduler = void 0;
    if (activeEffectScope && activeEffectScope.active) {
      activeEffectScope.effects.push(this);
    }
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    if (this.flags & 64) {
      this.flags &= ~64;
      if (pausedQueueEffects.has(this)) {
        pausedQueueEffects.delete(this);
        this.trigger();
      }
    }
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags & 2 && !(this.flags & 32)) {
      return;
    }
    if (!(this.flags & 8)) {
      batch(this);
    }
  }
  run() {
    if (!(this.flags & 1)) {
      return this.fn();
    }
    this.flags |= 2;
    cleanupEffect(this);
    prepareDeps(this);
    const prevEffect = activeSub;
    const prevShouldTrack = shouldTrack;
    activeSub = this;
    shouldTrack = true;
    try {
      return this.fn();
    } finally {
      cleanupDeps(this);
      activeSub = prevEffect;
      shouldTrack = prevShouldTrack;
      this.flags &= ~2;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let link = this.deps; link; link = link.nextDep) {
        removeSub(link);
      }
      this.deps = this.depsTail = void 0;
      cleanupEffect(this);
      this.onStop && this.onStop();
      this.flags &= ~1;
    }
  }
  trigger() {
    if (this.flags & 64) {
      pausedQueueEffects.add(this);
    } else if (this.scheduler) {
      this.scheduler();
    } else {
      this.runIfDirty();
    }
  }
  /**
   * @internal
   */
  runIfDirty() {
    if (isDirty(this)) {
      this.run();
    }
  }
  get dirty() {
    return isDirty(this);
  }
}
let batchDepth = 0;
let batchedSub;
let batchedComputed;
function batch(sub, isComputed = false) {
  sub.flags |= 8;
  if (isComputed) {
    sub.next = batchedComputed;
    batchedComputed = sub;
    return;
  }
  sub.next = batchedSub;
  batchedSub = sub;
}
function startBatch() {
  batchDepth++;
}
function endBatch() {
  if (--batchDepth > 0) {
    return;
  }
  if (batchedComputed) {
    let e = batchedComputed;
    batchedComputed = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= ~8;
      e = next;
    }
  }
  let error;
  while (batchedSub) {
    let e = batchedSub;
    batchedSub = void 0;
    while (e) {
      const next = e.next;
      e.next = void 0;
      e.flags &= ~8;
      if (e.flags & 1) {
        try {
          ;
          e.trigger();
        } catch (err) {
          if (!error) error = err;
        }
      }
      e = next;
    }
  }
  if (error) throw error;
}
function prepareDeps(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    link.version = -1;
    link.prevActiveLink = link.dep.activeLink;
    link.dep.activeLink = link;
  }
}
function cleanupDeps(sub) {
  let head;
  let tail = sub.depsTail;
  let link = tail;
  while (link) {
    const prev = link.prevDep;
    if (link.version === -1) {
      if (link === tail) tail = prev;
      removeSub(link);
      removeDep(link);
    } else {
      head = link;
    }
    link.dep.activeLink = link.prevActiveLink;
    link.prevActiveLink = void 0;
    link = prev;
  }
  sub.deps = head;
  sub.depsTail = tail;
}
function isDirty(sub) {
  for (let link = sub.deps; link; link = link.nextDep) {
    if (link.dep.version !== link.version || link.dep.computed && (refreshComputed(link.dep.computed) || link.dep.version !== link.version)) {
      return true;
    }
  }
  if (sub._dirty) {
    return true;
  }
  return false;
}
function refreshComputed(computed2) {
  if (computed2.flags & 4 && !(computed2.flags & 16)) {
    return;
  }
  computed2.flags &= ~16;
  if (computed2.globalVersion === globalVersion) {
    return;
  }
  computed2.globalVersion = globalVersion;
  const dep = computed2.dep;
  computed2.flags |= 2;
  if (dep.version > 0 && !computed2.isSSR && computed2.deps && !isDirty(computed2)) {
    computed2.flags &= ~2;
    return;
  }
  const prevSub = activeSub;
  const prevShouldTrack = shouldTrack;
  activeSub = computed2;
  shouldTrack = true;
  try {
    prepareDeps(computed2);
    const value = computed2.fn(computed2._value);
    if (dep.version === 0 || hasChanged(value, computed2._value)) {
      computed2._value = value;
      dep.version++;
    }
  } catch (err) {
    dep.version++;
    throw err;
  } finally {
    activeSub = prevSub;
    shouldTrack = prevShouldTrack;
    cleanupDeps(computed2);
    computed2.flags &= ~2;
  }
}
function removeSub(link, soft = false) {
  const { dep, prevSub, nextSub } = link;
  if (prevSub) {
    prevSub.nextSub = nextSub;
    link.prevSub = void 0;
  }
  if (nextSub) {
    nextSub.prevSub = prevSub;
    link.nextSub = void 0;
  }
  if (dep.subs === link) {
    dep.subs = prevSub;
    if (!prevSub && dep.computed) {
      dep.computed.flags &= ~4;
      for (let l2 = dep.computed.deps; l2; l2 = l2.nextDep) {
        removeSub(l2, true);
      }
    }
  }
  if (!soft && !--dep.sc && dep.map) {
    dep.map.delete(dep.key);
  }
}
function removeDep(link) {
  const { prevDep, nextDep } = link;
  if (prevDep) {
    prevDep.nextDep = nextDep;
    link.prevDep = void 0;
  }
  if (nextDep) {
    nextDep.prevDep = prevDep;
    link.nextDep = void 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function cleanupEffect(e) {
  const { cleanup } = e;
  e.cleanup = void 0;
  if (cleanup) {
    const prevSub = activeSub;
    activeSub = void 0;
    try {
      cleanup();
    } finally {
      activeSub = prevSub;
    }
  }
}
let globalVersion = 0;
class Link {
  constructor(sub, dep) {
    this.sub = sub;
    this.dep = dep;
    this.version = dep.version;
    this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class Dep {
  constructor(computed2) {
    this.computed = computed2;
    this.version = 0;
    this.activeLink = void 0;
    this.subs = void 0;
    this.map = void 0;
    this.key = void 0;
    this.sc = 0;
  }
  track(debugInfo) {
    if (!activeSub || !shouldTrack || activeSub === this.computed) {
      return;
    }
    let link = this.activeLink;
    if (link === void 0 || link.sub !== activeSub) {
      link = this.activeLink = new Link(activeSub, this);
      if (!activeSub.deps) {
        activeSub.deps = activeSub.depsTail = link;
      } else {
        link.prevDep = activeSub.depsTail;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
      }
      addSub(link);
    } else if (link.version === -1) {
      link.version = this.version;
      if (link.nextDep) {
        const next = link.nextDep;
        next.prevDep = link.prevDep;
        if (link.prevDep) {
          link.prevDep.nextDep = next;
        }
        link.prevDep = activeSub.depsTail;
        link.nextDep = void 0;
        activeSub.depsTail.nextDep = link;
        activeSub.depsTail = link;
        if (activeSub.deps === link) {
          activeSub.deps = next;
        }
      }
    }
    return link;
  }
  trigger(debugInfo) {
    this.version++;
    globalVersion++;
    this.notify(debugInfo);
  }
  notify(debugInfo) {
    startBatch();
    try {
      if (false) ;
      for (let link = this.subs; link; link = link.prevSub) {
        if (link.sub.notify()) {
          ;
          link.sub.dep.notify();
        }
      }
    } finally {
      endBatch();
    }
  }
}
function addSub(link) {
  link.dep.sc++;
  if (link.sub.flags & 4) {
    const computed2 = link.dep.computed;
    if (computed2 && !link.dep.subs) {
      computed2.flags |= 4 | 16;
      for (let l2 = computed2.deps; l2; l2 = l2.nextDep) {
        addSub(l2);
      }
    }
    const currentTail = link.dep.subs;
    if (currentTail !== link) {
      link.prevSub = currentTail;
      if (currentTail) currentTail.nextSub = link;
    }
    link.dep.subs = link;
  }
}
const targetMap = /* @__PURE__ */ new WeakMap();
const ITERATE_KEY = Symbol(
  ""
);
const MAP_KEY_ITERATE_KEY = Symbol(
  ""
);
const ARRAY_ITERATE_KEY = Symbol(
  ""
);
function track(target, type, key) {
  if (shouldTrack && activeSub) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = new Dep());
      dep.map = depsMap;
      dep.key = key;
    }
    {
      dep.track();
    }
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    globalVersion++;
    return;
  }
  const run = (dep) => {
    if (dep) {
      {
        dep.trigger();
      }
    }
  };
  startBatch();
  if (type === "clear") {
    depsMap.forEach(run);
  } else {
    const targetIsArray = isArray$1(target);
    const isArrayIndex = targetIsArray && isIntegerKey(key);
    if (targetIsArray && key === "length") {
      const newLength = Number(newValue);
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 === ARRAY_ITERATE_KEY || !isSymbol(key2) && key2 >= newLength) {
          run(dep);
        }
      });
    } else {
      if (key !== void 0 || depsMap.has(void 0)) {
        run(depsMap.get(key));
      }
      if (isArrayIndex) {
        run(depsMap.get(ARRAY_ITERATE_KEY));
      }
      switch (type) {
        case "add":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isArrayIndex) {
            run(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!targetIsArray) {
            run(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              run(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            run(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
  }
  endBatch();
}
function getDepFromReactive(object, key) {
  const depMap = targetMap.get(object);
  return depMap && depMap.get(key);
}
function reactiveReadArray(array) {
  const raw = toRaw(array);
  if (raw === array) return raw;
  track(raw, "iterate", ARRAY_ITERATE_KEY);
  return isShallow(array) ? raw : raw.map(toReactive);
}
function shallowReadArray(arr) {
  track(arr = toRaw(arr), "iterate", ARRAY_ITERATE_KEY);
  return arr;
}
const arrayInstrumentations = {
  __proto__: null,
  [Symbol.iterator]() {
    return iterator(this, Symbol.iterator, toReactive);
  },
  concat(...args) {
    return reactiveReadArray(this).concat(
      ...args.map((x) => isArray$1(x) ? reactiveReadArray(x) : x)
    );
  },
  entries() {
    return iterator(this, "entries", (value) => {
      value[1] = toReactive(value[1]);
      return value;
    });
  },
  every(fn, thisArg) {
    return apply(this, "every", fn, thisArg, void 0, arguments);
  },
  filter(fn, thisArg) {
    return apply(this, "filter", fn, thisArg, (v2) => v2.map(toReactive), arguments);
  },
  find(fn, thisArg) {
    return apply(this, "find", fn, thisArg, toReactive, arguments);
  },
  findIndex(fn, thisArg) {
    return apply(this, "findIndex", fn, thisArg, void 0, arguments);
  },
  findLast(fn, thisArg) {
    return apply(this, "findLast", fn, thisArg, toReactive, arguments);
  },
  findLastIndex(fn, thisArg) {
    return apply(this, "findLastIndex", fn, thisArg, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(fn, thisArg) {
    return apply(this, "forEach", fn, thisArg, void 0, arguments);
  },
  includes(...args) {
    return searchProxy(this, "includes", args);
  },
  indexOf(...args) {
    return searchProxy(this, "indexOf", args);
  },
  join(separator) {
    return reactiveReadArray(this).join(separator);
  },
  // keys() iterator only reads `length`, no optimisation required
  lastIndexOf(...args) {
    return searchProxy(this, "lastIndexOf", args);
  },
  map(fn, thisArg) {
    return apply(this, "map", fn, thisArg, void 0, arguments);
  },
  pop() {
    return noTracking(this, "pop");
  },
  push(...args) {
    return noTracking(this, "push", args);
  },
  reduce(fn, ...args) {
    return reduce(this, "reduce", fn, args);
  },
  reduceRight(fn, ...args) {
    return reduce(this, "reduceRight", fn, args);
  },
  shift() {
    return noTracking(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(fn, thisArg) {
    return apply(this, "some", fn, thisArg, void 0, arguments);
  },
  splice(...args) {
    return noTracking(this, "splice", args);
  },
  toReversed() {
    return reactiveReadArray(this).toReversed();
  },
  toSorted(comparer) {
    return reactiveReadArray(this).toSorted(comparer);
  },
  toSpliced(...args) {
    return reactiveReadArray(this).toSpliced(...args);
  },
  unshift(...args) {
    return noTracking(this, "unshift", args);
  },
  values() {
    return iterator(this, "values", toReactive);
  }
};
function iterator(self2, method, wrapValue) {
  const arr = shallowReadArray(self2);
  const iter = arr[method]();
  if (arr !== self2 && !isShallow(self2)) {
    iter._next = iter.next;
    iter.next = () => {
      const result = iter._next();
      if (result.value) {
        result.value = wrapValue(result.value);
      }
      return result;
    };
  }
  return iter;
}
const arrayProto = Array.prototype;
function apply(self2, method, fn, thisArg, wrappedRetFn, args) {
  const arr = shallowReadArray(self2);
  const needsWrap = arr !== self2 && !isShallow(self2);
  const methodFn = arr[method];
  if (methodFn !== arrayProto[method]) {
    const result2 = methodFn.apply(self2, args);
    return needsWrap ? toReactive(result2) : result2;
  }
  let wrappedFn = fn;
  if (arr !== self2) {
    if (needsWrap) {
      wrappedFn = function(item, index2) {
        return fn.call(this, toReactive(item), index2, self2);
      };
    } else if (fn.length > 2) {
      wrappedFn = function(item, index2) {
        return fn.call(this, item, index2, self2);
      };
    }
  }
  const result = methodFn.call(arr, wrappedFn, thisArg);
  return needsWrap && wrappedRetFn ? wrappedRetFn(result) : result;
}
function reduce(self2, method, fn, args) {
  const arr = shallowReadArray(self2);
  let wrappedFn = fn;
  if (arr !== self2) {
    if (!isShallow(self2)) {
      wrappedFn = function(acc, item, index2) {
        return fn.call(this, acc, toReactive(item), index2, self2);
      };
    } else if (fn.length > 3) {
      wrappedFn = function(acc, item, index2) {
        return fn.call(this, acc, item, index2, self2);
      };
    }
  }
  return arr[method](wrappedFn, ...args);
}
function searchProxy(self2, method, args) {
  const arr = toRaw(self2);
  track(arr, "iterate", ARRAY_ITERATE_KEY);
  const res = arr[method](...args);
  if ((res === -1 || res === false) && isProxy(args[0])) {
    args[0] = toRaw(args[0]);
    return arr[method](...args);
  }
  return res;
}
function noTracking(self2, method, args = []) {
  pauseTracking();
  startBatch();
  const res = toRaw(self2)[method].apply(self2, args);
  endBatch();
  resetTracking();
  return res;
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
function hasOwnProperty(key) {
  if (!isSymbol(key)) key = String(key);
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
class BaseReactiveHandler {
  constructor(_isReadonly = false, _isShallow = false) {
    this._isReadonly = _isReadonly;
    this._isShallow = _isShallow;
  }
  get(target, key, receiver) {
    if (key === "__v_skip") return target["__v_skip"];
    const isReadonly2 = this._isReadonly, isShallow2 = this._isShallow;
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return isShallow2;
    } else if (key === "__v_raw") {
      if (receiver === (isReadonly2 ? isShallow2 ? shallowReadonlyMap : readonlyMap : isShallow2 ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
        return target;
      }
      return;
    }
    const targetIsArray = isArray$1(target);
    if (!isReadonly2) {
      let fn;
      if (targetIsArray && (fn = arrayInstrumentations[key])) {
        return fn;
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty;
      }
    }
    const res = Reflect.get(
      target,
      key,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      isRef(target) ? target : receiver
    );
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (isShallow2) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$2(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  }
}
class MutableReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(false, isShallow2);
  }
  set(target, key, value, receiver) {
    let oldValue = target[key];
    if (!this._isShallow) {
      const isOldValueReadonly = isReadonly(oldValue);
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray$1(target) && isRef(oldValue) && !isRef(value)) {
        if (isOldValueReadonly) {
          return false;
        } else {
          oldValue.value = value;
          return true;
        }
      }
    }
    const hadKey = isArray$1(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(
      target,
      key,
      value,
      isRef(target) ? target : receiver
    );
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
    }
    return result;
  }
  deleteProperty(target, key) {
    const hadKey = hasOwn(target, key);
    target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0);
    }
    return result;
  }
  has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  ownKeys(target) {
    track(
      target,
      "iterate",
      isArray$1(target) ? "length" : ITERATE_KEY
    );
    return Reflect.ownKeys(target);
  }
}
class ReadonlyReactiveHandler extends BaseReactiveHandler {
  constructor(isShallow2 = false) {
    super(true, isShallow2);
  }
  set(target, key) {
    return true;
  }
  deleteProperty(target, key) {
    return true;
  }
}
const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(true);
const shallowReadonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler(true);
const toShallow = (value) => value;
const getProto = (v2) => Reflect.getPrototypeOf(v2);
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(
      rawTarget,
      "iterate",
      isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
    );
    return {
      // iterator protocol
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : type === "clear" ? void 0 : this;
  };
}
function createInstrumentations(readonly2, shallow) {
  const instrumentations = {
    get(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "get", key);
        }
        track(rawTarget, "get", rawKey);
      }
      const { has } = getProto(rawTarget);
      const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
      if (has.call(rawTarget, key)) {
        return wrap(target.get(key));
      } else if (has.call(rawTarget, rawKey)) {
        return wrap(target.get(rawKey));
      } else if (target !== rawTarget) {
        target.get(key);
      }
    },
    get size() {
      const target = this["__v_raw"];
      !readonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
      return Reflect.get(target, "size", target);
    },
    has(key) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const rawKey = toRaw(key);
      if (!readonly2) {
        if (hasChanged(key, rawKey)) {
          track(rawTarget, "has", key);
        }
        track(rawTarget, "has", rawKey);
      }
      return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
    },
    forEach(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw(target);
      const wrap = shallow ? toShallow : readonly2 ? toReadonly : toReactive;
      !readonly2 && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    }
  };
  extend(
    instrumentations,
    readonly2 ? {
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear")
    } : {
      add(value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const proto = getProto(target);
        const hadKey = proto.has.call(target, value);
        if (!hadKey) {
          target.add(value);
          trigger(target, "add", value, value);
        }
        return this;
      },
      set(key, value) {
        if (!shallow && !isShallow(value) && !isReadonly(value)) {
          value = toRaw(value);
        }
        const target = toRaw(this);
        const { has, get } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        }
        const oldValue = get.call(target, key);
        target.set(key, value);
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value);
        }
        return this;
      },
      delete(key) {
        const target = toRaw(this);
        const { has, get } = getProto(target);
        let hadKey = has.call(target, key);
        if (!hadKey) {
          key = toRaw(key);
          hadKey = has.call(target, key);
        }
        get ? get.call(target, key) : void 0;
        const result = target.delete(key);
        if (hadKey) {
          trigger(target, "delete", key, void 0);
        }
        return result;
      },
      clear() {
        const target = toRaw(this);
        const hadItems = target.size !== 0;
        const result = target.clear();
        if (hadItems) {
          trigger(
            target,
            "clear",
            void 0,
            void 0
          );
        }
        return result;
      }
    }
  );
  const iteratorMethods = [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ];
  iteratorMethods.forEach((method) => {
    instrumentations[method] = createIterableMethod(method, readonly2, shallow);
  });
  return instrumentations;
}
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = createInstrumentations(isReadonly2, shallow);
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(
      hasOwn(instrumentations, key) && key in target ? instrumentations : target,
      key,
      receiver
    );
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  );
}
function shallowReactive(target) {
  return createReactiveObject(
    target,
    false,
    shallowReactiveHandlers,
    shallowCollectionHandlers,
    shallowReactiveMap
  );
}
function readonly(target) {
  return createReactiveObject(
    target,
    true,
    readonlyHandlers,
    readonlyCollectionHandlers,
    readonlyMap
  );
}
function shallowReadonly(target) {
  return createReactiveObject(
    target,
    true,
    shallowReadonlyHandlers,
    shallowReadonlyCollectionHandlers,
    shallowReadonlyMap
  );
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$2(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(
    target,
    targetType === 2 ? collectionHandlers : baseHandlers
  );
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return value ? !!value["__v_raw"] : false;
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  if (!hasOwn(value, "__v_skip") && Object.isExtensible(value)) {
    def(value, "__v_skip", true);
  }
  return value;
}
const toReactive = (value) => isObject$2(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$2(value) ? readonly(value) : value;
function isRef(r) {
  return r ? r["__v_isRef"] === true : false;
}
function ref(value) {
  return createRef(value, false);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, isShallow2) {
    this.dep = new Dep();
    this["__v_isRef"] = true;
    this["__v_isShallow"] = false;
    this._rawValue = isShallow2 ? value : toRaw(value);
    this._value = isShallow2 ? value : toReactive(value);
    this["__v_isShallow"] = isShallow2;
  }
  get value() {
    {
      this.dep.track();
    }
    return this._value;
  }
  set value(newValue) {
    const oldValue = this._rawValue;
    const useDirectValue = this["__v_isShallow"] || isShallow(newValue) || isReadonly(newValue);
    newValue = useDirectValue ? newValue : toRaw(newValue);
    if (hasChanged(newValue, oldValue)) {
      this._rawValue = newValue;
      this._value = useDirectValue ? newValue : toReactive(newValue);
      {
        this.dep.trigger();
      }
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => key === "__v_raw" ? target : unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
function toRefs(object) {
  const ret = isArray$1(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = propertyToRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this["__v_isRef"] = true;
    this._value = void 0;
  }
  get value() {
    const val = this._object[this._key];
    return this._value = val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key);
  }
}
class GetterRefImpl {
  constructor(_getter) {
    this._getter = _getter;
    this["__v_isRef"] = true;
    this["__v_isReadonly"] = true;
    this._value = void 0;
  }
  get value() {
    return this._value = this._getter();
  }
}
function toRef(source, key, defaultValue) {
  if (isRef(source)) {
    return source;
  } else if (isFunction$1(source)) {
    return new GetterRefImpl(source);
  } else if (isObject$2(source) && arguments.length > 1) {
    return propertyToRef(source, key, defaultValue);
  } else {
    return ref(source);
  }
}
function propertyToRef(source, key, defaultValue) {
  const val = source[key];
  return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
}
class ComputedRefImpl {
  constructor(fn, setter, isSSR) {
    this.fn = fn;
    this.setter = setter;
    this._value = void 0;
    this.dep = new Dep(this);
    this.__v_isRef = true;
    this.deps = void 0;
    this.depsTail = void 0;
    this.flags = 16;
    this.globalVersion = globalVersion - 1;
    this.next = void 0;
    this.effect = this;
    this["__v_isReadonly"] = !setter;
    this.isSSR = isSSR;
  }
  /**
   * @internal
   */
  notify() {
    this.flags |= 16;
    if (!(this.flags & 8) && // avoid infinite self recursion
    activeSub !== this) {
      batch(this, true);
      return true;
    }
  }
  get value() {
    const link = this.dep.track();
    refreshComputed(this);
    if (link) {
      link.version = this.dep.version;
    }
    return this._value;
  }
  set value(newValue) {
    if (this.setter) {
      this.setter(newValue);
    }
  }
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  if (isFunction$1(getterOrOptions)) {
    getter = getterOrOptions;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, isSSR);
  return cRef;
}
const INITIAL_WATCHER_VALUE = {};
const cleanupMap = /* @__PURE__ */ new WeakMap();
let activeWatcher = void 0;
function onWatcherCleanup(cleanupFn, failSilently = false, owner = activeWatcher) {
  if (owner) {
    let cleanups = cleanupMap.get(owner);
    if (!cleanups) cleanupMap.set(owner, cleanups = []);
    cleanups.push(cleanupFn);
  }
}
function watch$1(source, cb, options = EMPTY_OBJ) {
  const { immediate, deep, once, scheduler, augmentJob, call } = options;
  const reactiveGetter = (source2) => {
    if (deep) return source2;
    if (isShallow(source2) || deep === false || deep === 0)
      return traverse(source2, 1);
    return traverse(source2);
  };
  let effect2;
  let getter;
  let cleanup;
  let boundCleanup;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => reactiveGetter(source);
    forceTrigger = true;
  } else if (isArray$1(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return reactiveGetter(s);
      } else if (isFunction$1(s)) {
        return call ? call(s, 2) : s();
      } else ;
    });
  } else if (isFunction$1(source)) {
    if (cb) {
      getter = call ? () => call(source, 2) : source;
    } else {
      getter = () => {
        if (cleanup) {
          pauseTracking();
          try {
            cleanup();
          } finally {
            resetTracking();
          }
        }
        const currentEffect = activeWatcher;
        activeWatcher = effect2;
        try {
          return call ? call(source, 3, [boundCleanup]) : source(boundCleanup);
        } finally {
          activeWatcher = currentEffect;
        }
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    const depth = deep === true ? Infinity : deep;
    getter = () => traverse(baseGetter(), depth);
  }
  const scope = getCurrentScope();
  const watchHandle = () => {
    effect2.stop();
    if (scope && scope.active) {
      remove(scope.effects, effect2);
    }
  };
  if (once && cb) {
    const _cb = cb;
    cb = (...args) => {
      _cb(...args);
      watchHandle();
    };
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = (immediateFirstRun) => {
    if (!(effect2.flags & 1) || !effect2.dirty && !immediateFirstRun) {
      return;
    }
    if (cb) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v2, i2) => hasChanged(v2, oldValue[i2])) : hasChanged(newValue, oldValue))) {
        if (cleanup) {
          cleanup();
        }
        const currentWatcher = activeWatcher;
        activeWatcher = effect2;
        try {
          const args = [
            newValue,
            // pass undefined as the old value when it's changed for the first time
            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
            boundCleanup
          ];
          call ? call(cb, 3, args) : (
            // @ts-expect-error
            cb(...args)
          );
          oldValue = newValue;
        } finally {
          activeWatcher = currentWatcher;
        }
      }
    } else {
      effect2.run();
    }
  };
  if (augmentJob) {
    augmentJob(job);
  }
  effect2 = new ReactiveEffect(getter);
  effect2.scheduler = scheduler ? () => scheduler(job, false) : job;
  boundCleanup = (fn) => onWatcherCleanup(fn, false, effect2);
  cleanup = effect2.onStop = () => {
    const cleanups = cleanupMap.get(effect2);
    if (cleanups) {
      if (call) {
        call(cleanups, 4);
      } else {
        for (const cleanup2 of cleanups) cleanup2();
      }
      cleanupMap.delete(effect2);
    }
  };
  if (cb) {
    if (immediate) {
      job(true);
    } else {
      oldValue = effect2.run();
    }
  } else if (scheduler) {
    scheduler(job.bind(null, true), true);
  } else {
    effect2.run();
  }
  watchHandle.pause = effect2.pause.bind(effect2);
  watchHandle.resume = effect2.resume.bind(effect2);
  watchHandle.stop = watchHandle;
  return watchHandle;
}
function traverse(value, depth = Infinity, seen) {
  if (depth <= 0 || !isObject$2(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  depth--;
  if (isRef(value)) {
    traverse(value.value, depth, seen);
  } else if (isArray$1(value)) {
    for (let i2 = 0; i2 < value.length; i2++) {
      traverse(value[i2], depth, seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v2) => {
      traverse(v2, depth, seen);
    });
  } else if (isPlainObject(value)) {
    for (const key in value) {
      traverse(value[key], depth, seen);
    }
    for (const key of Object.getOwnPropertySymbols(value)) {
      if (Object.prototype.propertyIsEnumerable.call(value, key)) {
        traverse(value[key], depth, seen);
      }
    }
  }
  return value;
}
/**
* @vue/runtime-core v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
const stack = [];
let isWarning = false;
function warn$1(msg, ...args) {
  if (isWarning) return;
  isWarning = true;
  pauseTracking();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(
      appWarnHandler,
      instance,
      11,
      [
        // eslint-disable-next-line no-restricted-syntax
        msg + args.map((a2) => {
          var _a, _b;
          return (_b = (_a = a2.toString) == null ? void 0 : _a.call(a2)) != null ? _b : JSON.stringify(a2);
        }).join(""),
        instance && instance.proxy,
        trace.map(
          ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
        ).join("\n"),
        trace
      ]
    );
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && // avoid spamming console during tests
    true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
  isWarning = false;
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i2) => {
    logs.push(...i2 === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
  const close = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
}
function formatProps(props) {
  const res = [];
  const keys = Object.keys(props);
  keys.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if (isString(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if (isRef(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction$1(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw ? value : [`${key}=`, value];
  }
}
function callWithErrorHandling(fn, instance, type, args) {
  try {
    return args ? fn(...args) : fn();
  } catch (err) {
    handleError(err, instance, type);
  }
}
function callWithAsyncErrorHandling(fn, instance, type, args) {
  if (isFunction$1(fn)) {
    const res = callWithErrorHandling(fn, instance, type, args);
    if (res && isPromise$1(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  if (isArray$1(fn)) {
    const values = [];
    for (let i2 = 0; i2 < fn.length; i2++) {
      values.push(callWithAsyncErrorHandling(fn[i2], instance, type, args));
    }
    return values;
  }
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  const { errorHandler, throwUnhandledErrorInProduction } = instance && instance.appContext.config || EMPTY_OBJ;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = `https://vuejs.org/error-reference/#runtime-${type}`;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
          if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    if (errorHandler) {
      pauseTracking();
      callWithErrorHandling(errorHandler, null, 10, [
        err,
        exposedInstance,
        errorInfo
      ]);
      resetTracking();
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev, throwUnhandledErrorInProduction);
}
function logError(err, type, contextVNode, throwInDev = true, throwInProd = false) {
  if (throwInProd) {
    throw err;
  } else {
    console.error(err);
  }
}
const queue = [];
let flushIndex = -1;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn ? p2.then(this ? fn.bind(this) : fn) : p2;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJob = queue[middle];
    const middleJobId = getId(middleJob);
    if (middleJobId < id || middleJobId === id && middleJob.flags & 2) {
      start = middle + 1;
    } else {
      end = middle;
    }
  }
  return start;
}
function queueJob(job) {
  if (!(job.flags & 1)) {
    const jobId = getId(job);
    const lastJob = queue[queue.length - 1];
    if (!lastJob || // fast path when the job id is larger than the tail
    !(job.flags & 2) && jobId >= getId(lastJob)) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(jobId), 0, job);
    }
    job.flags |= 1;
    queueFlush();
  }
}
function queueFlush() {
  if (!currentFlushPromise) {
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray$1(cb)) {
    if (activePostFlushCbs && cb.id === -1) {
      activePostFlushCbs.splice(postFlushIndex + 1, 0, cb);
    } else if (!(cb.flags & 1)) {
      pendingPostFlushCbs.push(cb);
      cb.flags |= 1;
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(instance, seen, i2 = flushIndex + 1) {
  for (; i2 < queue.length; i2++) {
    const cb = queue[i2];
    if (cb && cb.flags & 2) {
      if (instance && cb.id !== instance.uid) {
        continue;
      }
      queue.splice(i2, 1);
      i2--;
      if (cb.flags & 4) {
        cb.flags &= ~1;
      }
      cb();
      if (!(cb.flags & 4)) {
        cb.flags &= ~1;
      }
    }
  }
}
function flushPostFlushCbs(seen) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)].sort(
      (a2, b) => getId(a2) - getId(b)
    );
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      const cb = activePostFlushCbs[postFlushIndex];
      if (cb.flags & 4) {
        cb.flags &= ~1;
      }
      if (!(cb.flags & 8)) cb();
      cb.flags &= ~1;
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? job.flags & 2 ? -1 : Infinity : job.id;
function flushJobs(seen) {
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && !(job.flags & 8)) {
        if (false) ;
        if (job.flags & 4) {
          job.flags &= ~1;
        }
        callWithErrorHandling(
          job,
          job.i,
          job.i ? 15 : 14
        );
        if (!(job.flags & 4)) {
          job.flags &= ~1;
        }
      }
    }
  } finally {
    for (; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job) {
        job.flags &= ~1;
      }
    }
    flushIndex = -1;
    queue.length = 0;
    flushPostFlushCbs();
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx) return fn;
  if (fn._n) {
    return fn;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function withDirectives(vnode, directives) {
  if (currentRenderingInstance === null) {
    return vnode;
  }
  const instance = getComponentPublicInstance(currentRenderingInstance);
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i2 = 0; i2 < directives.length; i2++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i2];
    if (dir) {
      if (isFunction$1(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value);
      }
      bindings.push({
        dir,
        instance,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i2 = 0; i2 < bindings.length; i2++) {
    const binding = bindings[i2];
    if (oldBindings) {
      binding.oldValue = oldBindings[i2].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
const TeleportEndKey = Symbol("_vte");
const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
const isTeleportDeferred = (props) => props && (props.defer || props.defer === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if (isString(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target = select(targetSelector);
      return target;
    }
  } else {
    return targetSelector;
  }
};
const TeleportImpl = {
  name: "Teleport",
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
    const {
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      o: { insert, querySelector, createText, createComment }
    } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (n1 == null) {
      const placeholder = n2.el = createText("");
      const mainAnchor = n2.anchor = createText("");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const mount = (container2, anchor2) => {
        if (shapeFlag & 16) {
          if (parentComponent && parentComponent.isCE) {
            parentComponent.ce._teleportTarget = container2;
          }
          mountChildren(
            children,
            container2,
            anchor2,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      };
      const mountToTarget = () => {
        const target = n2.target = resolveTarget(n2.props, querySelector);
        const targetAnchor = prepareAnchor(target, n2, createText, insert);
        if (target) {
          if (namespace !== "svg" && isTargetSVG(target)) {
            namespace = "svg";
          } else if (namespace !== "mathml" && isTargetMathML(target)) {
            namespace = "mathml";
          }
          if (!disabled) {
            mount(target, targetAnchor);
            updateCssVars(n2, false);
          }
        }
      };
      if (disabled) {
        mount(container, mainAnchor);
        updateCssVars(n2, true);
      }
      if (isTeleportDeferred(n2.props)) {
        queuePostRenderEffect(() => {
          mountToTarget();
          n2.el.__isMounted = true;
        }, parentSuspense);
      } else {
        mountToTarget();
      }
    } else {
      if (isTeleportDeferred(n2.props) && !n1.el.__isMounted) {
        queuePostRenderEffect(() => {
          TeleportImpl.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
          delete n1.el.__isMounted;
        }, parentSuspense);
        return;
      }
      n2.el = n1.el;
      n2.targetStart = n1.targetStart;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      if (namespace === "svg" || isTargetSVG(target)) {
        namespace = "svg";
      } else if (namespace === "mathml" || isTargetMathML(target)) {
        namespace = "mathml";
      }
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          currentContainer,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          currentContainer,
          currentAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          false
        );
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(
            n2,
            container,
            mainAnchor,
            internals,
            1
          );
        } else {
          if (n2.props && n1.props && n2.props.to !== n1.props.to) {
            n2.props.to = n1.props.to;
          }
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(
            n2.props,
            querySelector
          );
          if (nextTarget) {
            moveTeleport(
              n2,
              nextTarget,
              null,
              internals,
              0
            );
          }
        } else if (wasDisabled) {
          moveTeleport(
            n2,
            target,
            targetAnchor,
            internals,
            1
          );
        }
      }
      updateCssVars(n2, disabled);
    }
  },
  remove(vnode, parentComponent, parentSuspense, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const {
      shapeFlag,
      children,
      anchor,
      targetStart,
      targetAnchor,
      target,
      props
    } = vnode;
    if (target) {
      hostRemove(targetStart);
      hostRemove(targetAnchor);
    }
    doRemove && hostRemove(anchor);
    if (shapeFlag & 16) {
      const shouldRemove = doRemove || !isTeleportDisabled(props);
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        unmount(
          child,
          parentComponent,
          parentSuspense,
          shouldRemove,
          !!child.dynamicChildren
        );
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i2 = 0; i2 < children.length; i2++) {
        move(
          children[i2],
          container,
          parentAnchor,
          2
        );
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
  o: { nextSibling, parentNode, querySelector, insert, createText }
}, hydrateChildren) {
  const target = vnode.target = resolveTarget(
    vnode.props,
    querySelector
  );
  if (target) {
    const disabled = isTeleportDisabled(vnode.props);
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (disabled) {
        vnode.anchor = hydrateChildren(
          nextSibling(node),
          vnode,
          parentNode(node),
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
        vnode.targetStart = targetNode;
        vnode.targetAnchor = targetNode && nextSibling(targetNode);
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          if (targetAnchor && targetAnchor.nodeType === 8) {
            if (targetAnchor.data === "teleport start anchor") {
              vnode.targetStart = targetAnchor;
            } else if (targetAnchor.data === "teleport anchor") {
              vnode.targetAnchor = targetAnchor;
              target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
              break;
            }
          }
          targetAnchor = nextSibling(targetAnchor);
        }
        if (!vnode.targetAnchor) {
          prepareAnchor(target, vnode, createText, insert);
        }
        hydrateChildren(
          targetNode && nextSibling(targetNode),
          vnode,
          target,
          parentComponent,
          parentSuspense,
          slotScopeIds,
          optimized
        );
      }
    }
    updateCssVars(vnode, disabled);
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode, isDisabled) {
  const ctx = vnode.ctx;
  if (ctx && ctx.ut) {
    let node, anchor;
    if (isDisabled) {
      node = vnode.el;
      anchor = vnode.anchor;
    } else {
      node = vnode.targetStart;
      anchor = vnode.targetAnchor;
    }
    while (node && node !== anchor) {
      if (node.nodeType === 1) node.setAttribute("data-v-owner", ctx.uid);
      node = node.nextSibling;
    }
    ctx.ut();
  }
}
function prepareAnchor(target, vnode, createText, insert) {
  const targetStart = vnode.targetStart = createText("");
  const targetAnchor = vnode.targetAnchor = createText("");
  targetStart[TeleportEndKey] = targetAnchor;
  if (target) {
    insert(targetStart, target);
    insert(targetAnchor, target);
  }
  return targetAnchor;
}
const leaveCbKey = Symbol("_leaveCb");
const enterCbKey = Symbol("_enterCb");
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionPropsValidators = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: TransitionHookValidator,
  onEnter: TransitionHookValidator,
  onAfterEnter: TransitionHookValidator,
  onEnterCancelled: TransitionHookValidator,
  // leave
  onBeforeLeave: TransitionHookValidator,
  onLeave: TransitionHookValidator,
  onAfterLeave: TransitionHookValidator,
  onLeaveCancelled: TransitionHookValidator,
  // appear
  onBeforeAppear: TransitionHookValidator,
  onAppear: TransitionHookValidator,
  onAfterAppear: TransitionHookValidator,
  onAppearCancelled: TransitionHookValidator
};
const recursiveGetSubtree = (instance) => {
  const subTree = instance.subTree;
  return subTree.component ? recursiveGetSubtree(subTree.component) : subTree;
};
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: BaseTransitionPropsValidators,
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      const child = findNonCommentChild(children);
      const rawProps = toRaw(props);
      const { mode } = rawProps;
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getInnerChild$1(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      let enterHooks = resolveTransitionHooks(
        innerChild,
        rawProps,
        state,
        instance,
        // #11061, ensure enterHooks is fresh after clone
        (hooks) => enterHooks = hooks
      );
      if (innerChild.type !== Comment) {
        setTransitionHooks(innerChild, enterHooks);
      }
      let oldInnerChild = instance.subTree && getInnerChild$1(instance.subTree);
      if (oldInnerChild && oldInnerChild.type !== Comment && !isSameVNodeType(innerChild, oldInnerChild) && recursiveGetSubtree(instance).type !== Comment) {
        let leavingHooks = resolveTransitionHooks(
          oldInnerChild,
          rawProps,
          state,
          instance
        );
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in" && innerChild.type !== Comment) {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (!(instance.job.flags & 8)) {
              instance.update();
            }
            delete leavingHooks.afterLeave;
            oldInnerChild = void 0;
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(
              state,
              oldInnerChild
            );
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el[leaveCbKey] = () => {
              earlyRemove();
              el[leaveCbKey] = void 0;
              delete enterHooks.delayedLeave;
              oldInnerChild = void 0;
            };
            enterHooks.delayedLeave = () => {
              delayedLeave();
              delete enterHooks.delayedLeave;
              oldInnerChild = void 0;
            };
          };
        } else {
          oldInnerChild = void 0;
        }
      } else if (oldInnerChild) {
        oldInnerChild = void 0;
      }
      return child;
    };
  }
};
function findNonCommentChild(children) {
  let child = children[0];
  if (children.length > 1) {
    for (const c2 of children) {
      if (c2.type !== Comment) {
        child = c2;
        break;
      }
    }
  }
  return child;
}
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance, postClone) {
  const {
    appear,
    mode,
    persisted = false,
    onBeforeEnter,
    onEnter,
    onAfterEnter,
    onEnterCancelled,
    onBeforeLeave,
    onLeave,
    onAfterLeave,
    onLeaveCancelled,
    onBeforeAppear,
    onAppear,
    onAfterAppear,
    onAppearCancelled
  } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(
      hook,
      instance,
      9,
      args
    );
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray$1(hook)) {
      if (hook.every((hook2) => hook2.length <= 1)) done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el[leaveCbKey]) {
        el[leaveCbKey](
          true
          /* cancelled */
        );
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
        leavingVNode.el[leaveCbKey]();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el[enterCbKey] = (cancelled) => {
        if (called) return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el[enterCbKey] = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove2) {
      const key2 = String(vnode.key);
      if (el[enterCbKey]) {
        el[enterCbKey](
          true
          /* cancelled */
        );
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el]);
      let called = false;
      const done = el[leaveCbKey] = (cancelled) => {
        if (called) return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave, [el]);
        }
        el[leaveCbKey] = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      const hooks2 = resolveTransitionHooks(
        vnode2,
        props,
        state,
        instance,
        postClone
      );
      if (postClone) postClone(hooks2);
      return hooks2;
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getInnerChild$1(vnode) {
  if (!isKeepAlive(vnode)) {
    if (isTeleport(vnode.type) && vnode.children) {
      return findNonCommentChild(vnode.children);
    }
    return vnode;
  }
  const { shapeFlag, children } = vnode;
  if (children) {
    if (shapeFlag & 16) {
      return children[0];
    }
    if (shapeFlag & 32 && isFunction$1(children.default)) {
      return children.default();
    }
  }
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    vnode.transition = hooks;
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i2 = 0; i2 < children.length; i2++) {
    let child = children[i2];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i2);
    if (child.type === Fragment) {
      if (child.patchFlag & 128) keyedFragmentCount++;
      ret = ret.concat(
        getTransitionRawChildren(child.children, keepComment, key)
      );
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i2 = 0; i2 < ret.length; i2++) {
      ret[i2].patchFlag = -2;
    }
  }
  return ret;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function defineComponent(options, extraOptions) {
  return isFunction$1(options) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
  ) : options;
}
function markAsyncBoundary(instance) {
  instance.ids = [instance.ids[0] + instance.ids[2]++ + "-", 0, 0];
}
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$1(rawRef)) {
    rawRef.forEach(
      (r, i2) => setRef(
        r,
        oldRawRef && (isArray$1(oldRawRef) ? oldRawRef[i2] : oldRawRef),
        parentSuspense,
        vnode,
        isUnmount
      )
    );
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    if (vnode.shapeFlag & 512 && vnode.type.__asyncResolved && vnode.component.subTree.component) {
      setRef(rawRef, oldRawRef, parentSuspense, vnode.component.subTree);
    }
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getComponentPublicInstance(vnode.component) : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref3 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  const rawSetupState = toRaw(setupState);
  const canSetSetupRef = setupState === EMPTY_OBJ ? () => false : (key) => {
    return hasOwn(rawSetupState, key);
  };
  if (oldRef != null && oldRef !== ref3) {
    if (isString(oldRef)) {
      refs[oldRef] = null;
      if (canSetSetupRef(oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$1(ref3)) {
    callWithErrorHandling(ref3, owner, 12, [value, refs]);
  } else {
    const _isString = isString(ref3);
    const _isRef = isRef(ref3);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? canSetSetupRef(ref3) ? setupState[ref3] : refs[ref3] : ref3.value;
          if (isUnmount) {
            isArray$1(existing) && remove(existing, refValue);
          } else {
            if (!isArray$1(existing)) {
              if (_isString) {
                refs[ref3] = [refValue];
                if (canSetSetupRef(ref3)) {
                  setupState[ref3] = refs[ref3];
                }
              } else {
                ref3.value = [refValue];
                if (rawRef.k) refs[rawRef.k] = ref3.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref3] = value;
          if (canSetSetupRef(ref3)) {
            setupState[ref3] = value;
          }
        } else if (_isRef) {
          ref3.value = value;
          if (rawRef.k) refs[rawRef.k] = value;
        } else ;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
getGlobalThis().requestIdleCallback || ((cb) => setTimeout(cb, 1));
getGlobalThis().cancelIdleCallback || ((id) => clearTimeout(id));
const isAsyncWrapper = (i2) => !!i2.type.__asyncLoader;
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(
    type,
    hook,
    keepAliveRoot,
    true
    /* prepend */
  );
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      pauseTracking();
      const reset = setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      reset();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => {
  if (!isInSSRComponentSetup || lifecycle === "sp") {
    injectHook(lifecycle, (...args) => hook(...args), target);
  }
};
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook(
  "bu"
);
const onUpdated = createHook("u");
const onBeforeUnmount = createHook(
  "bum"
);
const onUnmounted = createHook("um");
const onServerPrefetch = createHook(
  "sp"
);
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
const COMPONENTS = "components";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
function resolveDynamicComponent(component2) {
  if (isString(component2)) {
    return resolveAsset(COMPONENTS, component2, false) || component2;
  } else {
    return component2 || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    {
      const selfName = getComponentName(
        Component,
        false
      );
      if (selfName && (selfName === name || selfName === camelize$1(name) || selfName === capitalize(camelize$1(name)))) {
        return Component;
      }
    }
    const res = (
      // local registration
      // check instance[type] first which is resolved for options API
      resolve(instance[type] || Component[type], name) || // global registration
      resolve(instance.appContext[type], name)
    );
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize$1(name)] || registry[capitalize(camelize$1(name))]);
}
function renderList(source, renderItem, cache, index2) {
  let ret;
  const cached = cache;
  const sourceIsArray = isArray$1(source);
  if (sourceIsArray || isString(source)) {
    const sourceIsReactiveArray = sourceIsArray && isReactive(source);
    let needsWrap = false;
    if (sourceIsReactiveArray) {
      needsWrap = !isShallow(source);
      source = shallowReadArray(source);
    }
    ret = new Array(source.length);
    for (let i2 = 0, l2 = source.length; i2 < l2; i2++) {
      ret[i2] = renderItem(
        needsWrap ? toReactive(source[i2]) : source[i2],
        i2,
        void 0,
        cached
      );
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i2 = 0; i2 < source; i2++) {
      ret[i2] = renderItem(i2 + 1, i2, void 0, cached);
    }
  } else if (isObject$2(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(
        source,
        (item, i2) => renderItem(item, i2, void 0, cached)
      );
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i2 = 0, l2 = keys.length; i2 < l2; i2++) {
        const key = keys[i2];
        ret[i2] = renderItem(source[key], key, i2, cached);
      }
    }
  } else {
    ret = [];
  }
  return ret;
}
function createSlots(slots, dynamicSlots) {
  for (let i2 = 0; i2 < dynamicSlots.length; i2++) {
    const slot = dynamicSlots[i2];
    if (isArray$1(slot)) {
      for (let j = 0; j < slot.length; j++) {
        slots[slot[j].name] = slot[j].fn;
      }
    } else if (slot) {
      slots[slot.name] = slot.key ? (...args) => {
        const res = slot.fn(...args);
        if (res) res.key = slot.key;
        return res;
      } : slot.fn;
    }
  }
  return slots;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.ce || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.ce) {
    if (name !== "default") props.name = name;
    return openBlock(), createBlock(
      Fragment,
      null,
      [createVNode("slot", props, fallback && fallback())],
      64
    );
  }
  let slot = slots[name];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const slotKey = props.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  validSlotContent && validSlotContent.key;
  const rendered = createBlock(
    Fragment,
    {
      key: (slotKey && !isSymbol(slotKey) ? slotKey : `_${name}`) + // #7256 force differentiate fallback content from actual content
      (!validSlotContent && fallback ? "_fb" : "")
    },
    validSlotContent || (fallback ? fallback() : []),
    validSlotContent && slots._ === 1 ? 64 : -2
  );
  if (rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child)) return true;
    if (child.type === Comment) return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
const getPublicInstance = (i2) => {
  if (!i2) return null;
  if (isStatefulComponent(i2)) return getComponentPublicInstance(i2);
  return getPublicInstance(i2.parent);
};
const publicPropertiesMap = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
    $: (i2) => i2,
    $el: (i2) => i2.vnode.el,
    $data: (i2) => i2.data,
    $props: (i2) => i2.props,
    $attrs: (i2) => i2.attrs,
    $slots: (i2) => i2.slots,
    $refs: (i2) => i2.refs,
    $parent: (i2) => getPublicInstance(i2.parent),
    $root: (i2) => getPublicInstance(i2.root),
    $host: (i2) => i2.ce,
    $emit: (i2) => i2.emit,
    $options: (i2) => resolveMergedOptions(i2),
    $forceUpdate: (i2) => i2.f || (i2.f = () => {
      queueJob(i2.update);
    }),
    $nextTick: (i2) => i2.n || (i2.n = nextTick.bind(i2.proxy)),
    $watch: (i2) => instanceWatch.bind(i2)
  })
);
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    if (key === "__v_skip") {
      return true;
    }
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
      ) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance.attrs, "get", "");
      }
      return publicGetter(instance);
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) && (cssModule = cssModule[key])
    ) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (
      // global properties
      globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
    ) {
      {
        return globalProperties[key];
      }
    } else ;
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({
    _: { data, setupState, accessCache, ctx, appContext, propsOptions }
  }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
function useSlots() {
  return getContext().slots;
}
function getContext() {
  const i2 = getCurrentInstance();
  return i2.setupContext || (i2.setupContext = createSetupContext(i2));
}
function normalizePropsOrEmits(props) {
  return isArray$1(props) ? props.reduce(
    (normalized, p2) => (normalized[p2] = null, normalized),
    {}
  ) : props;
}
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    // state
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    // lifecycle
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    // public API
    expose,
    inheritAttrs,
    // assets
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction$1(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject$2(data)) ;
    else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c2 = computed({
        get,
        set
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c2.value,
        set: (v2) => c2.value = v2
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook$1(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray$1(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$1(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render && instance.render === NOOP) {
    instance.render = render;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components) instance.components = components;
  if (directives) instance.directives = directives;
  if (serverPrefetch) {
    markAsyncBoundary(instance);
  }
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
  if (isArray$1(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$2(opt)) {
      if ("default" in opt) {
        injected = inject(
          opt.from || key,
          opt.default,
          true
        );
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => injected.value,
        set: (v2) => injected.value = v2
      });
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(
    isArray$1(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy),
    instance,
    type
  );
}
function createWatcher(raw, ctx, publicThis, key) {
  let getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString(raw)) {
    const handler = ctx[raw];
    if (isFunction$1(handler)) {
      {
        watch(getter, handler);
      }
    }
  } else if (isFunction$1(raw)) {
    {
      watch(getter, raw.bind(publicThis));
    }
  } else if (isObject$2(raw)) {
    if (isArray$1(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$1(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const {
    mixins: globalMixins,
    optionsCache: cache,
    config: { optionMergeStrategies }
  } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach(
        (m2) => mergeOptions(resolved, m2, optionMergeStrategies, true)
      );
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if (isObject$2(base)) {
    cache.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach(
      (m2) => mergeOptions(to, m2, strats, true)
    );
  }
  for (const key in from) {
    if (asMixin && key === "expose") ;
    else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeEmitsOrPropsOptions,
  emits: mergeEmitsOrPropsOptions,
  // objects
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  // lifecycle
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  // assets
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  // watch
  watch: mergeWatchOptions,
  // provide / inject
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend(
      isFunction$1(to) ? to.call(this, this) : to,
      isFunction$1(from) ? from.call(this, this) : from
    );
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray$1(raw)) {
    const res = {};
    for (let i2 = 0; i2 < raw.length; i2++) {
      res[raw[i2]] = raw[i2];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
}
function mergeEmitsOrPropsOptions(to, from) {
  if (to) {
    if (isArray$1(to) && isArray$1(from)) {
      return [.../* @__PURE__ */ new Set([...to, ...from])];
    }
    return extend(
      /* @__PURE__ */ Object.create(null),
      normalizePropsOrEmits(to),
      normalizePropsOrEmits(from != null ? from : {})
    );
  } else {
    return from;
  }
}
function mergeWatchOptions(to, from) {
  if (!to) return from;
  if (!from) return to;
  const merged = extend(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction$1(rootComponent)) {
      rootComponent = extend({}, rootComponent);
    }
    if (rootProps != null && !isObject$2(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new WeakSet();
    const pluginCleanupFns = [];
    let isMounted = false;
    const app = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version: version$1,
      get config() {
        return context.config;
      },
      set config(v2) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin)) ;
        else if (plugin && isFunction$1(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if (isFunction$1(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else ;
        return app;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app;
      },
      component(name, component2) {
        if (!component2) {
          return context.components[name];
        }
        context.components[name] = component2;
        return app;
      },
      directive(name, directive) {
        if (!directive) {
          return context.directives[name];
        }
        context.directives[name] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, namespace) {
        if (!isMounted) {
          const vnode = app._ceVNode || createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (namespace === true) {
            namespace = "svg";
          } else if (namespace === false) {
            namespace = void 0;
          }
          {
            render(vnode, rootContainer, namespace);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          return getComponentPublicInstance(vnode.component);
        }
      },
      onUnmount(cleanupFn) {
        pluginCleanupFns.push(cleanupFn);
      },
      unmount() {
        if (isMounted) {
          callWithAsyncErrorHandling(
            pluginCleanupFns,
            app._instance,
            16
          );
          render(null, app._container);
          delete app._container.__vue_app__;
        }
      },
      provide(key, value) {
        context.provides[key] = value;
        return app;
      },
      runWithContext(fn) {
        const lastApp = currentApp;
        currentApp = app;
        try {
          return fn();
        } finally {
          currentApp = lastApp;
        }
      }
    };
    return app;
  };
}
let currentApp = null;
function provide(key, value) {
  if (!currentInstance) ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance || currentApp) {
    const provides = currentApp ? currentApp._context.provides : instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : void 0;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
    } else ;
  }
}
const internalObjectProto = {};
const createInternalObject = () => Object.create(internalObjectProto);
const isInternalObject = (obj) => Object.getPrototypeOf(obj) === internalObjectProto;
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = createInternalObject();
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const {
    props,
    attrs,
    vnode: { patchFlag }
  } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (optimized || patchFlag > 0) && !(patchFlag & 16)
  ) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
        let key = propsToUpdate[i2];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize$1(key);
            props[camelizedKey] = resolvePropValue(
              options,
              rawCurrentProps,
              camelizedKey,
              value,
              instance,
              false
            );
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || // for camelCase
      !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && // for camelCase
          (rawPrevProps[key] !== void 0 || // for kebab-case
          rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(
              options,
              rawCurrentProps,
              key,
              void 0,
              instance,
              true
            );
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance.attrs, "set", "");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize$1(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i2 = 0; i2 < needCastKeys.length; i2++) {
      const key = needCastKeys[i2];
      props[key] = resolvePropValue(
        options,
        rawCurrentProps,
        key,
        castValues[key],
        instance,
        !hasOwn(castValues, key)
      );
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && !opt.skipFactory && isFunction$1(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          const reset = setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(
            null,
            props
          );
          reset();
        }
      } else {
        value = defaultValue;
      }
      if (instance.ce) {
        instance.ce._setProp(key, value);
      }
    }
    if (opt[
      0
      /* shouldCast */
    ]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[
        1
        /* shouldCastTrue */
      ] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
const mixinPropsCache = /* @__PURE__ */ new WeakMap();
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = asMixin ? mixinPropsCache : appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$1(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend(normalized, props);
      if (keys) needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$2(comp)) {
      cache.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray$1(raw)) {
    for (let i2 = 0; i2 < raw.length; i2++) {
      const normalizedKey = camelize$1(raw[i2]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize$1(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray$1(opt) || isFunction$1(opt) ? { type: opt } : extend({}, opt);
        const propType = prop.type;
        let shouldCast = false;
        let shouldCastTrue = true;
        if (isArray$1(propType)) {
          for (let index2 = 0; index2 < propType.length; ++index2) {
            const type = propType[index2];
            const typeName = isFunction$1(type) && type.name;
            if (typeName === "Boolean") {
              shouldCast = true;
              break;
            } else if (typeName === "String") {
              shouldCastTrue = false;
            }
          }
        } else {
          shouldCast = isFunction$1(propType) && propType.name === "Boolean";
        }
        prop[
          0
          /* shouldCast */
        ] = shouldCast;
        prop[
          1
          /* shouldCastTrue */
        ] = shouldCastTrue;
        if (shouldCast || hasOwn(prop, "default")) {
          needCastKeys.push(normalizedKey);
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$2(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$" && !isReservedProp(key)) {
    return true;
  }
  return false;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray$1(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false) ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key)) continue;
    const value = rawSlots[key];
    if (isFunction$1(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const assignSlots = (slots, children, optimized) => {
  for (const key in children) {
    if (optimized || key !== "_") {
      slots[key] = children[key];
    }
  }
};
const initSlots = (instance, children, optimized) => {
  const slots = instance.slots = createInternalObject();
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      assignSlots(slots, children, optimized);
      if (optimized) {
        def(slots, "_", type, true);
      }
    } else {
      normalizeObjectSlots(children, slots);
    }
  } else if (children) {
    normalizeVNodeSlots(instance, children);
  }
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        assignSlots(slots, children, optimized);
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
        delete slots[key];
      }
    }
  }
};
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis();
  target.__VUE__ = true;
  const {
    insert: hostInsert,
    remove: hostRemove,
    patchProp: hostPatchProp,
    createElement: hostCreateElement,
    createText: hostCreateText,
    createComment: hostCreateComment,
    setText: hostSetText,
    setElementText: hostSetElementText,
    parentNode: hostParentNode,
    nextSibling: hostNextSibling,
    setScopeId: hostSetScopeId = NOOP,
    insertStaticContent: hostInsertStaticContent
  } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref3, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, namespace);
        }
        break;
      case Fragment:
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        break;
      default:
        if (shapeFlag & 1) {
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 6) {
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (shapeFlag & 64) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else if (shapeFlag & 128) {
          type.process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized,
            internals
          );
        } else ;
    }
    if (ref3 != null && parentComponent) {
      setRef(ref3, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateText(n2.children),
        container,
        anchor
      );
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(
        n2.el = hostCreateComment(n2.children || ""),
        container,
        anchor
      );
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, namespace) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(
      n2.children,
      container,
      anchor,
      namespace,
      n2.el,
      n2.anchor
    );
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    if (n2.type === "svg") {
      namespace = "svg";
    } else if (n2.type === "math") {
      namespace = "mathml";
    }
    if (n1 == null) {
      mountElement(
        n2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      patchElement(
        n1,
        n2,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { props, shapeFlag, transition, dirs } = vnode;
    el = vnode.el = hostCreateElement(
      vnode.type,
      namespace,
      props && props.is,
      props
    );
    if (shapeFlag & 8) {
      hostSetElementText(el, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(
        vnode.children,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(vnode, namespace),
        slotScopeIds,
        optimized
      );
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(el, key, null, props[key], namespace, parentComponent);
        }
      }
      if ("value" in props) {
        hostPatchProp(el, "value", null, props.value, namespace);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = needTransition(parentSuspense, transition);
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
        hostSetScopeId(el, slotScopeIds[i2]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree || isSuspense(subTree.type) && (subTree.ssContent === vnode || subTree.ssFallback === vnode)) {
        const parentVNode = parentComponent.vnode;
        setScopeId(
          el,
          parentVNode,
          parentVNode.scopeId,
          parentVNode.slotScopeIds,
          parentComponent.parent
        );
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
    for (let i2 = start; i2 < children.length; i2++) {
      const child = children[i2] = optimized ? cloneIfMounted(children[i2]) : normalizeVNode(children[i2]);
      patch(
        null,
        child,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    if (oldProps.innerHTML && newProps.innerHTML == null || oldProps.textContent && newProps.textContent == null) {
      hostSetElementText(el, "");
    }
    if (dynamicChildren) {
      patchBlockChildren(
        n1.dynamicChildren,
        dynamicChildren,
        el,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds
      );
    } else if (!optimized) {
      patchChildren(
        n1,
        n2,
        el,
        null,
        parentComponent,
        parentSuspense,
        resolveChildrenNamespace(n2, namespace),
        slotScopeIds,
        false
      );
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, oldProps, newProps, parentComponent, namespace);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, namespace);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
            const key = propsToUpdate[i2];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el, key, prev, next, namespace, parentComponent);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, oldProps, newProps, parentComponent, namespace);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
    for (let i2 = 0; i2 < newChildren.length; i2++) {
      const oldVNode = oldChildren[i2];
      const newVNode = newChildren[i2];
      const container = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
        oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          fallbackContainer
        )
      );
      patch(
        oldVNode,
        newVNode,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        true
      );
    }
  };
  const patchProps = (el, oldProps, newProps, parentComponent, namespace) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(
              el,
              key,
              oldProps[key],
              null,
              namespace,
              parentComponent
            );
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key)) continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el, key, prev, next, namespace, parentComponent);
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(
        // #10007
        // such fragment like `<></>` will be compiled into
        // a fragment which doesn't have a children.
        // In this case fallback to an empty array
        n2.children || [],
        container,
        fragmentEndAnchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
      // of renderSlot() with no valid children
      n1.dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          container,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds
        );
        if (
          // #2080 if the stable fragment has a key, it's a <template v-for> that may
          //  get moved around. Make sure all root level vnodes inherit el.
          // #2134 or if it's a component root, it may also get moved around
          // as the component is being moved.
          n2.key != null || parentComponent && n2 === parentComponent.subTree
        ) {
          traverseStaticChildren(
            n1,
            n2,
            true
            /* shallow */
          );
        }
      } else {
        patchChildren(
          n1,
          n2,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(
          n2,
          container,
          anchor,
          namespace,
          optimized
        );
      } else {
        mountComponent(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          optimized
        );
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
    const instance = initialVNode.component = createComponentInstance(
      initialVNode,
      parentComponent,
      parentSuspense
    );
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance, false, optimized);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect, optimized);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
    } else {
      setupRenderEffect(
        instance,
        initialVNode,
        container,
        anchor,
        parentSuspense,
        namespace,
        optimized
      );
    }
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m: m2, parent, root, type } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        {
          if (root.ce) {
            root.ce._injectChildStyle(type);
          }
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(
            null,
            subTree,
            container,
            anchor,
            instance,
            parentSuspense,
            namespace
          );
          initialVNode.el = subTree.el;
        }
        if (m2) {
          queuePostRenderEffect(m2, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
            parentSuspense
          );
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u: u2, parent, vnode } = instance;
        {
          const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
          if (nonHydratedAsyncRoot) {
            if (next) {
              next.el = vnode.el;
              updateComponentPreRender(instance, next, optimized);
            }
            nonHydratedAsyncRoot.asyncDep.then(() => {
              if (!instance.isUnmounted) {
                componentUpdateFn();
              }
            });
            return;
          }
        }
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          hostParentNode(prevTree.el),
          // anchor may have changed if it's in a fragment
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          namespace
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u2) {
          queuePostRenderEffect(u2, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(
            () => invokeVNodeHook(vnodeHook, parent, next, vnode),
            parentSuspense
          );
        }
      }
    };
    instance.scope.on();
    const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn);
    instance.scope.off();
    const update = instance.update = effect2.run.bind(effect2);
    const job = instance.job = effect2.runIfDirty.bind(effect2);
    job.i = instance;
    job.id = instance.uid;
    effect2.scheduler = () => queueJob(job);
    toggleRecurse(instance, true);
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(instance);
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(
          c1,
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i2;
    for (i2 = 0; i2 < commonLength; i2++) {
      const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      patch(
        c1[i2],
        nextChild,
        container,
        null,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized
      );
    }
    if (oldLength > newLength) {
      unmountChildren(
        c1,
        parentComponent,
        parentSuspense,
        true,
        false,
        commonLength
      );
    } else {
      mountChildren(
        c2,
        container,
        anchor,
        parentComponent,
        parentSuspense,
        namespace,
        slotScopeIds,
        optimized,
        commonLength
      );
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
    let i2 = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i2 <= e1 && i2 <= e2) {
      const n1 = c1[i2];
      const n2 = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      i2++;
    }
    while (i2 <= e1 && i2 <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(
          n1,
          n2,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i2 > e1) {
      if (i2 <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i2 <= e2) {
          patch(
            null,
            c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]),
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          i2++;
        }
      }
    } else if (i2 > e2) {
      while (i2 <= e1) {
        unmount(c1[i2], parentComponent, parentSuspense, true);
        i2++;
      }
    } else {
      const s1 = i2;
      const s2 = i2;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i2 = s2; i2 <= e2; i2++) {
        const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i2);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i2 = 0; i2 < toBePatched; i2++) newIndexToOldIndexMap[i2] = 0;
      for (i2 = s1; i2 <= e1; i2++) {
        const prevChild = c1[i2];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i2 + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(
            prevChild,
            c2[newIndex],
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i2 = toBePatched - 1; i2 >= 0; i2--) {
        const nextIndex = s2 + i2;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i2] === 0) {
          patch(
            null,
            nextChild,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else if (moved) {
          if (j < 0 || i2 !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i2 = 0; i2 < children.length; i2++) {
        move(children[i2], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition2) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove22 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove22();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove22, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const {
      type,
      props,
      ref: ref3,
      children,
      dynamicChildren,
      shapeFlag,
      patchFlag,
      dirs,
      cacheIndex
    } = vnode;
    if (patchFlag === -2) {
      optimized = false;
    }
    if (ref3 != null) {
      setRef(ref3, null, parentSuspense, vnode, true);
    }
    if (cacheIndex != null) {
      parentComponent.renderCache[cacheIndex] = void 0;
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(
          vnode,
          parentComponent,
          parentSuspense,
          internals,
          doRemove
        );
      } else if (dynamicChildren && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !dynamicChildren.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(
          dynamicChildren,
          parentComponent,
          parentSuspense,
          false,
          true
        );
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, job, subTree, um, m: m2, a: a2 } = instance;
    invalidateMount(m2);
    invalidateMount(a2);
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (job) {
      job.flags |= 8;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i2 = start; i2 < children.length; i2++) {
      unmount(children[i2], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    const el = hostNextSibling(vnode.anchor || vnode.el);
    const teleportEnd = el && el[TeleportEndKey];
    return teleportEnd ? hostNextSibling(teleportEnd) : el;
  };
  let isFlushing = false;
  const render = (vnode, container, namespace) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(
        container._vnode || null,
        vnode,
        container,
        null,
        null,
        null,
        namespace
      );
    }
    container._vnode = vnode;
    if (!isFlushing) {
      isFlushing = true;
      flushPreFlushCbs();
      flushPostFlushCbs();
      isFlushing = false;
    }
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  return {
    render,
    hydrate,
    createApp: createAppAPI(render)
  };
}
function resolveChildrenNamespace({ type, props }, currentNamespace) {
  return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
}
function toggleRecurse({ effect: effect2, job }, allowed) {
  if (allowed) {
    effect2.flags |= 32;
    job.flags |= 4;
  } else {
    effect2.flags &= ~32;
    job.flags &= ~4;
  }
}
function needTransition(parentSuspense, transition) {
  return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$1(ch1) && isArray$1(ch2)) {
    for (let i2 = 0; i2 < ch1.length; i2++) {
      const c1 = ch1[i2];
      let c2 = ch2[i2];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i2] = cloneIfMounted(ch2[i2]);
          c2.el = c1.el;
        }
        if (!shallow && c2.patchFlag !== -2)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i2, j, u2, v2, c2;
  const len = arr.length;
  for (i2 = 0; i2 < len; i2++) {
    const arrI = arr[i2];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p2[i2] = j;
        result.push(i2);
        continue;
      }
      u2 = 0;
      v2 = result.length - 1;
      while (u2 < v2) {
        c2 = u2 + v2 >> 1;
        if (arr[result[c2]] < arrI) {
          u2 = c2 + 1;
        } else {
          v2 = c2;
        }
      }
      if (arrI < arr[result[u2]]) {
        if (u2 > 0) {
          p2[i2] = result[u2 - 1];
        }
        result[u2] = i2;
      }
    }
  }
  u2 = result.length;
  v2 = result[u2 - 1];
  while (u2-- > 0) {
    result[u2] = v2;
    v2 = p2[v2];
  }
  return result;
}
function locateNonHydratedAsyncRoot(instance) {
  const subComponent = instance.subTree.component;
  if (subComponent) {
    if (subComponent.asyncDep && !subComponent.asyncResolved) {
      return subComponent;
    } else {
      return locateNonHydratedAsyncRoot(subComponent);
    }
  }
}
function invalidateMount(hooks) {
  if (hooks) {
    for (let i2 = 0; i2 < hooks.length; i2++)
      hooks[i2].flags |= 8;
  }
}
const ssrContextKey = Symbol.for("v-scx");
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    return ctx;
  }
};
function watchEffect(effect2, options) {
  return doWatch(effect2, null, options);
}
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, options = EMPTY_OBJ) {
  const { immediate, deep, flush, once } = options;
  const baseWatchOptions = extend({}, options);
  const runsImmediately = cb && immediate || !cb && flush !== "post";
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else if (!runsImmediately) {
      const watchStopHandle = () => {
      };
      watchStopHandle.stop = NOOP;
      watchStopHandle.resume = NOOP;
      watchStopHandle.pause = NOOP;
      return watchStopHandle;
    }
  }
  const instance = currentInstance;
  baseWatchOptions.call = (fn, type, args) => callWithAsyncErrorHandling(fn, instance, type, args);
  let isPre = false;
  if (flush === "post") {
    baseWatchOptions.scheduler = (job) => {
      queuePostRenderEffect(job, instance && instance.suspense);
    };
  } else if (flush !== "sync") {
    isPre = true;
    baseWatchOptions.scheduler = (job, isFirstRun) => {
      if (isFirstRun) {
        job();
      } else {
        queueJob(job);
      }
    };
  }
  baseWatchOptions.augmentJob = (job) => {
    if (cb) {
      job.flags |= 4;
    }
    if (isPre) {
      job.flags |= 2;
      if (instance) {
        job.id = instance.uid;
        job.i = instance;
      }
    }
  };
  const watchHandle = watch$1(source, cb, baseWatchOptions);
  if (isInSSRComponentSetup) {
    if (ssrCleanup) {
      ssrCleanup.push(watchHandle);
    } else if (runsImmediately) {
      watchHandle();
    }
  }
  return watchHandle;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction$1(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const reset = setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  reset();
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i2 = 0; i2 < segments.length && cur; i2++) {
      cur = cur[segments[i2]];
    }
    return cur;
  };
}
const getModelModifiers = (props, modelName) => {
  return modelName === "modelValue" || modelName === "model-value" ? props.modelModifiers : props[`${modelName}Modifiers`] || props[`${camelize$1(modelName)}Modifiers`] || props[`${hyphenate(modelName)}Modifiers`];
};
function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted) return;
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modifiers = isModelListener2 && getModelModifiers(props, event.slice(7));
  if (modifiers) {
    if (modifiers.trim) {
      args = rawArgs.map((a2) => isString(a2) ? a2.trim() : a2);
    }
    if (modifiers.number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
  props[handlerName = toHandlerKey(camelize$1(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(
      handler,
      instance,
      6,
      args
    );
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(
      onceHandler,
      instance,
      6,
      args
    );
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$1(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$2(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if (isArray$1(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend(normalized, raw);
  }
  if (isObject$2(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const {
    type: Component,
    vnode,
    proxy,
    withProxy,
    propsOptions: [propsOptions],
    slots,
    attrs,
    emit: emit2,
    render,
    renderCache,
    props,
    data,
    setupState,
    ctx,
    inheritAttrs
  } = instance;
  const prev = setCurrentRenderingInstance(instance);
  let result;
  let fallthroughAttrs;
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      const thisProxy = false ? new Proxy(proxyToUse, {
        get(target, key, receiver) {
          warn$1(
            `Property '${String(
              key
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
          );
          return Reflect.get(target, key, receiver);
        }
      }) : proxyToUse;
      result = normalizeVNode(
        render.call(
          thisProxy,
          proxyToUse,
          renderCache,
          false ? shallowReadonly(props) : props,
          setupState,
          data,
          ctx
        )
      );
      fallthroughAttrs = attrs;
    } else {
      const render2 = Component;
      if (false) ;
      result = normalizeVNode(
        render2.length > 1 ? render2(
          false ? shallowReadonly(props) : props,
          false ? {
            get attrs() {
              markAttrsAccessed();
              return shallowReadonly(attrs);
            },
            slots,
            emit: emit2
          } : { attrs, slots, emit: emit2 }
        ) : render2(
          false ? shallowReadonly(props) : props,
          null
        )
      );
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(
            fallthroughAttrs,
            propsOptions
          );
        }
        root = cloneVNode(root, fallthroughAttrs, false, true);
      }
    }
  }
  if (vnode.dirs) {
    root = cloneVNode(root, null, false, true);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    setTransitionHooks(root, vnode.transition);
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component: component2 } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component2.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i2 = 0; i2 < dynamicProps.length; i2++) {
        const key = dynamicProps[i2];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i2 = 0; i2 < nextKeys.length; i2++) {
    const key = nextKeys[i2];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent) {
    const root = parent.subTree;
    if (root.suspense && root.suspense.activeBranch === vnode) {
      root.el = vnode.el;
    }
    if (root === vnode) {
      (vnode = parent.vnode).el = el;
      parent = parent.parent;
    } else {
      break;
    }
  }
}
const isSuspense = (type) => type.__isSuspense;
function queueEffectWithSuspense(fn, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$1(fn)) {
      suspense.effects.push(...fn);
    } else {
      suspense.effects.push(fn);
    }
  } else {
    queuePostFlushCb(fn);
  }
}
const Fragment = Symbol.for("v-fgt");
const Text = Symbol.for("v-txt");
const Comment = Symbol.for("v-cmt");
const Static = Symbol.for("v-stc");
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value, inVOnce = false) {
  isBlockTreeEnabled += value;
  if (value < 0 && currentBlock && inVOnce) {
    currentBlock.hasOnce = true;
  }
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true
    )
  );
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(
    createVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      true
    )
  );
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({
  ref: ref3,
  ref_key,
  ref_for
}) => {
  if (typeof ref3 === "number") {
    ref3 = "" + ref3;
  }
  return ref3 != null ? isString(ref3) || isRef(ref3) || isFunction$1(ref3) ? { i: currentRenderingInstance, r: ref3, k: ref_key, f: !!ref_for } : ref3 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
  !isBlockNode && // has current parent block
  currentBlock && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(
      type,
      props,
      true
      /* mergeRef: true */
    );
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag = -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$2(style)) {
      if (isProxy(style) && !isArray$1(style)) {
        style = extend({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$2(type) ? 4 : isFunction$1(type) ? 2 : 0;
  return createBaseVNode(
    type,
    props,
    children,
    patchFlag,
    dynamicProps,
    shapeFlag,
    isBlockNode,
    true
  );
}
function guardReactiveProps(props) {
  if (!props) return null;
  return isProxy(props) || isInternalObject(props) ? extend({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false, cloneTransition = false) {
  const { props, ref: ref3, patchFlag, children, transition } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      mergeRef && ref3 ? isArray$1(ref3) ? ref3.concat(normalizeRef(extraProps)) : [ref3, normalizeRef(extraProps)] : normalizeRef(extraProps)
    ) : ref3,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetStart: vnode.targetStart,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  if (transition && cloneTransition) {
    setTransitionHooks(
      cloned,
      transition.clone(cloned)
    );
  }
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray$1(child)) {
    return createVNode(
      Fragment,
      null,
      // #3666, avoid reference pollution when reusing vnode
      child.slice()
    );
  } else if (isVNode(child)) {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray$1(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !isInternalObject(children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$1(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i2 = 0; i2 < args.length; i2++) {
    const toMerge = args[i2];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray$1(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new EffectScope(
      true
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    ids: parent ? parent.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: EMPTY_OBJ,
    // inheritAttrs
    inheritAttrs: type.inheritAttrs,
    // state
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    // suspense related
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
let internalSetCurrentInstance;
let setInSSRSetupState;
{
  const g2 = getGlobalThis();
  const registerGlobalSetter = (key, setter) => {
    let setters;
    if (!(setters = g2[key])) setters = g2[key] = [];
    setters.push(setter);
    return (v2) => {
      if (setters.length > 1) setters.forEach((set) => set(v2));
      else setters[0](v2);
    };
  };
  internalSetCurrentInstance = registerGlobalSetter(
    `__VUE_INSTANCE_SETTERS__`,
    (v2) => currentInstance = v2
  );
  setInSSRSetupState = registerGlobalSetter(
    `__VUE_SSR_SETTERS__`,
    (v2) => isInSSRComponentSetup = v2
  );
}
const setCurrentInstance = (instance) => {
  const prev = currentInstance;
  internalSetCurrentInstance(instance);
  instance.scope.on();
  return () => {
    instance.scope.off();
    internalSetCurrentInstance(prev);
  };
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  internalSetCurrentInstance(null);
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false, optimized = false) {
  isSSR && setInSSRSetupState(isSSR);
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children, optimized);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isSSR && setInSSRSetupState(false);
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers);
  const { setup } = Component;
  if (setup) {
    pauseTracking();
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    const reset = setCurrentInstance(instance);
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      0,
      [
        instance.props,
        setupContext
      ]
    );
    const isAsyncSetup = isPromise$1(setupResult);
    resetTracking();
    reset();
    if ((isAsyncSetup || instance.sp) && !isAsyncWrapper(instance)) {
      markAsyncBoundary(instance);
    }
    if (isAsyncSetup) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult);
    }
  } else {
    finishComponentSetup(instance);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$1(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$2(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else ;
  finishComponentSetup(instance);
}
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    instance.render = Component.render || NOOP;
  }
  {
    const reset = setCurrentInstance(instance);
    pauseTracking();
    try {
      applyOptions(instance);
    } finally {
      resetTracking();
      reset();
    }
  }
}
const attrsProxyHandlers = {
  get(target, key) {
    track(target, "get", "");
    return target[key];
  }
};
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  {
    return {
      attrs: new Proxy(instance.attrs, attrsProxyHandlers),
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getComponentPublicInstance(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  } else {
    return instance.proxy;
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c2) => c2.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name = match[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(
      instance.components || instance.parent.type.components
    ) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return isFunction$1(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  const c2 = computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
  return c2;
};
function h$2(type, propsOrChildren, children) {
  const l2 = arguments.length;
  if (l2 === 2) {
    if (isObject$2(propsOrChildren) && !isArray$1(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l2 > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l2 === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
const version$1 = "3.5.13";
/**
* @vue/runtime-dom v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let policy = void 0;
const tt = typeof window !== "undefined" && window.trustedTypes;
if (tt) {
  try {
    policy = /* @__PURE__ */ tt.createPolicy("vue", {
      createHTML: (val) => val
    });
  } catch (e) {
  }
}
const unsafeToTrustedHTML = policy ? (val) => policy.createHTML(val) : (val) => val;
const svgNS = "http://www.w3.org/2000/svg";
const mathmlNS = "http://www.w3.org/1998/Math/MathML";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, namespace, is, props) => {
    const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : is ? doc.createElement(tag, { is }) : doc.createElement(tag);
    if (tag === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(content, parent, anchor, namespace, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling)) break;
      }
    } else {
      templateContainer.innerHTML = unsafeToTrustedHTML(
        namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content
      );
      const template = templateContainer.content;
      if (namespace === "svg" || namespace === "mathml") {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      // first
      before ? before.nextSibling : parent.firstChild,
      // last
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
const TRANSITION = "transition";
const ANIMATION = "animation";
const vtcKey = Symbol("_vtc");
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = /* @__PURE__ */ extend(
  {},
  BaseTransitionPropsValidators,
  DOMTransitionPropsValidators
);
const decorate$1 = (t) => {
  t.displayName = "Transition";
  t.props = TransitionPropsValidators;
  return t;
};
const Transition = /* @__PURE__ */ decorate$1(
  (props, { slots }) => h$2(BaseTransition, resolveTransitionProps(props), slots)
);
const callHook = (hook, args = []) => {
  if (isArray$1(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray$1(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps2 = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps2[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps2;
  }
  const {
    name = "v",
    type,
    duration,
    enterFromClass = `${name}-enter-from`,
    enterActiveClass = `${name}-enter-active`,
    enterToClass = `${name}-enter-to`,
    appearFromClass = enterFromClass,
    appearActiveClass = enterActiveClass,
    appearToClass = enterToClass,
    leaveFromClass = `${name}-leave-from`,
    leaveActiveClass = `${name}-leave-active`,
    leaveToClass = `${name}-leave-to`
  } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const {
    onBeforeEnter,
    onEnter,
    onEnterCancelled,
    onLeave,
    onLeaveCancelled,
    onBeforeAppear = onBeforeEnter,
    onAppear = onEnter,
    onAppearCancelled = onEnterCancelled
  } = baseProps2;
  const finishEnter = (el, isAppear, done, isCancelled) => {
    el._enterCancelled = isCancelled;
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve2 = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve2]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve2);
        }
      });
    };
  };
  return extend(baseProps2, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve2 = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      if (!el._enterCancelled) {
        forceReflow();
        addTransitionClass(el, leaveActiveClass);
      } else {
        addTransitionClass(el, leaveActiveClass);
        forceReflow();
      }
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve2);
        }
      });
      callHook(onLeave, [el, resolve2]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false, void 0, true);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true, void 0, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject$2(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c2) => c2 && el.classList.add(c2));
  (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c2) => c2 && el.classList.remove(c2));
  const _vtc = el[vtcKey];
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el[vtcKey] = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve2();
    }
  };
  if (explicitTimeout != null) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve2();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
    getStyleProperties(`${TRANSITION}Property`).toString()
  );
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d2, i2) => toMs(d2) + toMs(delays[i2])));
}
function toMs(s) {
  if (s === "auto") return 0;
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
function patchClass(el, value, isSVG) {
  const transitionClasses = el[vtcKey];
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
const vShowOriginalDisplay = Symbol("_vod");
const vShowHidden = Symbol("_vsh");
const vShow = {
  beforeMount(el, { value }, { transition }) {
    el[vShowOriginalDisplay] = el.style.display === "none" ? "" : el.style.display;
    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },
  mounted(el, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el);
    }
  },
  updated(el, { value, oldValue }, { transition }) {
    if (!value === !oldValue) return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },
  beforeUnmount(el, { value }) {
    setDisplay(el, value);
  }
};
function setDisplay(el, value) {
  el.style.display = value ? el[vShowOriginalDisplay] : "none";
  el[vShowHidden] = !value;
}
const CSS_VAR_TEXT = Symbol("");
const displayRE = /(^|;)\s*display\s*:/;
function patchStyle(el, prev, next) {
  const style = el.style;
  const isCssString = isString(next);
  let hasControlledDisplay = false;
  if (next && !isCssString) {
    if (prev) {
      if (!isString(prev)) {
        for (const key in prev) {
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      } else {
        for (const prevStyle of prev.split(";")) {
          const key = prevStyle.slice(0, prevStyle.indexOf(":")).trim();
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      }
    }
    for (const key in next) {
      if (key === "display") {
        hasControlledDisplay = true;
      }
      setStyle(style, key, next[key]);
    }
  } else {
    if (isCssString) {
      if (prev !== next) {
        const cssVarText = style[CSS_VAR_TEXT];
        if (cssVarText) {
          next += ";" + cssVarText;
        }
        style.cssText = next;
        hasControlledDisplay = displayRE.test(next);
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
  }
  if (vShowOriginalDisplay in el) {
    el[vShowOriginalDisplay] = hasControlledDisplay ? style.display : "";
    if (el[vShowHidden]) {
      style.display = "none";
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
  if (isArray$1(val)) {
    val.forEach((v2) => setStyle(style, name, v2));
  } else {
    if (val == null) val = "";
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty(
          hyphenate(prefixed),
          val.replace(importantRE, ""),
          "important"
        );
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize$1(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = capitalize(name);
  for (let i2 = 0; i2 < prefixes.length; i2++) {
    const prefixed = prefixes[i2] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance, isBoolean = isSpecialBooleanAttr(key)) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (value == null || isBoolean && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(
        key,
        isBoolean ? "" : isSymbol(value) ? String(value) : value
      );
    }
  }
}
function patchDOMProp(el, key, value, parentComponent, attrName) {
  if (key === "innerHTML" || key === "textContent") {
    if (value != null) {
      el[key] = key === "innerHTML" ? unsafeToTrustedHTML(value) : value;
    }
    return;
  }
  const tag = el.tagName;
  if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
  !tag.includes("-")) {
    const oldValue = tag === "OPTION" ? el.getAttribute("value") || "" : el.value;
    const newValue = value == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      el.type === "checkbox" ? "on" : ""
    ) : String(value);
    if (oldValue !== newValue || !("_value" in el)) {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    el._value = value;
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e) {
  }
  needRemove && el.removeAttribute(attrName || key);
}
function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
const veiKey = Symbol("_vei");
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el[veiKey] || (el[veiKey] = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(
        nextValue,
        instance
      );
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m2;
    while (m2 = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m2[0].length);
      options[m2[0].toLowerCase()] = true;
    }
  }
  const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p$G = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p$G.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    if (!e._vts) {
      e._vts = Date.now();
    } else if (e._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(
      patchStopImmediatePropagation(e, invoker.value),
      instance,
      5,
      [e]
    );
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray$1(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map(
      (fn) => (e2) => !e2._stopped && fn && fn(e2)
    );
  } else {
    return value;
  }
}
const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
const patchProp = (el, key, prevValue, nextValue, namespace, parentComponent) => {
  const isSVG = namespace === "svg";
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(el, key, nextValue);
    if (!el.tagName.includes("-") && (key === "value" || key === "checked" || key === "selected")) {
      patchAttr(el, key, nextValue, isSVG, parentComponent, key !== "value");
    }
  } else if (
    // #11081 force set props for possible async custom element
    el._isVueCE && (/[A-Z]/.test(key) || !isString(nextValue))
  ) {
    patchDOMProp(el, camelize$1(key), nextValue, parentComponent, key);
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && isNativeOn(key) && isFunction$1(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (key === "width" || key === "height") {
    const tag = el.tagName;
    if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
      return false;
    }
  }
  if (isNativeOn(key) && isString(value)) {
    return false;
  }
  return key in el;
}
const getModelAssigner = (vnode) => {
  const fn = vnode.props["onUpdate:modelValue"] || false;
  return isArray$1(fn) ? (value) => invokeArrayFns(fn, value) : fn;
};
function onCompositionStart(e) {
  e.target.composing = true;
}
function onCompositionEnd(e) {
  const target = e.target;
  if (target.composing) {
    target.composing = false;
    target.dispatchEvent(new Event("input"));
  }
}
const assignKey = Symbol("_assign");
const vModelText = {
  created(el, { modifiers: { lazy, trim, number } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    const castToNumber = number || vnode.props && vnode.props.type === "number";
    addEventListener(el, lazy ? "change" : "input", (e) => {
      if (e.target.composing) return;
      let domValue = el.value;
      if (trim) {
        domValue = domValue.trim();
      }
      if (castToNumber) {
        domValue = looseToNumber(domValue);
      }
      el[assignKey](domValue);
    });
    if (trim) {
      addEventListener(el, "change", () => {
        el.value = el.value.trim();
      });
    }
    if (!lazy) {
      addEventListener(el, "compositionstart", onCompositionStart);
      addEventListener(el, "compositionend", onCompositionEnd);
      addEventListener(el, "change", onCompositionEnd);
    }
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(el, { value }) {
    el.value = value == null ? "" : value;
  },
  beforeUpdate(el, { value, oldValue, modifiers: { lazy, trim, number } }, vnode) {
    el[assignKey] = getModelAssigner(vnode);
    if (el.composing) return;
    const elValue = (number || el.type === "number") && !/^0\d/.test(el.value) ? looseToNumber(el.value) : el.value;
    const newValue = value == null ? "" : value;
    if (elValue === newValue) {
      return;
    }
    if (document.activeElement === el && el.type !== "range") {
      if (lazy && value === oldValue) {
        return;
      }
      if (trim && el.value.trim() === newValue) {
        return;
      }
    }
    el.value = newValue;
  }
};
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, modifiers) => systemModifiers.some((m2) => e[`${m2}Key`] && !modifiers.includes(m2))
};
const withModifiers = (fn, modifiers) => {
  const cache = fn._withMods || (fn._withMods = {});
  const cacheKey = modifiers.join(".");
  return cache[cacheKey] || (cache[cacheKey] = (event, ...args) => {
    for (let i2 = 0; i2 < modifiers.length; i2++) {
      const guard = modifierGuards[modifiers[i2]];
      if (guard && guard(event, modifiers)) return;
    }
    return fn(event, ...args);
  });
};
const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container) return;
    const component2 = app._component;
    if (!isFunction$1(component2) && !component2.render && !component2.template) {
      component2.template = container.innerHTML;
    }
    if (container.nodeType === 1) {
      container.textContent = "";
    }
    const proxy = mount(container, false, resolveRootNamespace(container));
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
function resolveRootNamespace(container) {
  if (container instanceof SVGElement) {
    return "svg";
  }
  if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
    return "mathml";
  }
}
function normalizeContainer(container) {
  if (isString(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
const CmpUi = /* @__PURE__ */ defineComponent({
  name: "cmp-ui",
  props: {
    title: {
      type: String,
      default: ""
    }
  },
  setup() {
    const data = ref({});
    const methods = {
      loadData: () => {
        flutterApp.getNavigationBarConfig({
          success: function(res) {
            console.log("回调结果: res getNavigationBarConfig");
            console.log(res);
            Object.assign(data.value, res);
          },
          fail: function(error) {
            console.log("error", error);
          }
        });
      },
      showToast: () => {
        flutterApp.showToast({
          text: "我就是我的提示",
          success: function(res) {
            console.log("回调结果: res showToast");
          },
          fail: function(error) {
            console.log("error", error);
          }
        });
      },
      showModal: () => {
        flutterApp.showModal({
          title: "处理成功啦",
          content: "告知当前状态、信息和解决方法，等内容。描述尽可能控制在三行内。",
          cancelText: "取消",
          confirmText: "确定",
          success: function(res) {
            console.log("回调结果: res showToast");
          },
          fail: function(error) {
            console.log("error", error);
          }
        });
      },
      showModal2: () => {
        flutterApp.showModal({
          title: "处理成功啦",
          content: "告知当前状态、信息和解决方法，等内容。描述尽可能控制在三行内。",
          cancelText: "取消",
          confirmText: "确定",
          // 带确认的弹出框
          type: "alert",
          success: function(res) {
            console.log("回调结果: res showToast");
          },
          fail: function(error) {
            console.log("error", error);
          }
        });
      },
      setNavigationBarTitle: () => {
        flutterApp.setNavigationBarTitle({
          title: `设置的新标题${Math.random()}`.substring(0, 12),
          success: function(res) {
            console.log("回调结果: res setNavigationBarTitle");
            console.log(res);
          },
          fail: function(error) {
            console.log("error", error);
          }
        });
      },
      setNavigationBarConfig: () => {
        flutterApp.setNavigationBarConfig({
          title: `设置的新标题${Math.random()}`.substring(0, 12),
          backgroundColor: "#007bfc",
          foregroundColor: "black",
          success: function(res) {
            console.log("回调结果: res setNavigationBarTitle");
            console.log(res);
          },
          fail: function(error) {
            console.log("error", error);
          }
        });
      }
    };
    onMounted(() => {
    });
    return () => {
      return createVNode("div", {
        "class": "full-container"
      }, [createVNode(resolveComponent("nut-space"), {
        "direction": "vertical",
        "fill": true
      }, {
        default: () => [createVNode(resolveComponent("nut-button"), {
          "block": true,
          "onClick": methods.showModal
        }, {
          default: () => [createTextVNode("弹出框")]
        }), createVNode(resolveComponent("nut-button"), {
          "block": true,
          "onClick": methods.showModal2
        }, {
          default: () => [createTextVNode("弹出确认框")]
        }), createVNode(resolveComponent("nut-button"), {
          "block": true,
          "onClick": methods.showToast
        }, {
          default: () => [createTextVNode("showToast")]
        }), createVNode(resolveComponent("nut-button"), {
          "block": true,
          "onClick": methods.loadData
        }, {
          default: () => [createTextVNode("获取barConfig")]
        }), createVNode(resolveComponent("nut-button"), {
          "block": true,
          "onClick": methods.setNavigationBarTitle
        }, {
          default: () => [createTextVNode("设置title")]
        }), createVNode(resolveComponent("nut-button"), {
          "block": true,
          "onClick": methods.setNavigationBarConfig
        }, {
          default: () => [createTextVNode("页面导航栏")]
        }), createVNode("pre", null, [JSON.stringify(data.value, null, 2)])]
      })]);
    };
  }
});
const CmpPlatformInfo = /* @__PURE__ */ defineComponent({
  name: "cmp-platform-info",
  props: {
    title: {
      type: String,
      default: ""
    }
  },
  setup() {
    ref([]);
    const info = ref({
      brand: "",
      id: "",
      host: "",
      display: "",
      // 用于向用户显示的构建ID字符串
      bootloader: "",
      // 系统引导程序的版本号
      fingerprint: "",
      // 唯一标识此构建的字符串
      hardware: "",
      // 硬件的名称（来自内核命令行或/proc）
      manufacturer: "",
      // 产品/硬件的制造商
      model: "",
      // 最终产品的最终用户可见名称
      product: "",
      // 整体产品的名称
      serialNumber: "",
      // 设备的硬件序列号（如果可用）
      tags: "",
      // 描述构建的逗号分隔的标签，如 “unsigned,debug”
      type: ""
      // 构建的类型，如 “user” 或 “eng”
    });
    const methods = {
      handleClick: () => {
        console.log(Object.keys(flutterApp));
        console.log(flutterApp.getSystemInfo);
        flutterApp.getSystemInfo({
          success: function(res) {
            console.log("回调结果: res getSystemInfo");
            console.log(res);
            const obj = {};
            Object.keys(info.value).forEach((key) => {
              obj[key] = res[key];
            });
            Object.assign(info.value, obj);
          },
          fail: function(error) {
            console.log("getSystemInfo error", error);
          }
        });
      }
    };
    onMounted(() => {
    });
    return () => {
      return createVNode("div", {
        "class": "full-container"
      }, [createVNode(resolveComponent("nut-space"), {
        "direction": "vertical",
        "fill": true
      }, {
        default: () => [createVNode(resolveComponent("nut-button"), {
          "onClick": methods.handleClick
        }, {
          default: () => [createTextVNode("获取设备信息")]
        }), createVNode("pre", null, [JSON.stringify(info.value, null, 2)])]
      })]);
    };
  }
});
const CmpShare = /* @__PURE__ */ defineComponent({
  name: "cmp-share",
  props: {
    title: {
      type: String,
      default: ""
    }
  },
  setup() {
    ref([]);
    onMounted(() => {
    });
    return () => {
      return createVNode("div", {
        "class": "full-container"
      }, [createTextVNode("xxx 第三方分享")]);
    };
  }
});
const CmpObserver = /* @__PURE__ */ defineComponent({
  name: "cmp-observer",
  props: {
    title: {
      type: String,
      default: ""
    }
  },
  setup() {
    ref([]);
    onMounted(() => {
    });
    return () => {
      return createVNode("div", {
        "class": "full-container"
      }, [createTextVNode("监听")]);
    };
  }
});
const CmpNavigation = /* @__PURE__ */ defineComponent({
  name: "cmp-navigation",
  props: {
    title: {
      type: String,
      default: ""
    }
  },
  setup() {
    ref([]);
    onMounted(() => {
    });
    return () => {
      return createVNode("div", {
        "class": "full-container"
      }, [createTextVNode("navigation 导航操作")]);
    };
  }
});
const CmpMedia = /* @__PURE__ */ defineComponent({
  name: "cmp-media",
  props: {
    title: {
      type: String,
      default: ""
    }
  },
  setup() {
    ref([]);
    onMounted(() => {
    });
    return () => {
      return createVNode("div", {
        "class": "full-container"
      }, [createTextVNode("media 媒体文件操作")]);
    };
  }
});
const CmpScannerCode = /* @__PURE__ */ defineComponent({
  name: "CmpScannerCode",
  props: {
    title: {
      type: String,
      default: ""
    }
  },
  setup() {
    const data = ref({});
    const methods = {
      scanCode: () => {
        flutterApp.scanCode({
          success: function(res) {
            console.log("识别回调结果: res scanCode", res);
            Object.assign(data.value, res);
          },
          fail: function(error) {
            console.log("error", error);
          }
        });
      }
    };
    onMounted(() => {
    });
    return () => {
      return createVNode("div", {
        "class": "full-container"
      }, [createVNode(resolveComponent("nut-space"), {
        "direction": "vertical",
        "fill": true
      }, {
        default: () => [createVNode(resolveComponent("nut-button"), {
          "block": true,
          "onClick": methods.scanCode
        }, {
          default: () => [createTextVNode("识别二维码")]
        }), createVNode("pre", null, [JSON.stringify(data.value, null, 2)])]
      })]);
    };
  }
});
const CmpClipboardData = /* @__PURE__ */ defineComponent({
  name: "CmpClipboardData",
  props: {
    title: {
      type: String,
      default: ""
    }
  },
  setup() {
    const data = ref({});
    const methods = {
      setClipboardData: () => {
        flutterApp.setClipboardData({
          text: "设置剪切板内容" + (/* @__PURE__ */ new Date()).toLocaleString(),
          success: function(res) {
            console.log("回调结果: res setClipboardData", res);
            Object.assign(data.value, {
              action: "设置剪切板",
              res
            });
          },
          fail: function(error) {
            console.log("error", error);
          }
        });
      },
      getClipboardData: () => {
        flutterApp.getClipboardData({
          success: function(res) {
            console.log("回调结果: res getClipboardData", res);
            Object.assign(data.value, {
              action: "获取剪切板内容",
              res
            });
          },
          fail: function(error) {
            console.log("error", error);
          }
        });
      },
      getLocation: () => {
        flutterApp.getLocation({
          success: function(res) {
            console.log("回调结果: res getLocation", res);
            Object.assign(data.value, {
              action: "getLocation",
              res
            });
          },
          fail: function(error) {
            console.log("error", error);
          }
        });
      },
      getNetworkType: () => {
        flutterApp.getNetworkType({
          success: function(res) {
            console.log("回调结果: res getNetworkType", res);
            Object.assign(data.value, {
              action: "getNetworkType",
              res
            });
          },
          fail: function(error) {
            console.log("error", error);
          }
        });
      }
    };
    onMounted(() => {
    });
    return () => {
      return createVNode("div", {
        "class": "full-container"
      }, [createVNode(resolveComponent("nut-space"), {
        "direction": "vertical",
        "fill": true
      }, {
        default: () => [createVNode(resolveComponent("nut-button"), {
          "block": true,
          "onClick": methods.setClipboardData
        }, {
          default: () => [createTextVNode("设置剪切板内容")]
        }), createVNode(resolveComponent("nut-button"), {
          "block": true,
          "onClick": methods.getClipboardData
        }, {
          default: () => [createTextVNode("获取剪切板内容")]
        }), createVNode(resolveComponent("nut-button"), {
          "block": true,
          "onClick": methods.getLocation
        }, {
          default: () => [createTextVNode("获取定位")]
        }), createVNode(resolveComponent("nut-button"), {
          "block": true,
          "onClick": methods.getNetworkType
        }, {
          default: () => [createTextVNode("获取当前网络状态")]
        }), createVNode("pre", null, [JSON.stringify(data.value, null, 2)])]
      })]);
    };
  }
});
const CmpNotification = /* @__PURE__ */ defineComponent({
  name: "CmpNotification",
  props: {
    title: {
      type: String,
      default: ""
    }
  },
  setup() {
    const data = ref({});
    const methods = {
      showNotification: () => {
        flutterApp.showNotification({
          title: "消息标题：" + (/* @__PURE__ */ new Date()).toLocaleString(),
          body: "我是发送的消息内容",
          success: function(res) {
            console.log("回调结果: res showNotification", res);
            Object.assign(data.value, {
              action: "设置剪切板",
              res
            });
          },
          fail: function(error) {
            console.log("error", error);
          }
        });
      },
      getClipboardData: () => {
        flutterApp.getClipboardData({
          success: function(res) {
            console.log("回调结果: res getClipboardData", res);
            Object.assign(data.value, {
              action: "获取剪切板内容",
              res
            });
          },
          fail: function(error) {
            console.log("error", error);
          }
        });
      },
      getLocation: () => {
        flutterApp.getLocation({
          success: function(res) {
            console.log("回调结果: res getLocation", res);
            Object.assign(data.value, {
              action: "getLocation",
              res
            });
          },
          fail: function(error) {
            console.log("error", error);
          }
        });
      },
      getNetworkType: () => {
        flutterApp.getNetworkType({
          success: function(res) {
            console.log("回调结果: res getNetworkType", res);
            Object.assign(data.value, {
              action: "getNetworkType",
              res
            });
          },
          fail: function(error) {
            console.log("error", error);
          }
        });
      }
    };
    onMounted(() => {
    });
    return () => {
      return createVNode("div", {
        "class": "full-container"
      }, [createVNode(resolveComponent("nut-space"), {
        "direction": "vertical",
        "fill": true
      }, {
        default: () => [createVNode(resolveComponent("nut-button"), {
          "block": true,
          "onClick": methods.showNotification
        }, {
          default: () => [createTextVNode("发送简单通知")]
        }), createVNode("pre", null, [JSON.stringify(data.value, null, 2)])]
      })]);
    };
  }
});
const _hoisted_1$1b = { class: "main-page" };
const _sfc_main$1H = /* @__PURE__ */ defineComponent({
  __name: "App",
  setup(__props) {
    const value = ref("ui");
    return (_ctx, _cache) => {
      const _component_nut_tab_pane = resolveComponent("nut-tab-pane");
      const _component_nut_tabs = resolveComponent("nut-tabs");
      return openBlock(), createElementBlock("div", _hoisted_1$1b, [
        createVNode(_component_nut_tabs, {
          modelValue: value.value,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => value.value = $event),
          "title-scroll": "",
          "title-gutter": "10"
        }, {
          default: withCtx(() => [
            createVNode(_component_nut_tab_pane, {
              title: "UI",
              "pane-key": "ui"
            }, {
              default: withCtx(() => [
                createVNode(unref(CmpUi))
              ]),
              _: 1
            }),
            createVNode(_component_nut_tab_pane, {
              title: "获取设备信息",
              "pane-key": "CmpPlatformInfo"
            }, {
              default: withCtx(() => [
                createVNode(unref(CmpPlatformInfo))
              ]),
              _: 1
            }),
            createVNode(_component_nut_tab_pane, {
              title: "蓝牙",
              "pane-key": "2"
            }, {
              default: withCtx(() => _cache[1] || (_cache[1] = [
                createTextVNode(" Content 2")
              ])),
              _: 1
            }),
            createVNode(_component_nut_tab_pane, {
              title: "媒体文件",
              "pane-key": "media"
            }, {
              default: withCtx(() => [
                createVNode(unref(CmpMedia))
              ]),
              _: 1
            }),
            createVNode(_component_nut_tab_pane, {
              title: "分享",
              "pane-key": "share"
            }, {
              default: withCtx(() => [
                createVNode(unref(CmpShare))
              ]),
              _: 1
            }),
            createVNode(_component_nut_tab_pane, {
              title: "监听",
              "pane-key": "observer"
            }, {
              default: withCtx(() => [
                createVNode(unref(CmpObserver))
              ]),
              _: 1
            }),
            createVNode(_component_nut_tab_pane, {
              title: "导航",
              "pane-key": "navigation"
            }, {
              default: withCtx(() => [
                createVNode(unref(CmpNavigation))
              ]),
              _: 1
            }),
            createVNode(_component_nut_tab_pane, {
              title: "二维码",
              "pane-key": "scannerCode"
            }, {
              default: withCtx(() => [
                createVNode(unref(CmpScannerCode))
              ]),
              _: 1
            }),
            createVNode(_component_nut_tab_pane, {
              title: "设备",
              "pane-key": "ClipboardData"
            }, {
              default: withCtx(() => [
                createVNode(unref(CmpClipboardData))
              ]),
              _: 1
            }),
            createVNode(_component_nut_tab_pane, {
              title: "通知",
              "pane-key": "CmpNotification"
            }, {
              default: withCtx(() => [
                createVNode(unref(CmpNotification))
              ]),
              _: 1
            })
          ]),
          _: 1
        }, 8, ["modelValue"])
      ]);
    };
  }
});
const _export_sfc$1 = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const App = /* @__PURE__ */ _export_sfc$1(_sfc_main$1H, [["__scopeId", "data-v-e2d7068a"]]);
const h$1 = /* @__PURE__ */ defineComponent({
  __name: "IconFont",
  props: {
    name: { type: String, default: "" },
    size: { type: [String, Number], default: "" },
    width: { type: [String, Number], default: "" },
    height: { type: [String, Number], default: "" },
    classPrefix: { type: String, default: "nut-icon" },
    fontClassName: { type: String, default: "nutui-iconfont" },
    color: { type: String, default: "" },
    tag: { type: String, default: "i" }
  },
  setup(e) {
    var c2;
    const t = e, a2 = "nut-icon", o = useSlots(), s = () => t.name ? t.name.indexOf("/") !== -1 : false, r = (n) => {
      if (n)
        return isNaN(Number(n)) ? String(n) : n + "px";
    }, i2 = s();
    let l2 = h$2(
      i2 ? "img" : t.tag,
      {
        class: i2 ? `${a2}__img` : `${t.fontClassName} ${a2} ${t.classPrefix}-${t.name}`,
        style: {
          color: t.color,
          fontSize: r(t.size),
          width: r(t.width || t.size),
          height: r(t.height || t.size)
        },
        src: i2 ? t.name : ""
      },
      (c2 = o.default) == null ? void 0 : c2.call(o)
    );
    const u2 = () => l2;
    return (n, y2) => (openBlock(), createBlock(u2));
  }
});
function S$2(e) {
  return e.name = "IconFont", e.install = (t) => {
    t.component("IconFont", e);
  }, e;
}
S$2(h$1);
const a$v = (r) => /* @__PURE__ */ defineComponent({
  props: {
    class: { type: String, default: "" },
    name: { type: String, default: r },
    color: { type: String, default: "" },
    width: { type: [String, Number], default: "" },
    height: { type: [String, Number], default: "" }
  },
  setup(e) {
    const n = (t) => {
      if (t)
        return isNaN(Number(t)) ? String(t) : t + "px";
    }, o = computed(() => {
      const t = "nut-icon";
      return {
        [e.class]: e.class,
        [t]: true,
        [t + "-" + e.name]: e.name
      };
    }), c2 = computed(() => {
      const t = {};
      return t.height = n(e.height), t.width = n(e.width), t.color = e.color, t;
    });
    return { classes: o, style: c2 };
  }
}), l = (r, e) => {
  const n = r.__vccOpts || r;
  for (const [o, c2] of e)
    n[o] = c2;
  return n;
};
const c$7 = a$v("arrow-down2"), i$F = /* @__PURE__ */ createBaseVNode("path", {
  d: "M1741.19 227.497a121.654 121.654 0 1 1 127.858 206.812L1292.65 790.27a182.482 182.482 0 0 1-191.727 0L524.646 434.31a121.654 121.654 0 1 1 127.859-206.812l544.403 335.887c181.387-111.8 362.773-223.965 544.282-335.887",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), p$F = [
  i$F
];
function d$9(e, m2, _, f2, w2, u2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 2472 1024",
    role: "presentation"
  }, p$F, 6);
}
const v$9 = /* @__PURE__ */ l(c$7, [["render", d$9]]);
const c$6 = a$v("arrow-up2"), p$E = /* @__PURE__ */ createBaseVNode("path", {
  d: "M623.406 815.479A129.722 129.722 0 1 1 487.068 594.95C691.9 468.083 896.73 341.993 1101.691 215.125a194.583 194.583 0 0 1 204.442 0l614.494 379.567a129.722 129.722 0 1 1-136.338 220.657l-580.506-358.292-580.377 358.422",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), i$E = [
  p$E
];
function m$u(e, _, d2, f2, u2, w2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 2472 1024",
    role: "presentation"
  }, i$E, 6);
}
const v$8 = /* @__PURE__ */ l(c$6, [["render", m$u]]);
const i$D = a$v("check-checked"), p$D = /* @__PURE__ */ createBaseVNode("path", {
  d: "M510.613 2.837C229.793 2.837.032 232.598.032 513.418S229.793 1024 510.613 1024s510.582-229.762 510.582-510.582S794.27 2.837 510.613 2.837zm0 794.238c-156.01 0-283.656-127.646-283.656-283.657s127.645-283.656 283.656-283.656S794.27 357.407 794.27 513.418 666.624 797.075 510.613 797.075z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), d$8 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M382.968 513.418a127.645 127.645 0 1 0 255.29 0 127.645 127.645 0 1 0-255.29 0Z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1);
function f$2(e, m2, _, h2, u2, C2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1032 1024",
    role: "presentation"
  }, [
    p$D,
    createTextVNode(","),
    d$8
  ], 6);
}
const y$2 = /* @__PURE__ */ l(i$D, [["render", f$2]]);
const a$u = a$v("check-disabled"), i$C = /* @__PURE__ */ createBaseVNode("path", {
  d: "M506.467 0C227.962 0 .094 227.868.094 506.374s227.868 506.373 506.373 506.373 506.374-227.868 506.374-506.373S787.786 0 506.467 0zm202.55 571.077H306.73c-45.01 0-67.516-22.506-67.516-67.517 0-45.01 22.505-67.516 67.516-67.516h402.286c45.01 0 67.516 22.505 67.516 67.516 0 45.011-22.505 67.517-67.516 67.517z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), p$C = [
  i$C
];
function d$7(e, m2, _, f2, h2, u2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    role: "presentation"
  }, p$C, 6);
}
const g$7 = /* @__PURE__ */ l(a$u, [["render", d$7]]);
const a$t = a$v("check-normal"), i$B = /* @__PURE__ */ createBaseVNode("path", {
  d: "M512 1024c-136.533 0-264.533-54.044-361.244-150.756C54.044 776.534 0 648.534 0 512c0-136.533 54.044-264.533 150.756-361.244C247.466 54.044 375.466 0 512 0c136.533 0 264.533 54.044 361.244 150.756C969.956 247.466 1024 375.466 1024 512s-54.044 264.533-150.756 361.244C776.534 969.956 648.534 1024 512 1024zm0-938.667c-113.778 0-221.867 45.511-301.511 125.156S85.333 398.222 85.333 512s45.511 221.867 125.156 301.511S398.222 938.667 512 938.667s221.867-45.511 301.511-125.156S938.667 625.778 938.667 512 893.156 290.133 813.51 210.489 625.778 85.333 512 85.333z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), m$t = [
  i$B
];
function p$B(e, _, d2, f2, C2, h2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    role: "presentation"
  }, m$t, 6);
}
const S$1 = /* @__PURE__ */ l(a$t, [["render", p$B]]);
const a$s = a$v("Check"), i$A = /* @__PURE__ */ createBaseVNode("path", {
  d: "M998.4 245.029c-219.429 153.6-398.629 332.8-552.229 552.228-40.228 58.514-128 54.857-164.571-3.657-69.486-106.057-149.943-186.514-256-256-51.2-32.914-18.286-113.371 40.229-98.743C182.857 460.8 274.286 508.343 358.4 585.143c157.257-190.172 358.4-340.114 588.8-435.2 62.171-25.6 106.057 58.514 51.2 95.086",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), p$A = [
  i$A
];
function m$s(e, _, d2, f2, h2, u2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    role: "presentation"
  }, p$A, 6);
}
const g$6 = /* @__PURE__ */ l(a$s, [["render", m$s]]);
const a$r = a$v("checked"), i$z = /* @__PURE__ */ createBaseVNode("path", {
  d: "M512 0C230.4 0 0 230.4 0 512s230.4 512 512 512 512-230.4 512-512S793.6 0 512 0zm281.6 369.778C779.378 381.156 600.178 500.622 472.178 691.2c0 0 0 2.844-2.845 2.844-8.533 5.69-48.355 36.978-88.177-8.533-39.823-51.2-62.578-99.555-142.223-142.222-2.844 0-2.844-2.845-2.844-2.845-8.533-11.377-39.822-56.888 19.911-56.888 45.511 0 91.022 11.377 162.133 73.955 5.69 5.689 14.223 5.689 17.067 0C469.333 517.69 608.711 366.933 768 318.578c0 0 19.911-2.845 31.289 14.222 5.689 11.378 11.378 22.756-5.689 36.978z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), p$z = [
  i$z
];
function d$6(e, m2, _, f2, h2, C2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    role: "presentation"
  }, p$z, 6);
}
const g$5 = /* @__PURE__ */ l(a$r, [["render", d$6]]);
const a$q = a$v("checklist"), i$y = /* @__PURE__ */ createBaseVNode("path", {
  d: "M159.289 500.622c62.578 0 125.155 17.067 221.867 102.4 8.533 5.69 19.91 5.69 25.6 0 48.355-54.044 238.933-261.689 455.11-329.955 0 0 28.445-5.69 42.667 19.91 8.534 17.067 19.911 34.134-5.689 54.045-22.755 17.067-264.533 179.2-440.888 440.89l-2.845 2.844c-11.378 8.533-68.267 51.2-119.467-14.223-56.888-71.11-85.333-139.377-196.266-196.266-2.845 0-2.845-2.845-5.69-5.69-11.377-11.377-54.044-73.955 25.6-73.955z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), p$y = [
  i$y
];
function m$r(e, _, d2, f2, h2, u2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    role: "presentation"
  }, p$y, 6);
}
const k = /* @__PURE__ */ l(a$q, [["render", m$r]]);
const a$p = a$v("circle-close"), i$x = /* @__PURE__ */ createBaseVNode("path", {
  d: "M511.492 73.063a438.425 438.425 0 0 1 310.545 748.953 439.16 439.16 0 1 1-621.09-621.073A435.695 435.695 0 0 1 511.492 73.046m0-73.063C267.49.018 57.468 172.408 9.87 411.717-37.713 651.042 90.39 890.658 315.823 984.03c225.45 93.355 485.444 14.472 621.005-188.416 135.543-202.906 108.885-473.293-63.659-645.82A509.645 509.645 0 0 0 511.492.002zm-175.7 635.495 299.673-299.674c12.049-12.049 24.115-12.049 36.164 0l15.496 15.497c12.05 12.066 12.05 24.115 0 36.18L387.47 687.122c-12.066 12.05-24.115 12.05-36.181 0l-15.497-15.496c-12.049-12.066-12.049-24.115 0-36.182zm0-284.177 15.496-15.497c12.066-12.049 24.115-12.049 36.18 0l299.64 299.674c12.05 12.049 12.05 24.098 0 36.164l-15.496 15.496c-12.05 12.05-24.115 12.05-36.182 0L335.808 387.465c-12.049-12.05-12.049-24.098 0-36.164z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), m$q = [
  i$x
];
function p$x(e, _, d2, f2, u2, C2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    role: "presentation"
  }, m$q, 6);
}
const z$1 = /* @__PURE__ */ l(a$p, [["render", p$x]]);
const a$o = a$v("close"), i$w = /* @__PURE__ */ createBaseVNode("path", {
  d: "M981.577 1024c-11.703 0-23.406-2.926-32.183-11.703L13.166 76.07c-14.629-17.555-14.629-46.812 0-64.366 17.554-14.629 46.811-14.629 64.365 0L1013.76 947.93c17.554 17.555 17.554 43.886 0 61.44-8.777 11.703-20.48 14.629-32.183 14.629zm-936.228 0c-11.703 0-23.406-2.926-32.183-11.703-17.555-17.554-17.555-43.886 0-61.44L949.394 14.63c17.555-17.555 43.886-17.555 61.44 0 17.555 17.554 17.555 43.885 0 61.44L74.606 1012.297C68.754 1021.074 57.05 1024 45.349 1024z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), p$w = [
  i$w
];
function m$p(e, _, d2, f2, u2, h2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1026 1024",
    role: "presentation"
  }, p$w, 6);
}
const g$4 = /* @__PURE__ */ l(a$o, [["render", m$p]]);
const a$n = a$v("comment"), m$o = /* @__PURE__ */ createBaseVNode("path", {
  d: "M760.415 876.089H259.793c-132.741 0-242.726-109.985-242.726-242.726V242.726C17.067 109.986 127.052 0 259.793 0h504.414c132.741 0 242.726 109.985 242.726 242.726v394.43c-3.792 132.74-109.985 238.933-246.518 238.933zM259.793 113.778c-72.06 0-128.949 56.889-128.949 128.948v394.43c0 72.059 56.89 128.948 128.949 128.948h504.414c68.267 0 128.949-56.89 128.949-128.948v-394.43c0-72.06-56.89-128.948-128.949-128.948H259.793zm56.888 887.466c-15.17 0-30.34-3.792-41.718-15.17-22.756-22.755-22.756-56.889 0-79.644l109.985-109.986c22.756-22.755 56.889-22.755 79.645 0s22.755 56.89 0 79.645L354.607 986.074c-7.585 7.585-22.755 15.17-37.926 15.17zm193.423-398.222c-45.511 0-91.023-22.755-117.57-56.889-18.964-26.548-15.171-60.681 7.585-79.644 26.548-18.963 60.681-15.17 79.644 7.585 15.17 18.963 45.511 18.963 56.889 0 18.963-22.755 56.889-30.34 79.644-7.585s30.341 56.889 7.585 79.644c-22.755 37.926-68.266 56.89-113.777 56.89z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), i$v = [
  m$o
];
function p$v(e, _, d2, f2, h2, v2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    role: "presentation"
  }, i$v, 6);
}
const w$a = /* @__PURE__ */ l(a$n, [["render", p$v]]);
const a$m = a$v("del"), i$u = /* @__PURE__ */ createBaseVNode("path", {
  d: "M668.444 1024H355.556c-142.223 0-256-113.778-256-256V170.667h824.888V768c0 142.222-113.777 256-256 256zM184.89 256v512c0 93.867 76.8 170.667 170.667 170.667h312.888c93.867 0 170.667-76.8 170.667-170.667V256H184.89zm753.778 0H85.333c-22.755 0-42.666-19.911-42.666-42.667s19.91-42.666 42.666-42.666h853.334c22.755 0 42.666 19.91 42.666 42.666S961.423 256 938.667 256zM625.777 85.333H398.223c-22.755 0-42.666-19.91-42.666-42.666S375.466 0 398.222 0h227.556c22.755 0 42.666 19.911 42.666 42.667s-19.91 42.666-42.666 42.666z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), p$u = [
  i$u
];
function m$n(e, d2, _, f2, h2, u2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    role: "presentation"
  }, p$u, 6);
}
const w$9 = /* @__PURE__ */ l(a$m, [["render", m$n]]);
const c$5 = a$v("down-arrow"), i$t = /* @__PURE__ */ createBaseVNode("path", {
  d: "M128 349.867C93.867 332.8 34.133 341.333 8.533 384-8.533 418.133 0 477.867 42.667 503.467 179.2 588.8 315.733 665.6 443.733 750.933c42.667 25.6 93.867 25.6 136.534 0C716.8 665.6 853.333 588.8 981.333 503.467c42.667-25.6 51.2-76.8 25.6-119.467s-76.8-51.2-119.466-25.6C768 435.2 640 512 512 588.8 384 512 256 435.2 128 349.867",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), p$t = [
  i$t
];
function d$5(e, m2, _, f2, w2, u2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    role: "presentation"
  }, p$t, 6);
}
const g$3 = /* @__PURE__ */ l(c$5, [["render", d$5]]);
const a$l = a$v("edit"), i$s = /* @__PURE__ */ createBaseVNode("path", {
  d: "M285.479 992.97H108.606c-27.927 0-55.854-12.412-77.576-31.03C9.31 940.217 0 915.393 0 884.363l3.103-155.152c0-24.824 9.31-46.545 27.927-65.164L626.812 65.164c83.782-83.782 220.315-83.782 307.2 0 83.782 83.781 83.782 223.418 0 307.2l-605.09 601.988c-12.413 12.412-27.928 18.618-43.443 18.618zM781.964 93.09c-31.03 0-65.164 12.413-89.988 37.237L96.194 729.212 93.09 884.364c0 9.309 6.206 15.515 15.515 15.515h161.358l598.884-595.782c49.649-49.649 49.649-127.224 0-173.77l-3.103-3.103c-21.72-21.721-52.751-34.133-83.781-34.133zm-201.946 78.508 65.816-65.847L882.812 342.73l-65.846 65.784zM946.424 992.97H217.212c-24.824 0-46.545-21.722-46.545-46.546s21.72-46.545 46.545-46.545h729.212c24.824 0 46.546 21.721 46.546 46.545s-21.722 46.546-46.546 46.546z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), p$s = [
  i$s
];
function d$4(e, m2, _, f2, h2, u2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    role: "presentation"
  }, p$s, 6);
}
const g$2 = /* @__PURE__ */ l(a$l, [["render", d$4]]);
const a$k = a$v("fabulous"), i$r = /* @__PURE__ */ createBaseVNode("path", {
  d: "M584.06 1024H318.577C144.118 1024 0 883.674 0 705.422s140.326-318.578 318.578-318.578v113.778c-113.778 0-204.8 91.022-204.8 204.8s91.022 204.8 204.8 204.8h265.481V1024zm56.888 0h-53.096c-208.593 0-379.26-170.667-379.26-383.052 0-83.437 26.549-163.081 75.852-231.348l3.793-3.793c15.17-22.755 30.34-60.681 45.511-121.363l7.585-34.133c7.586-18.963 15.17-41.718 18.963-68.267C386.844 22.756 470.281 0 519.586 0c117.57 0 178.251 106.193 178.251 212.385v7.585c0 7.586-3.793 18.963-3.793 37.926C876.09 257.896 1024 405.807 1024 587.852v53.096C1024 853.333 853.333 1024 640.948 1024zM519.585 113.778c-30.34 0-41.718 53.096-49.304 87.23-3.792 34.133-11.377 60.68-15.17 83.436l-7.585 34.134c-11.378 45.51-34.133 113.778-60.682 155.496l-7.585 3.793A269.274 269.274 0 0 0 322.37 644.74c0 147.91 121.363 269.274 269.274 269.274h53.097c147.91 0 269.274-121.363 269.274-269.274v-53.097c0-117.57-98.608-216.177-216.178-216.177h-56.889c-18.963-3.793-37.926-15.17-49.304-30.341-11.377-15.17-15.17-37.926-15.17-56.889 7.585-41.718 11.378-64.474 11.378-75.852v-3.792c-3.793 0-3.793-94.815-68.267-94.815z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), p$r = [
  i$r
];
function m$m(e, f2, _, d2, u2, h2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1061 1024",
    role: "presentation"
  }, p$r, 6);
}
const w$8 = /* @__PURE__ */ l(a$k, [["render", m$m]]);
const a$j = a$v("failure"), i$q = /* @__PURE__ */ createBaseVNode("path", {
  d: "M512 1024C229.831 1024 0 794.169 0 512S229.831 0 512 0s512 229.831 512 512-229.831 512-512 512zm0-955.733C266.24 68.267 68.267 266.24 68.267 512S266.24 955.733 512 955.733 955.733 757.76 955.733 512 757.76 68.267 512 68.267zm111.502 282.169c13.654-13.654 34.134-13.654 47.787 0 11.378 11.377 13.653 31.857 2.275 45.51l-2.275 2.276-111.502 111.502 111.502 111.503c13.653 13.653 13.653 34.133 0 47.786-13.653 13.654-34.133 13.654-47.787 0L512 557.511 400.498 669.013c-11.378 11.378-31.858 13.654-45.511 2.276l-2.276-2.276c-11.378-11.377-13.653-31.857-2.275-45.51l2.275-2.276 111.502-111.503-111.502-111.502c-13.653-13.653-13.653-34.133 0-47.786s34.133-13.654 47.787 0L512 461.938l111.502-111.502z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), p$q = [
  i$q
];
function m$l(e, f2, _, d2, u2, h2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    role: "presentation"
  }, p$q, 6);
}
const C$2 = /* @__PURE__ */ l(a$j, [["render", m$l]]);
const i$p = a$v("image-error"), p$p = /* @__PURE__ */ createBaseVNode("path", {
  d: "M696.43 465.25c40.61 0 73.53-32.72 73.53-73.09s-32.96-73.08-73.53-73.08-73.54 32.72-73.54 73.08 32.92 73.09 73.54 73.09zM535.74 650.62l-273.61-259.4a56.19 56.19 0 0 0-15.36 11.58l-114 119.63-6-222.77c-.73-26.82 20.84-49.41 47.67-50.14l201.77-5.44 47.34-50-250.43 6.75C119 202.33 76.33 247.17 77.78 301l7.32 271.4 4.5 166.78C91.06 793 136.05 835.47 190.2 834l176-4.75 12-.32 47.34-50 116.18-122.64z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), m$k = /* @__PURE__ */ createBaseVNode("path", {
  d: "m861.71 214.8-242.83-33.86-55.09 41.46L855 263a49.05 49.05 0 0 1 41.79 55.13l-54.33 389.59-120.87-159.05A59.86 59.86 0 0 0 638.06 537l-44 33.08 65.07 86.15L603.84 698l-79.57 60.1-54.92 41.48 34.17 4.76 270.73 37.76a97.55 97.55 0 0 0 109.88-79.6 22.37 22.37 0 0 0 .65-3.44l60.53-434.16c7.44-53.32-29.95-102.62-83.6-110.1z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1);
function d$3(e, f2, _, u2, g2, h2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    role: "presentation"
  }, [
    p$p,
    createTextVNode(","),
    m$k
  ], 6);
}
const y$1 = /* @__PURE__ */ l(i$p, [["render", d$3]]);
const i$o = a$v("image"), p$o = /* @__PURE__ */ createBaseVNode("path", {
  d: "M853.161 892.55H362.595l-209.433-.414a18.5 18.5 0 0 1-1.813-.092c-24.849-2.485-47.825-14.06-64.696-32.595-16.991-18.665-26.35-42.855-26.35-68.112V264.626c0-55.808 45.404-101.211 101.212-101.211H853.16c55.808 0 101.21 45.403 101.21 101.211v225.513c0 .275-.006.552-.018.826-.022.494-1.972 51.723 15.481 85.462 4.717 9.119 1.148 20.335-7.97 25.053-9.117 4.714-20.335 1.15-25.053-7.97-21.3-41.177-19.845-97.643-19.619-103.74V264.627c0-35.307-28.724-64.031-64.03-64.031H161.515c-35.308 0-64.032 28.724-64.032 64.031v526.711c0 32.755 24.321 59.958 56.718 63.62l208.431.412h490.53c35.306 0 64.03-28.725 64.03-64.032l-.382-93.677c-.105-1.75-1.587-19.548-19.55-42.5a9.548 9.548 0 0 1-.147-.19l-21.712-28.489-117.227-155.119c-.416-.55-38.995-50.852-86.272-45.534-38.335 4.315-75.955 45.164-108.79 118.132-17.615 39.141-34.65 68.269-52.082 89.046-17.607 20.986-35.68 33.52-55.251 38.317-43.423 10.638-81.05-18.995-120.887-50.373l-5.057-3.98c-46.555-36.578-68.75-28.224-158.33 59.602-7.33 7.188-19.1 7.071-26.289-.26-7.187-7.33-7.07-19.1.26-26.287 46.659-45.746 77.544-72.727 107.086-84.283 33.358-13.048 64.275-6.267 100.242 21.994l5.093 4.008c33.923 26.72 63.22 49.795 89.029 43.467 25.618-6.279 53.3-42.114 82.28-106.509 39.14-86.976 85.838-134.027 138.797-139.849 68.454-7.515 117.824 57.405 119.892 60.172l117.122 154.98 21.6 28.344c26.277 33.631 27.334 61.639 27.367 64.725l.001.128.384 94.06c.001 55.884-45.4 101.287-101.209 101.287z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), m$j = /* @__PURE__ */ createBaseVNode("path", {
  d: "M312.328 446.968c-42.325 0-76.759-34.434-76.759-76.76s34.434-76.759 76.76-76.759 76.759 34.435 76.759 76.76-34.434 76.759-76.76 76.759zm0-116.34c-21.824 0-39.579 17.756-39.579 39.58s17.755 39.58 39.58 39.58 39.579-17.756 39.579-39.58-17.755-39.58-39.58-39.58z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1);
function d$2(e, f2, _, u2, h2, g2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    role: "presentation"
  }, [
    p$o,
    createTextVNode(","),
    m$j
  ], 6);
}
const y = /* @__PURE__ */ l(i$o, [["render", d$2]]);
const c$4 = a$v("joy-smile"), i$n = /* @__PURE__ */ createBaseVNode("path", {
  d: "M2185.74 479.429a117.992 117.992 0 1 0-162.829-170.852c-284.772 271.204-732.314 271.204-1017.087 0A118.05 118.05 0 0 0 842.996 479.43c375.98 358.045 966.705 358.045 1342.744 0",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), p$n = [
  i$n
];
function m$i(e, _, d2, f2, u2, y2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 3072 1024",
    role: "presentation"
  }, p$n, 6);
}
const g$1 = /* @__PURE__ */ l(c$4, [["render", m$i]]);
const c$3 = a$v("left"), i$m = /* @__PURE__ */ createBaseVNode("path", {
  d: "M642.973 1005.542 321.912 587.098a123.278 123.278 0 0 1 0-150.17l321.06-418.443a47.182 47.182 0 0 1 74.83 57.422l-321.088 418.47a28.994 28.994 0 0 0 0 35.3l321.088 418.47a47.155 47.155 0 0 1-74.83 57.395",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), p$m = [
  i$m
];
function f$1(e, m2, _, d2, u2, h2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    role: "presentation"
  }, p$m, 6);
}
const v$7 = /* @__PURE__ */ l(c$3, [["render", f$1]]);
const a$i = a$v("link"), i$l = /* @__PURE__ */ createBaseVNode("path", {
  d: "M313.034 1004.045c-66.848 0-124.402-24.156-170.798-70.577l-40.854-40.829C54.96 846.218 28.966 783.097 30.83 714.411c3.702-66.85 31.56-131.808 79.819-180.12l137.4-137.373c14.86-14.861 40.855-14.861 55.69 0 14.86 14.861 16.725 38.99 0 55.69l-137.348 137.4a187.47 187.47 0 0 0-55.69 126.24c-1.864 46.422 14.835 89.115 46.396 120.675l40.855 40.855c31.56 31.56 74.253 48.286 120.674 46.421 46.421-1.838 92.843-22.291 126.24-55.69l137.4-137.4c14.862-14.86 40.856-14.86 55.69 0 14.862 14.862 14.862 40.856 0 55.69l-137.4 137.427c-48.285 48.259-113.27 76.117-180.118 79.82a5.645 5.645 0 0 0-7.405 0zm475.294-382.477c-11.133 0-18.563-3.702-27.832-12.997-14.86-14.861-14.86-40.855 0-55.69l115.082-115.108a187.47 187.47 0 0 0 55.716-126.267c1.838-46.395-14.861-89.114-46.421-120.674l-40.855-40.855c-64.985-64.959-176.364-61.257-246.915 9.294L478.266 278.108c-14.835 14.835-40.829 14.835-55.69 0-14.86-14.861-14.86-40.855 0-55.716l118.81-118.81C643.524 1.444 803.163-2.232 899.734 94.287l40.829 40.855c46.421 46.421 72.415 109.541 70.55 178.228-3.702 66.85-31.56 131.807-79.819 180.093L816.186 608.571c-7.43 7.43-18.563 11.133-27.858 12.997zm-332.327-1.864c-11.16 0-18.564-3.702-27.832-12.997-14.888-14.835-14.888-40.829 0-55.69l148.506-148.532c14.861-14.862 40.855-14.862 55.69 0 14.861 14.86 14.861 40.854 0 55.69L483.832 606.706c-7.404 7.43-18.563 11.159-27.831 12.997z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), p$l = [
  i$l
];
function m$h(e, _, d2, f2, u2, h2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    role: "presentation"
  }, p$l, 6);
}
const C$1 = /* @__PURE__ */ l(a$i, [["render", m$h]]);
const a$h = a$v("loading"), i$k = /* @__PURE__ */ createBaseVNode("path", {
  d: "M784 902.4c9.6 19.2 6.4 41.6-12.8 54.4-19.2 9.6-41.6 3.2-51.2-12.8-9.6-19.2-6.4-41.6 12.8-54.4 16-12.8 38.4-8 51.2 12.8zM550.4 984c0 22.4-16 38.4-38.4 38.4s-38.4-16-38.4-38.4v-24c0-22.4 19.2-38.4 41.6-38.4 19.2 0 35.2 16 38.4 38.4v25.6h-3.2zm-240-43.2c-9.6 19.2-35.2 25.6-54.4 16-19.2-9.6-25.6-35.2-16-51.2l28.8-51.2c9.6-19.2 35.2-25.6 54.4-16s25.6 35.2 12.8 54.4l-25.6 48zM121.6 784c-19.2 9.6-41.6 3.2-54.4-16-9.6-19.2-6.4-41.6 12.8-54.4l76.8-44.8c19.2-9.6 41.6-3.2 54.4 16 9.6 19.2 3.2 41.6-16 54.4L121.6 784zM38.4 552C16 552 0 536 0 513.6s16-38.4 38.4-38.4H160c22.4 0 38.4 19.2 38.4 38.4 0 22.4-16 38.4-38.4 38.4H38.4zm44.8-241.6c-19.2-9.6-25.6-35.2-16-51.2 9.6-19.2 35.2-25.6 54.4-16L256 320c19.2 9.6 25.6 35.2 16 54.4s-35.2 25.6-54.4 16l-134.4-80zm160-185.6 92.8 160c9.6 19.2 35.2 25.6 54.4 12.8s25.6-35.2 12.8-54.4l-92.8-160C297.6 64 275.2 60.8 256 70.4c-16 12.8-22.4 33.6-12.8 54.4zM473.6 40c0-22.4 16-38.4 38.4-38.4s38.4 19.2 38.4 38.4v184c0 22.4-19.2 38.4-38.4 38.4-22.4 0-38.4-19.2-38.4-38.4V40zm240 43.2c9.6-19.2 35.2-25.6 54.4-16 19.2 9.6 25.6 35.2 16 51.2l-92.8 160c-9.6 19.2-35.2 25.6-54.4 16-19.2-9.6-25.6-35.2-12.8-54.4l89.6-156.8zm188.8 160-160 92.8c-19.2 9.6-25.6 35.2-16 54.4 12.8 19.2 35.2 25.6 54.4 12.8l160-92.8c19.2-9.6 25.6-35.2 12.8-54.4-9.6-16-32-25.6-51.2-12.8zM985.6 472c22.4 0 38.4 16 38.4 38.4s-16 38.4-38.4 38.4H800c-22.4 0-38.4-19.2-38.4-38.4 0-22.4 19.2-38.4 38.4-38.4h185.6z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), m$g = [
  i$k
];
function p$k(c2, z2, d2, _, f2, h2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(c2.classes),
    style: normalizeStyle(c2.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    role: "presentation"
  }, m$g, 6);
}
const u = /* @__PURE__ */ l(a$h, [["render", p$k]]);
const a$g = a$v("loading1"), i$j = /* @__PURE__ */ createBaseVNode("path", {
  d: "M520.665 64.564a29.244 29.244 0 0 0-7.071-.894c-16.211 0-29.35 13.14-29.35 29.35 0 15.83 12.538 28.696 28.223 29.293v.073c.375 0 .751-.014 1.127-.014 216.493 0 389.629 173.942 389.629 390.433 0 216.496-173.136 388.827-389.63 388.827s-389.63-172.333-389.63-388.829c0-.27.01-.536.01-.804h-.01c0-16.209-13.141-29.35-29.35-29.35s-29.35 13.139-29.35 29.35c0 .055.007.11.007.164-.001.214-.007.425-.007.64 0 247.609 200.722 448.331 448.33 448.331 247.607 0 448.33-200.722 448.33-448.33-.002-245.242-196.917-444.456-441.258-448.24z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), p$j = [
  i$j
];
function d$1(e, m2, _, f2, g2, h2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    role: "presentation"
  }, p$j, 6);
}
const w$7 = /* @__PURE__ */ l(a$g, [["render", d$1]]);
const a$f = a$v("location"), i$i = /* @__PURE__ */ createBaseVNode("path", {
  d: "M512 971.487C259.938 971.487 52.513 764.062 52.513 512S259.938 52.513 512 52.513 971.487 259.938 971.487 512 764.062 971.487 512 971.487zm0-840.205c-210.051 0-380.718 170.667-380.718 380.718S301.95 892.718 512 892.718 892.718 722.05 892.718 512 722.05 131.282 512 131.282zm0 577.641c-107.651 0-196.923-89.272-196.923-196.923S404.349 315.077 512 315.077 708.923 404.349 708.923 512 619.651 708.923 512 708.923zm0-315.077c-65.641 0-118.154 52.513-118.154 118.154S446.36 630.154 512 630.154 630.154 577.64 630.154 512 577.64 393.846 512 393.846zm0-210.051c-21.005 0-39.385-18.38-39.385-39.385V39.385C472.615 18.379 490.995 0 512 0s39.385 18.38 39.385 39.385V144.41c0 21.005-18.38 39.385-39.385 39.385zM512 1024c-21.005 0-39.385-18.38-39.385-39.385V879.59c0-21.005 18.38-39.385 39.385-39.385s39.385 18.38 39.385 39.385v105.025c0 21.006-18.38 39.385-39.385 39.385zm472.615-472.615H879.59c-21.005 0-39.385-18.38-39.385-39.385s18.38-39.385 39.385-39.385h105.025c21.006 0 39.385 18.38 39.385 39.385s-18.38 39.385-39.385 39.385zm-840.205 0H39.385C18.379 551.385 0 533.005 0 512s18.38-39.385 39.385-39.385H144.41c21.005 0 39.385 18.38 39.385 39.385s-18.38 39.385-39.385 39.385z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), m$f = [
  i$i
];
function p$i(e, _, d2, f2, z2, h2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    role: "presentation"
  }, m$f, 6);
}
const S = /* @__PURE__ */ l(a$f, [["render", p$i]]);
const a$e = a$v("location2"), i$h = /* @__PURE__ */ createBaseVNode("path", {
  d: "m530.286 1005.714-25.6-10.971c-36.572-14.629-58.515-25.6-73.143-36.572-102.4-84.114-164.572-135.314-193.829-171.885-43.885-51.2-76.8-91.429-106.057-142.629C95.086 577.83 76.8 504.686 76.8 431.543c0-117.029 43.886-226.743 128-307.2C285.257 43.886 394.971 0 512 0s226.743 43.886 310.857 128c84.114 80.457 128 190.171 128 307.2 0 73.143-18.286 146.286-54.857 212.114-25.6 43.886-58.514 91.429-106.057 142.629-29.257 32.914-87.772 84.114-197.486 171.886 0 0-7.314 7.314-18.286 10.971l-43.885 32.914zM497.37 874.057s3.658 3.657 14.629 7.314c3.657-3.657 7.314-3.657 10.971-7.314C621.714 797.257 683.886 742.4 705.83 716.8c40.228-47.543 69.485-87.771 91.428-128 25.6-47.543 40.229-102.4 40.229-157.257 0-87.772-32.915-168.229-95.086-230.4-58.514-58.514-142.629-91.429-230.4-91.429S340.114 142.63 277.943 204.8c-62.172 62.171-95.086 142.629-95.086 230.4 0 54.857 14.629 109.714 40.229 157.257 25.6 43.886 54.857 80.457 95.085 124.343 25.6 29.257 84.115 80.457 179.2 157.257zm18.286-248.686c-102.4 0-182.857-80.457-182.857-182.857s80.457-182.857 182.857-182.857 182.857 80.457 182.857 182.857-80.457 182.857-182.857 182.857zm0-256c-40.228 0-73.143 32.915-73.143 73.143s32.915 73.143 73.143 73.143 73.143-32.914 73.143-73.143-32.914-73.143-73.143-73.143z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), m$e = [
  i$h
];
function p$h(e, _, d2, f2, u2, z2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    role: "presentation"
  }, m$e, 6);
}
const w$6 = /* @__PURE__ */ l(a$e, [["render", p$h]]);
const a$d = a$v("mask-close"), i$g = /* @__PURE__ */ createBaseVNode("path", {
  d: "M512 14.897C238.594 14.897 14.897 238.594 14.897 512S238.594 1009.103 512 1009.103 1009.103 785.406 1009.103 512 785.406 14.897 512 14.897zm207.126 646.234c16.57 16.57 16.57 41.425 0 57.995s-41.425 16.57-57.995 0L512 569.996l-149.13 149.13c-16.57 16.57-41.426 16.57-57.996 0s-16.57-41.425 0-57.995L454.004 512l-149.13-149.13c-16.57-16.57-16.57-41.426 0-57.996s41.425-16.57 57.995 0L512 454.004l149.13-149.13c16.57-16.57 41.426-16.57 57.996 0s16.57 41.425 0 57.995L569.996 512l149.13 149.13z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), p$g = [
  i$g
];
function m$d(e, _, d2, f2, u2, h2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    role: "presentation"
  }, p$g, 6);
}
const g = /* @__PURE__ */ l(a$d, [["render", m$d]]);
const a$c = a$v("minus"), i$f = /* @__PURE__ */ createBaseVNode("path", {
  d: "M299.52 460.8h409.6c28.16 0 51.2 23.04 51.2 51.2s-23.04 51.2-51.2 51.2h-409.6c-28.16 0-51.2-23.04-51.2-51.2s23.04-51.2 51.2-51.2z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), p$f = [
  i$f
];
function m$c(e, _, d2, f2, u2, h2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    role: "presentation"
  }, p$f, 6);
}
const v$6 = /* @__PURE__ */ l(a$c, [["render", m$c]]);
const a$b = a$v("more-x"), i$e = /* @__PURE__ */ createBaseVNode("path", {
  d: "M937.115 428.218c-43.442 0-80.679 37.237-80.679 80.679s37.237 80.679 80.68 80.679c43.442 0 80.678-37.237 80.678-80.679s-34.133-80.679-80.679-80.679m-428.218-52.751c-74.473 0-133.43 58.957-133.43 133.43s58.957 133.43 133.43 133.43 133.43-58.957 133.43-133.43-58.957-133.43-133.43-133.43M83.782 428.218c-43.443 0-80.679 37.237-80.679 80.679s34.133 80.679 80.679 80.679 80.679-37.237 80.679-80.679-37.237-80.679-80.68-80.679",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), p$e = [
  i$e
];
function m$b(e, _, d2, f2, u2, h2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    role: "presentation"
  }, p$e, 6);
}
const v$5 = /* @__PURE__ */ l(a$b, [["render", m$b]]);
const a$a = a$v("notice"), i$d = /* @__PURE__ */ createBaseVNode("path", {
  d: "M940.873 819.2h-85.334V430.933c0-192-153.6-345.6-341.333-345.6s-341.333 153.6-341.333 345.6V819.2H87.539V430.933C87.54 192 279.54 0 514.206 0s426.667 192 426.667 430.933V819.2zM514.633 1024c-68.267 0-132.267-29.867-174.934-85.333-17.066-17.067-12.8-42.667 4.267-59.734 17.067-12.8 46.933-12.8 59.733 8.534 29.867 34.133 68.267 51.2 110.934 51.2s81.066-17.067 106.666-51.2c12.8-17.067 42.667-21.334 59.734-8.534 17.066 12.8 21.333 42.667 8.533 59.734C646.899 994.133 582.899 1024 514.633 1024zm469.333-162.133h-12.8c-294.4-89.6-618.667-89.6-913.067 0-21.333 4.266-46.933-8.534-55.466-29.867-8.534-21.333 4.266-46.933 29.866-51.2 311.467-93.867 652.8-89.6 964.267 0 21.333 8.533 34.133 29.867 29.867 51.2-8.534 21.333-25.6 29.867-42.667 29.867z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), p$d = [
  i$d
];
function m$a(e, _, d2, f2, h2, u2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1027 1024",
    role: "presentation"
  }, p$d, 6);
}
const C = /* @__PURE__ */ l(a$a, [["render", m$a]]);
const a$9 = a$v("photograph"), p$c = /* @__PURE__ */ createBaseVNode("path", {
  d: "M570.514 789.943c-119.954 0-219.428-99.474-219.428-219.429s99.474-219.428 219.428-219.428 219.429 99.474 219.429 219.428-99.474 219.429-219.429 219.429zm0-351.086c-73.143 0-131.657 58.514-131.657 131.657s58.514 131.657 131.657 131.657 131.657-58.514 131.657-131.657-58.514-131.657-131.657-131.657zM877.714 1024h-614.4C117.03 1024 0 906.971 0 760.686V380.343c0-146.286 117.029-263.314 263.314-263.314h32.183c0-2.926 2.926-8.778 2.926-11.703C315.977 43.886 374.49 0 438.857 0h263.314c70.218 0 128.732 49.737 143.36 117.029h32.183c146.286 0 263.315 117.028 263.315 263.314v380.343C1141.029 906.97 1024 1024 877.714 1024zm-614.4-819.2c-96.548 0-175.543 78.994-175.543 175.543v380.343c0 96.548 78.995 175.543 175.543 175.543h614.4c96.549 0 175.543-78.995 175.543-175.543V380.343c0-96.549-78.994-175.543-175.543-175.543H819.2c-32.183 0-58.514-26.331-58.514-58.514S734.354 87.77 702.17 87.77H438.857c-26.331 0-49.737 17.555-55.588 40.96-2.926 5.852-2.926 11.703-2.926 17.555 0 32.183-26.332 58.514-58.514 58.514h-58.515zm-87.771 160.914a73.143 73.143 0 1 0 146.286 0 73.143 73.143 0 1 0-146.286 0Z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), h = [
  p$c
];
function i$c(e, m2, _, d2, f2, g2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1141 1024",
    role: "presentation"
  }, h, 6);
}
const z = /* @__PURE__ */ l(a$9, [["render", i$c]]);
const c$2 = a$v("plus"), i$b = /* @__PURE__ */ createBaseVNode("path", {
  d: "M345.6 460.8h409.6q51.2 0 51.2 51.2t-51.2 51.2H345.6q-51.2 0-51.2-51.2t51.2-51.2zM550.4 256q51.2 0 51.2 51.2v409.6q0 51.2-51.2 51.2t-51.2-51.2V307.2q0-51.2 51.2-51.2z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), p$b = [
  i$b
];
function m$9(e, _, d2, f2, u2, h2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    role: "presentation"
  }, p$b, 6);
}
const w$5 = /* @__PURE__ */ l(c$2, [["render", m$9]]);
const a$8 = a$v("rect-down"), i$a = /* @__PURE__ */ createBaseVNode("path", {
  d: "M515.072 778.24c-14.336 0-28.672-5.632-39.936-16.384L69.12 356.864c-22.016-22.016-22.016-57.856 0-79.872s57.856-22.016 79.872 0L515.584 642.56 880.64 275.968c22.016-22.016 57.856-22.016 79.872 0s22.016 57.856 0 79.872L555.008 762.368c-10.752 10.752-25.6 15.872-39.936 15.872z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), p$a = [
  i$a
];
function d(e, m2, _, f2, w2, u2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    role: "presentation"
  }, p$a, 6);
}
const v$4 = /* @__PURE__ */ l(a$8, [["render", d]]);
const a$7 = a$v("rect-up"), p$9 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M920.576 778.24c-14.336 0-28.672-5.632-39.936-16.384L515.072 395.264 148.48 760.832c-22.016 22.016-57.856 22.016-79.872 0s-22.016-57.856 0-79.872l406.528-405.504c22.016-22.016 57.856-22.016 79.872 0l405.504 406.528c22.016 22.016 22.016 57.856 0 79.872-11.264 11.264-25.6 16.384-39.936 16.384z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), i$9 = [
  p$9
];
function m$8(e, _, d2, f2, u2, h2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    role: "presentation"
  }, i$9, 6);
}
const v$3 = /* @__PURE__ */ l(a$7, [["render", m$8]]);
const a$6 = a$v("refresh2"), i$8 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M771.938 315.077h199.55L958.358 469.99 758.81 364.964c-13.128-7.877-18.38-23.63-10.502-36.759 2.625-7.877 13.128-13.128 23.63-13.128zm-535.63 393.846H44.636L57.764 554.01l191.672 105.026c13.128 7.877 18.38 23.63 10.502 36.759-5.25 7.877-15.753 13.128-23.63 13.128zM509.374 1024C257.313 1024 44.636 845.456 5.251 596.02 0 575.016 15.754 556.637 36.76 551.386c21.005-2.626 42.01 10.502 44.636 31.507 34.133 210.052 215.302 362.339 427.98 362.339 191.671 0 362.338-128.657 417.476-312.452 5.252-21.005 28.882-34.133 49.887-26.256 21.006 5.251 34.134 28.882 26.257 49.887C937.354 871.713 735.179 1024 509.375 1024zm467.364-551.385c-18.379 0-36.759-13.128-39.384-34.133C903.22 231.056 722.05 78.77 509.374 78.77c-191.671 0-362.338 128.657-414.85 312.452-5.252 21.005-28.883 34.133-49.888 26.256-21.005-5.251-34.133-28.882-26.257-49.887C81.395 152.287 283.57 0 509.374 0c252.062 0 464.739 178.544 504.123 427.98 2.626 21.005-10.502 42.01-31.507 44.635h-5.252z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), p$8 = [
  i$8
];
function m$7(e, f2, _, d2, h2, C2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    role: "presentation"
  }, p$8, 6);
}
const w$4 = /* @__PURE__ */ l(a$6, [["render", m$7]]);
const a$5 = a$v("retweet"), i$7 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M136 552h63.6c4.4 0 8-3.6 8-8V288.7h528.6v72.6c0 1.9.6 3.7 1.8 5.2 2.9 3.6 8.1 4.3 11.7 1.4L893 255.4c4.3-5 3.6-10.3 0-13.2L749.7 129.8c-1.5-1.2-3.3-1.8-5.2-1.8-4.6 0-8.4 3.8-8.4 8.4V209H199.7c-39.5 0-71.7 32.2-71.7 71.8V544c0 4.4 3.6 8 8 8zm752-80h-63.6c-4.4 0-8 3.6-8 8v255.3H287.8v-72.6c0-1.9-.6-3.7-1.8-5.2-2.9-3.6-8.1-4.3-11.7-1.4L131 768.6c-4.3 5-3.6 10.3 0 13.2l143.3 112.4c1.5 1.2 3.3 1.8 5.2 1.8 4.6 0 8.4-3.8 8.4-8.4V815h536.6c39.5 0 71.7-32.2 71.7-71.8V480c-.2-4.4-3.8-8-8.2-8z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), p$7 = [
  i$7
];
function m$6(e, _, d2, f2, h2, v2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    role: "presentation"
  }, p$7, 6);
}
const V = /* @__PURE__ */ l(a$5, [["render", m$6]]);
const a$4 = a$v("right"), i$6 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M381.262 1005.566c-16.132 21.51-45.708 24.198-67.217 8.066-21.51-16.132-24.198-45.708-8.066-67.217C413.526 806.604 518.384 666.792 625.932 529.67c8.066-10.755 8.066-24.198 0-34.953C518.384 354.906 413.526 215.094 305.979 77.972c-16.132-21.51-10.755-51.085 8.066-67.217C335.555-5.377 365.13 0 381.262 18.82c107.547 142.5 212.405 282.311 319.953 419.434 34.952 43.019 34.952 104.858 0 150.566-107.548 139.811-212.406 279.622-319.953 416.745",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), p$6 = [
  i$6
];
function m$5(e, _, d2, f2, h2, g2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    role: "presentation"
  }, p$6, 6);
}
const w$3 = /* @__PURE__ */ l(a$4, [["render", m$5]]);
const a$3 = a$v("service"), i$5 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M1024 657.723H905.846v-126.03c0-228.431-177.23-413.54-393.846-413.54s-393.846 185.109-393.846 413.54v126.03H0v-126.03C0 236.307 228.43 0 512 0s512 236.308 512 531.692v126.031zM196.923 866.462C86.646 866.462 0 779.815 0 669.538s86.646-196.923 196.923-196.923 196.923 86.647 196.923 196.923S307.2 866.462 196.923 866.462zm0-275.693c-43.323 0-78.77 35.446-78.77 78.77s35.447 78.769 78.77 78.769 78.77-35.446 78.77-78.77-35.447-78.769-78.77-78.769zm630.154 275.693c-110.277 0-196.923-86.647-196.923-196.924S716.8 472.615 827.077 472.615 1024 559.262 1024 669.538s-86.646 196.924-196.923 196.924zm0-275.693c-43.323 0-78.77 35.446-78.77 78.77s35.447 78.769 78.77 78.769 78.77-35.446 78.77-78.77-35.447-78.769-78.77-78.769zm-149.662 429.293c-23.63 0-47.261-15.754-55.138-43.324-7.877-31.507 7.877-63.015 39.385-74.83 102.4-31.508 189.046-102.4 236.307-196.923 15.754-27.57 51.2-39.385 78.77-23.631s39.384 51.2 23.63 78.77c-63.015 122.091-177.23 216.614-307.2 256-3.938 3.938-11.815 3.938-15.754 3.938z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), m$4 = [
  i$5
];
function p$5(e, _, d2, f2, v2, z2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    role: "presentation"
  }, m$4, 6);
}
const w$2 = /* @__PURE__ */ l(a$3, [["render", p$5]]);
const a$2 = a$v("star-fill-n"), i$4 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M1047.135 361.244 722.87 312.89 577.802 22.756c-2.844-8.534-11.378-14.223-19.911-17.067-19.911-8.533-45.511-2.845-54.045 17.067L358.78 312.889 34.513 358.4c-8.533 0-17.067 5.689-22.755 11.378-17.067 17.066-14.223 42.666 0 56.889l233.244 227.555-54.044 321.422c-2.845 8.534 0 17.067 2.844 25.6 11.378 19.912 34.133 28.445 54.044 17.067L537.98 867.556l290.133 150.755c8.533 2.845 17.067 5.689 25.6 2.845 22.756-2.845 36.978-25.6 34.133-45.512l-54.044-321.422 233.244-227.555c5.69-5.69 11.378-14.223 11.378-22.756 5.69-19.911-8.533-39.822-31.289-42.667z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), p$4 = [
  i$4
];
function f(e, m2, _, d2, u2, h2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1081 1024",
    role: "presentation"
  }, p$4, 6);
}
const v$2 = /* @__PURE__ */ l(a$2, [["render", f]]);
const a$1 = a$v("tips"), i$3 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M512 1024C230.4 1024 0 793.6 0 512S230.4 0 512 0s512 230.4 512 512-230.4 512-512 512zm0-938.667c-234.667 0-426.667 192-426.667 426.667s192 426.667 426.667 426.667 426.667-192 426.667-426.667S746.667 85.333 512 85.333zM448 320a64 64 0 1 0 128 0 64 64 0 1 0-128 0Zm-17.067 149.333h51.2c12.8 0 21.334 8.534 21.334 21.334v8.533c0 12.8-8.534 21.333-21.334 21.333h-51.2c-12.8 0-25.6-12.8-25.6-25.6s12.8-25.6 25.6-25.6zm51.2 0H524.8c25.6 0 51.2 21.334 51.2 51.2v8.534L537.6 755.2c0 8.533-8.533 17.067-21.333 17.067H473.6c-25.6 0-51.2-21.334-51.2-51.2v-8.534L460.8 486.4c4.267-8.533 12.8-17.067 21.333-17.067zm8.534 251.734h76.8c12.8 0 25.6 12.8 25.6 25.6s-12.8 25.6-25.6 25.6h-76.8c-12.8 0-21.334-8.534-21.334-21.334v-12.8c4.267-12.8 12.8-17.066 21.334-17.066z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), p$3 = [
  i$3
];
function m$3(e, _, d2, f2, h2, v2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    role: "presentation"
  }, p$3, 6);
}
const w$1 = /* @__PURE__ */ l(a$1, [["render", m$3]]);
const a = a$v("top"), p$2 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M136.533 540.444c-11.377 0-25.6-5.688-34.133-17.066-14.222-19.911-11.378-45.511 8.533-59.734L477.867 179.2c19.91-14.222 45.51-11.378 59.733 8.533s11.378 45.511-8.533 59.734L162.133 531.91c-5.689 5.689-14.222 8.533-25.6 8.533zm745.245 0c-8.534 0-17.067-2.844-25.6-8.533L489.244 247.467c-19.91-14.223-22.755-42.667-8.533-59.734 14.222-19.91 42.667-22.755 59.733-8.533l366.934 284.444c19.91 14.223 22.755 42.667 8.533 59.734-8.533 11.378-19.911 17.066-34.133 17.066zM512 1024c-22.756 0-42.667-19.911-42.667-42.667v-768c0-22.755 19.911-42.666 42.667-42.666s42.667 19.91 42.667 42.666v768c0 22.756-19.911 42.667-42.667 42.667zM884.622 85.333h-742.4c-22.755 0-42.666-19.91-42.666-42.666S119.466 0 142.222 0h742.4c22.756 0 42.667 19.911 42.667 42.667s-19.911 42.666-42.667 42.666z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), i$2 = [
  p$2
];
function m$2(e, _, d2, f2, h2, u2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    role: "presentation"
  }, i$2, 6);
}
const w = /* @__PURE__ */ l(a, [["render", m$2]]);
const c$1 = a$v("triangle-down"), i$1 = /* @__PURE__ */ createBaseVNode("path", {
  d: "m573.056 752 308.8-404.608A76.8 76.8 0 0 0 820.736 224H203.232a76.8 76.8 0 0 0-61.056 123.392L450.976 752a76.8 76.8 0 0 0 122.08 0z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), p$1 = [
  i$1
];
function m$1(e, d2, _, f2, w2, g2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    role: "presentation"
  }, p$1, 6);
}
const v$1 = /* @__PURE__ */ l(c$1, [["render", m$1]]);
const c = a$v("triangle-up"), i = /* @__PURE__ */ createBaseVNode("path", {
  d: "m573.056 272 308.8 404.608A76.8 76.8 0 0 1 820.736 800H203.232a76.8 76.8 0 0 1-61.056-123.392L450.976 272a76.8 76.8 0 0 1 122.08 0z",
  fill: "currentColor",
  "fill-opacity": "0.9"
}, null, -1), p = [
  i
];
function m(e, _, d2, f2, u2, g2) {
  return openBlock(), createElementBlock("svg", {
    class: normalizeClass(e.classes),
    style: normalizeStyle(e.style),
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 1024 1024",
    role: "presentation"
  }, p, 6);
}
const v = /* @__PURE__ */ l(c, [["render", m]]);
const withInstall = (comp) => {
  const _comp = comp;
  _comp.install = (vue) => {
    if (_comp.name) {
      vue.component(_comp.name, _comp);
    }
  };
  return _comp;
};
var __defProp$1f = Object.defineProperty;
var __defProps$19 = Object.defineProperties;
var __getOwnPropDescs$19 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1b = Object.getOwnPropertySymbols;
var __hasOwnProp$1b = Object.prototype.hasOwnProperty;
var __propIsEnum$1b = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1f = (obj, key, value) => key in obj ? __defProp$1f(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1b = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$1b.call(b, prop))
      __defNormalProp$1f(a2, prop, b[prop]);
  if (__getOwnPropSymbols$1b)
    for (var prop of __getOwnPropSymbols$1b(b)) {
      if (__propIsEnum$1b.call(b, prop))
        __defNormalProp$1f(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$19 = (a2, b) => __defProps$19(a2, __getOwnPropDescs$19(b));
const _hoisted_1$1a = { class: "nut-button__wrap" };
const _sfc_main$1G = /* @__PURE__ */ defineComponent(__spreadProps$19(__spreadValues$1b({}, {
  name: "NutButton"
}), {
  __name: "button",
  props: {
    color: { default: "" },
    shape: { default: "round" },
    plain: { type: Boolean, default: false },
    loading: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    type: { default: "default" },
    size: { default: "normal" },
    block: { type: Boolean, default: false }
  },
  emits: ["click"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const handleClick = (event) => {
      if (!props.loading && !props.disabled) {
        emit2("click", event);
      }
    };
    const classes = computed(() => {
      const prefixCls2 = "nut-button";
      return {
        [prefixCls2]: true,
        [`${prefixCls2}--${props.type}`]: props.type,
        [`${prefixCls2}--${props.size}`]: props.size,
        [`${prefixCls2}--${props.shape}`]: props.shape,
        [`${prefixCls2}--plain`]: props.plain,
        [`${prefixCls2}--block`]: props.block,
        [`${prefixCls2}--disabled`]: props.disabled,
        [`${prefixCls2}--loading`]: props.loading
      };
    });
    const getStyle = computed(() => {
      let style = {};
      if (props.color) {
        style = {
          color: props.plain ? props.color : "#fff",
          background: props.plain ? "#fff" : `border-box ${props.color}`
        };
        if (props.color.includes("gradient")) {
          style.borderColor = "transparent";
        } else {
          style.borderColor = props.color;
        }
      }
      return style;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("view", {
        class: normalizeClass(classes.value),
        style: normalizeStyle(getStyle.value),
        onClick: handleClick
      }, [
        createBaseVNode("view", _hoisted_1$1a, [
          _ctx.loading ? (openBlock(), createBlock(unref(u), {
            key: 0,
            class: "nut-icon-loading"
          })) : createCommentVNode("", true),
          _ctx.$slots.icon && !_ctx.loading ? renderSlot(_ctx.$slots, "icon", { key: 1 }) : createCommentVNode("", true),
          _ctx.$slots.default ? (openBlock(), createElementBlock("view", {
            key: 2,
            class: normalizeClass({ "nut-button__text": _ctx.$slots.icon || _ctx.loading })
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 2)) : createCommentVNode("", true)
        ])
      ], 6);
    };
  }
}));
withInstall(_sfc_main$1G);
function useRouter() {
  const proxy = getCurrentInstance().proxy;
  return proxy.$router || null;
}
const pxCheck = (value) => {
  if (value !== void 0) {
    return isNaN(Number(value)) ? String(value) : `${value}px`;
  }
};
var __defProp$1e = Object.defineProperty;
var __defProps$18 = Object.defineProperties;
var __getOwnPropDescs$18 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1a = Object.getOwnPropertySymbols;
var __hasOwnProp$1a = Object.prototype.hasOwnProperty;
var __propIsEnum$1a = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1e = (obj, key, value) => key in obj ? __defProp$1e(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1a = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$1a.call(b, prop))
      __defNormalProp$1e(a2, prop, b[prop]);
  if (__getOwnPropSymbols$1a)
    for (var prop of __getOwnPropSymbols$1a(b)) {
      if (__propIsEnum$1a.call(b, prop))
        __defNormalProp$1e(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$18 = (a2, b) => __defProps$18(a2, __getOwnPropDescs$18(b));
const _hoisted_1$19 = {
  key: 0,
  class: "nut-cell__icon"
};
const _hoisted_2$Z = {
  key: 1,
  class: "nut-cell__title"
};
const _hoisted_3$O = { class: "title" };
const _hoisted_4$E = { class: "nut-cell__title-desc" };
const _sfc_main$1F = /* @__PURE__ */ defineComponent(__spreadProps$18(__spreadValues$1a({}, {
  name: "NutCell"
}), {
  __name: "cell",
  props: {
    title: { default: "" },
    subTitle: { default: "" },
    desc: { default: "" },
    descTextAlign: { default: "right" },
    isLink: { type: Boolean, default: false },
    roundRadius: { default: "" },
    center: { type: Boolean, default: false },
    size: { default: "normal" },
    to: {},
    replace: { type: Boolean, default: false },
    url: { default: "" }
  },
  emits: ["click"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const classes = computed(() => {
      const prefixCls2 = "nut-cell";
      return {
        [prefixCls2]: true,
        [`${prefixCls2}--clickable`]: props.isLink || props.to,
        [`${prefixCls2}--center`]: props.center,
        [`${prefixCls2}--large`]: props.size === "large"
      };
    });
    const router = useRouter();
    const baseStyle = computed(() => {
      return {
        borderRadius: pxCheck(props.roundRadius)
      };
    });
    const descStyle = computed(() => {
      return {
        textAlign: props.descTextAlign
      };
    });
    const handleClick = (event) => {
      emit2("click", event);
      if (props.to && router) {
        router[props.replace ? "replace" : "push"](props.to);
      } else if (props.url) {
        props.replace ? location.replace(props.url) : location.href = props.url;
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("view", {
        class: normalizeClass(classes.value),
        style: normalizeStyle(baseStyle.value),
        onClick: handleClick
      }, [
        renderSlot(_ctx.$slots, "default", {}, () => [
          _ctx.$slots.icon ? (openBlock(), createElementBlock("view", _hoisted_1$19, [
            renderSlot(_ctx.$slots, "icon")
          ])) : createCommentVNode("", true),
          _ctx.title || _ctx.subTitle || _ctx.$slots.title ? (openBlock(), createElementBlock("view", _hoisted_2$Z, [
            _ctx.subTitle ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              renderSlot(_ctx.$slots, "title", {}, () => [
                createBaseVNode("view", _hoisted_3$O, toDisplayString(_ctx.title), 1)
              ]),
              createBaseVNode("view", _hoisted_4$E, toDisplayString(_ctx.subTitle), 1)
            ], 64)) : renderSlot(_ctx.$slots, "title", { key: 1 }, () => [
              createTextVNode(toDisplayString(_ctx.title), 1)
            ])
          ])) : createCommentVNode("", true),
          _ctx.desc || _ctx.$slots.desc ? (openBlock(), createElementBlock("view", {
            key: 2,
            class: normalizeClass(["nut-cell__value", { "nut-cell__value--alone": !_ctx.title && !_ctx.subTitle && !_ctx.$slots.title }]),
            style: normalizeStyle(descStyle.value)
          }, [
            renderSlot(_ctx.$slots, "desc", {}, () => [
              createTextVNode(toDisplayString(_ctx.desc), 1)
            ])
          ], 6)) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "link", {}, () => [
            _ctx.isLink || _ctx.to ? (openBlock(), createBlock(unref(w$3), {
              key: 0,
              class: "nut-cell__link"
            })) : createCommentVNode("", true)
          ])
        ])
      ], 6);
    };
  }
}));
withInstall(_sfc_main$1F);
var __defProp$1d = Object.defineProperty;
var __defProps$17 = Object.defineProperties;
var __getOwnPropDescs$17 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$19 = Object.getOwnPropertySymbols;
var __hasOwnProp$19 = Object.prototype.hasOwnProperty;
var __propIsEnum$19 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1d = (obj, key, value) => key in obj ? __defProp$1d(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$19 = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$19.call(b, prop))
      __defNormalProp$1d(a2, prop, b[prop]);
  if (__getOwnPropSymbols$19)
    for (var prop of __getOwnPropSymbols$19(b)) {
      if (__propIsEnum$19.call(b, prop))
        __defNormalProp$1d(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$17 = (a2, b) => __defProps$17(a2, __getOwnPropDescs$17(b));
const _hoisted_1$18 = { class: "nut-cell-group" };
const _hoisted_2$Y = {
  key: 1,
  class: "nut-cell-group__title"
};
const _hoisted_3$N = {
  key: 3,
  class: "nut-cell-group__desc"
};
const _hoisted_4$D = { class: "nut-cell-group__wrap" };
const _sfc_main$1E = /* @__PURE__ */ defineComponent(__spreadProps$17(__spreadValues$19({}, {
  name: "NutCellGroup"
}), {
  __name: "cell-group",
  props: {
    title: { default: "" },
    desc: { default: "" }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("view", _hoisted_1$18, [
        _ctx.$slots.title ? renderSlot(_ctx.$slots, "title", { key: 0 }) : _ctx.title ? (openBlock(), createElementBlock("view", _hoisted_2$Y, toDisplayString(_ctx.title), 1)) : createCommentVNode("", true),
        _ctx.$slots.desc ? renderSlot(_ctx.$slots, "desc", { key: 2 }) : _ctx.desc ? (openBlock(), createElementBlock("view", _hoisted_3$N, toDisplayString(_ctx.desc), 1)) : createCommentVNode("", true),
        createBaseVNode("view", _hoisted_4$D, [
          renderSlot(_ctx.$slots, "default")
        ])
      ]);
    };
  }
}));
withInstall(_sfc_main$1E);
const TypeOfFun = (value) => {
  if (null === value) {
    return "null";
  }
  const type = typeof value;
  if ("undefined" === type || "string" === type) {
    return type;
  }
  const typeString = toString.call(value);
  switch (typeString) {
    case "[object Array]":
      return "array";
    case "[object Date]":
      return "date";
    case "[object Boolean]":
      return "boolean";
    case "[object Number]":
      return "number";
    case "[object Function]":
      return "function";
    case "[object RegExp]":
      return "regexp";
    case "[object Object]":
      if (void 0 !== value.nodeType) {
        if (3 == value.nodeType) {
          return /\S/.test(value.nodeValue) ? "textnode" : "whitespace";
        } else {
          return "element";
        }
      } else {
        return "object";
      }
    default:
      return "unknow";
  }
};
const isArray = Array.isArray;
const isDate$1 = (val) => val instanceof Date;
const isFunction = (val) => typeof val === "function";
const isObject$1 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject$1(val) && isFunction(val.then) && isFunction(val.catch);
};
const docu = document;
const body = docu.body;
const getPropByPath = (obj, keyPath) => {
  try {
    return keyPath.split(".").reduce((prev, curr) => prev[curr], obj);
  } catch (error) {
    return "";
  }
};
const floatData = (format2, dataOp, mapOps) => {
  const mergeFormat = Object.assign({}, format2);
  const mergeMapOps = Object.assign({}, mapOps);
  if (Object.keys(dataOp).length > 0) {
    Object.keys(mergeFormat).forEach((keys) => {
      if (Object.prototype.hasOwnProperty.call(mergeMapOps, keys)) {
        const tof = TypeOfFun(mergeMapOps[keys]);
        if (tof == "function") {
          mergeFormat[keys] = mergeMapOps[keys](dataOp);
        }
        if (tof == "string") {
          mergeFormat[keys] = dataOp[mergeMapOps[keys]];
        }
      } else {
        if (dataOp[keys]) mergeFormat[keys] = dataOp[keys];
      }
    });
    return mergeFormat;
  }
  return format2;
};
function myFixed(num, digit = 2) {
  if (Object.is(parseFloat(num), NaN)) {
    return console.log(`传入的值：${num}不是一个数字`);
  }
  num = parseFloat(num);
  return (Math.round((num + Number.EPSILON) * Math.pow(10, digit)) / Math.pow(10, digit)).toFixed(digit);
}
function preventDefault(event, isStopPropagation) {
  if (typeof event.cancelable !== "boolean" || event.cancelable) {
    event.preventDefault();
  }
  if (isStopPropagation) {
    event.stopPropagation();
  }
}
const padZero = (num, length = 2) => {
  num += "";
  while (num.length < length) {
    num = "0" + num;
  }
  return num.toString();
};
const clamp = (num, min, max) => Math.min(Math.max(num, min), max);
const getScrollTopRoot = () => {
  return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
};
var __defProp$1c = Object.defineProperty;
var __defProps$16 = Object.defineProperties;
var __getOwnPropDescs$16 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$18 = Object.getOwnPropertySymbols;
var __hasOwnProp$18 = Object.prototype.hasOwnProperty;
var __propIsEnum$18 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1c = (obj, key, value) => key in obj ? __defProp$1c(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$18 = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$18.call(b, prop))
      __defNormalProp$1c(a2, prop, b[prop]);
  if (__getOwnPropSymbols$18)
    for (var prop of __getOwnPropSymbols$18(b)) {
      if (__propIsEnum$18.call(b, prop))
        __defNormalProp$1c(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$16 = (a2, b) => __defProps$16(a2, __getOwnPropDescs$16(b));
let count = 0;
const CLSNAME = "nut-overflow-hidden";
const useLockScroll = (isLock) => {
  const lock = () => {
    if (isLock()) {
      try {
        !count && body.classList.add(CLSNAME);
        count++;
      } catch (error) {
        console.warn("[NutUI] <useLockScroll>", error);
      }
    }
  };
  const unlock = () => {
    if (isLock() && count) {
      try {
        count--;
        !count && body.classList.remove(CLSNAME);
      } catch (error) {
        console.warn("[NutUI] <unlock>", error);
      }
    }
  };
  return [lock, unlock];
};
const _sfc_main$1D = /* @__PURE__ */ defineComponent(__spreadProps$16(__spreadValues$18({}, {
  name: "NutOverlay"
}), {
  __name: "overlay",
  props: {
    visible: { type: Boolean, default: false },
    zIndex: { default: 2e3 },
    duration: { default: 0.3 },
    lockScroll: { type: Boolean, default: true },
    overlayClass: { default: "" },
    overlayStyle: {},
    closeOnClickOverlay: { type: Boolean, default: true }
  },
  emits: ["click", "update:visible"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const [lock, unlock] = useLockScroll(() => props.lockScroll);
    const classes = computed(() => {
      const prefixCls2 = "nut-overlay";
      return {
        [prefixCls2]: true,
        [props.overlayClass]: true
      };
    });
    const style = computed(() => {
      return __spreadValues$18({
        transitionDuration: `${props.duration}s`,
        zIndex: props.zIndex
      }, props.overlayStyle);
    });
    watchEffect(() => {
      props.visible ? lock() : unlock();
    });
    const onClick = (e) => {
      emit2("click", e);
      if (props.closeOnClickOverlay) {
        emit2("update:visible", false);
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Transition, { name: "overlay-fade" }, {
        default: withCtx(() => [
          withDirectives(createBaseVNode("view", {
            class: normalizeClass(classes.value),
            style: normalizeStyle(style.value),
            onClick: withModifiers(onClick, ["stop"])
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 6), [
            [vShow, _ctx.visible]
          ])
        ]),
        _: 3
      });
    };
  }
}));
withInstall(_sfc_main$1D);
const camelize = (s) => s.replace(/-./g, (x) => x[1].toUpperCase());
function createComponent(name) {
  const componentName2 = "nut-" + name;
  return {
    componentName: componentName2,
    create: function(_component) {
      _component.name = "Nut" + camelize("-" + name);
      _component.install = (vue) => {
        vue.component(_component.name, _component);
      };
      return /* @__PURE__ */ defineComponent(_component);
    }
  };
}
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
var __defProp$1b = Object.defineProperty;
var __defProps$15 = Object.defineProperties;
var __getOwnPropDescs$15 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$17 = Object.getOwnPropertySymbols;
var __hasOwnProp$17 = Object.prototype.hasOwnProperty;
var __propIsEnum$17 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1b = (obj, key, value) => key in obj ? __defProp$1b(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$17 = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$17.call(b, prop))
      __defNormalProp$1b(a2, prop, b[prop]);
  if (__getOwnPropSymbols$17)
    for (var prop of __getOwnPropSymbols$17(b)) {
      if (__propIsEnum$17.call(b, prop))
        __defNormalProp$1b(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$15 = (a2, b) => __defProps$15(a2, __getOwnPropDescs$15(b));
const popupProps = {
  visible: {
    type: Boolean,
    default: false
  },
  zIndex: {
    type: [Number, String],
    default: 2e3
  },
  duration: {
    type: [Number, String],
    default: 0.3
  },
  lockScroll: {
    type: Boolean,
    default: true
  },
  closeOnClickOverlay: {
    type: Boolean,
    default: true
  },
  position: {
    type: String,
    default: "center"
  },
  transition: {
    type: String,
    default: ""
  },
  style: {
    type: Object,
    default: () => ({})
  },
  popClass: {
    type: String,
    default: ""
  },
  closeable: {
    type: Boolean,
    default: false
  },
  closeIconPosition: {
    type: String,
    default: "top-right"
  },
  destroyOnClose: {
    type: Boolean,
    default: true
  },
  teleport: {
    type: [String, Element],
    default: "body"
  },
  overlay: {
    type: Boolean,
    default: true
  },
  round: {
    type: Boolean,
    default: false
  },
  teleportDisable: {
    type: Boolean,
    default: false
  },
  safeAreaInsetBottom: {
    type: Boolean,
    default: false
  },
  overlayClass: {
    type: String,
    default: ""
  },
  overlayStyle: {
    type: Object,
    default: () => ({})
  }
};
const { componentName: componentName$7, create: create$10 } = createComponent("popup");
const initIndex = 2e3;
let _zIndex = initIndex;
const _sfc_main$1C = create$10({
  components: {
    NutOverlay: _sfc_main$1D,
    Close: g$4
  },
  props: popupProps,
  emits: ["clickPop", "clickCloseIcon", "open", "close", "opened", "closed", "clickOverlay", "update:visible"],
  setup(props, { emit: emit2 }) {
    let opened;
    const state = reactive({
      zIndex: props.zIndex,
      showSlot: true,
      closed: props.closeable
    });
    const classes = computed(() => {
      const prefixCls2 = componentName$7;
      return {
        [prefixCls2]: true,
        ["round"]: props.round,
        [`nut-popup--${props.position}`]: true,
        [`nut-popup--${props.position}--safebottom`]: props.position === "bottom" && props.safeAreaInsetBottom,
        [props.popClass]: true
      };
    });
    const popStyle = computed(() => {
      return __spreadValues$17({
        zIndex: state.zIndex,
        transitionDuration: `${props.duration}s`
      }, props.style);
    });
    const transitionName = computed(() => {
      return props.transition ? props.transition : `nut-popup-slide-${props.position}`;
    });
    const open = () => {
      if (!opened) {
        opened = true;
        if (props.zIndex !== initIndex) {
          _zIndex = Number(props.zIndex);
        }
        emit2("update:visible", true);
        state.zIndex = ++_zIndex;
        if (props.destroyOnClose) {
          state.showSlot = true;
        }
        emit2("open");
      }
    };
    const close = () => {
      if (opened) {
        opened = false;
        emit2("update:visible", false);
        emit2("close");
        if (props.destroyOnClose) {
          setTimeout(() => {
            state.showSlot = false;
          }, +props.duration * 1e3);
        }
      }
    };
    const onClick = (e) => {
      emit2("clickPop", e);
    };
    const onClickCloseIcon = (e) => {
      e.stopPropagation();
      emit2("clickCloseIcon", e);
      close();
    };
    const onClickOverlay = (e) => {
      emit2("clickOverlay", e);
      if (props.closeOnClickOverlay) {
        close();
      }
    };
    const onOpened = (el) => {
      emit2("opened", el);
    };
    const onClosed = (el) => {
      emit2("closed", el);
    };
    watch(
      () => props.visible,
      () => {
        if (props.visible && !opened) {
          open();
        }
        if (!props.visible && opened) {
          close();
        }
      }
    );
    watchEffect(() => {
      state.closed = props.closeable;
    });
    return __spreadProps$15(__spreadValues$17({}, toRefs(state)), {
      popStyle,
      transitionName,
      classes,
      onClick,
      onClickCloseIcon,
      onClickOverlay,
      onOpened,
      onClosed
    });
  }
});
function _sfc_render$X(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_overlay = resolveComponent("nut-overlay");
  const _component_Close = resolveComponent("Close");
  return openBlock(), createBlock(Teleport, {
    to: _ctx.teleport,
    disabled: !_ctx.teleportDisable
  }, [
    _ctx.overlay ? (openBlock(), createBlock(_component_nut_overlay, mergeProps({
      key: 0,
      visible: _ctx.visible,
      "close-on-click-overlay": _ctx.closeOnClickOverlay,
      "z-index": _ctx.zIndex,
      "lock-scroll": _ctx.lockScroll,
      duration: _ctx.duration,
      "overlay-class": _ctx.overlayClass,
      "overlay-style": _ctx.overlayStyle
    }, _ctx.$attrs, { onClick: _ctx.onClickOverlay }), null, 16, ["visible", "close-on-click-overlay", "z-index", "lock-scroll", "duration", "overlay-class", "overlay-style", "onClick"])) : createCommentVNode("", true),
    createVNode(Transition, {
      name: _ctx.transitionName,
      onAfterEnter: _ctx.onOpened,
      onAfterLeave: _ctx.onClosed
    }, {
      default: withCtx(() => [
        withDirectives(createBaseVNode("view", {
          class: normalizeClass(_ctx.classes),
          style: normalizeStyle(_ctx.popStyle),
          onClick: _cache[1] || (_cache[1] = (...args) => _ctx.onClick && _ctx.onClick(...args))
        }, [
          _ctx.showSlot ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("", true),
          _ctx.closed ? (openBlock(), createElementBlock("view", {
            key: 1,
            class: normalizeClass(["nut-popup__close-icon", "nut-popup__close-icon--" + _ctx.closeIconPosition]),
            onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClickCloseIcon && _ctx.onClickCloseIcon(...args))
          }, [
            renderSlot(_ctx.$slots, "close-icon", {}, () => [
              createVNode(_component_Close, { height: "12px" })
            ])
          ], 2)) : createCommentVNode("", true)
        ], 6), [
          [vShow, _ctx.visible]
        ])
      ]),
      _: 3
    }, 8, ["name", "onAfterEnter", "onAfterLeave"])
  ], 8, ["to", "disabled"]);
}
const NutPopup = /* @__PURE__ */ _export_sfc(_sfc_main$1C, [["render", _sfc_render$X]]);
const component = (tag) => {
  return {
    props: {
      theme: { type: String, default: "" },
      themeVars: { type: Object, default: {} },
      tag: { type: String, default: tag }
    },
    setup(props, { slots }) {
      const hexToRgb = (color) => {
        const reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
        if (!reg.test(color)) return "";
        color = color.toLowerCase();
        if (color.length === 4) {
          color = "#" + color.slice(1).split("").map((char) => char + char).join("");
        }
        const colors = [];
        for (let i2 = 1; i2 < 7; i2 += 2) {
          colors.push(parseInt("0x" + color.slice(i2, i2 + 2)));
        }
        return colors.join(",");
      };
      const kebabCase = (str) => {
        str = str.replace(str.charAt(0), str.charAt(0).toLocaleLowerCase());
        return str.replace(/([a-z])([A-Z])/g, (_, p1, p2) => p1 + "-" + p2.toLowerCase());
      };
      const mapThemeVarsToCSSVars = (themeVars) => {
        if (!themeVars) return;
        const cssVars = {};
        const primaryColor = themeVars == null ? void 0 : themeVars.primaryColor;
        if (primaryColor) {
          const primaryColorRgb = hexToRgb(primaryColor);
          cssVars["--nut-address-region-tab-line"] = `linear-gradient(90deg, ${primaryColor} 0%, rgba(${primaryColorRgb}, 0.15) 100%)`;
          cssVars["--nut-tabs-horizontal-tab-line-color"] = `linear-gradient(90deg, ${primaryColor} 0%, rgba(${primaryColorRgb}, 0.15) 100%)`;
          cssVars["--nut-tabs-vertical-tab-line-color"] = `linear-gradient(180deg, ${primaryColor} 0%, rgba(${primaryColorRgb}, 0.15) 100%)`;
        }
        Object.keys(themeVars).forEach((key) => {
          cssVars[`--nut-${kebabCase(key)}`] = themeVars[key];
        });
        return cssVars;
      };
      const themeStyle = computed(() => mapThemeVarsToCSSVars(props.themeVars));
      return () => {
        var _a;
        return h$2(
          props.tag,
          {
            class: `nut-theme-${props.theme}`,
            style: themeStyle.value
          },
          (_a = slots.default) == null ? void 0 : _a.call(slots)
        );
      };
    }
  };
};
const { create: create$$ } = createComponent("config-provider");
const _sfc_main$1B = create$$(component("div"));
var __defProp$1a = Object.defineProperty;
var __defProps$14 = Object.defineProperties;
var __getOwnPropDescs$14 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$16 = Object.getOwnPropertySymbols;
var __hasOwnProp$16 = Object.prototype.hasOwnProperty;
var __propIsEnum$16 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1a = (obj, key, value) => key in obj ? __defProp$1a(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$16 = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$16.call(b, prop))
      __defNormalProp$1a(a2, prop, b[prop]);
  if (__getOwnPropSymbols$16)
    for (var prop of __getOwnPropSymbols$16(b)) {
      if (__propIsEnum$16.call(b, prop))
        __defNormalProp$1a(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$14 = (a2, b) => __defProps$14(a2, __getOwnPropDescs$14(b));
const _hoisted_1$17 = ["src", "data-src", "alt"];
const _hoisted_2$X = {
  key: 0,
  class: "nut-img-loading"
};
const _hoisted_3$M = {
  key: 1,
  class: "nut-img-error"
};
const _sfc_main$1A = /* @__PURE__ */ defineComponent(__spreadProps$14(__spreadValues$16({}, {
  name: "NutImage"
}), {
  __name: "image",
  props: {
    src: {},
    fit: { default: "fill" },
    position: { default: "center" },
    alt: { default: "" },
    width: { default: "" },
    height: { default: "" },
    round: { type: Boolean, default: false },
    radius: {},
    showError: { type: Boolean, default: true },
    showLoading: { type: Boolean, default: true },
    lazyLoad: { type: Boolean, default: false }
  },
  emits: ["click", "load", "error"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const loading = ref(true);
    const isError = ref(false);
    const classes = computed(() => {
      const prefixCls2 = "nut-image";
      return {
        [prefixCls2]: true,
        [`${prefixCls2}-round`]: props.round
      };
    });
    const observer = ref(null);
    const show = ref(false);
    const imgRef = ref(null);
    const initObserver = () => {
      const options = {
        threshold: [0],
        rootMargin: "0px"
      };
      observer.value = new IntersectionObserver((entires) => {
        entires.forEach((item) => {
          if (item.isIntersecting) {
            show.value = true;
            observer.value.disconnect();
          }
        });
      }, options);
      imgRef.value && observer.value.observe(imgRef.value);
    };
    onMounted(() => {
      props.lazyLoad && initObserver();
    });
    onBeforeUnmount(() => {
      observer.value && observer.value.disconnect();
    });
    const stylebox = computed(() => {
      let style = {};
      if (props.width) style.width = pxCheck(props.width);
      if (props.height) style.height = pxCheck(props.height);
      if (props.radius !== void 0 && props.radius !== null) {
        style.overflow = "hidden";
        style.borderRadius = pxCheck(props.radius);
      }
      return style;
    });
    const styles = computed(() => {
      let styless = {
        objectFit: props.fit,
        objectPosition: props.position
      };
      return styless;
    });
    watch(
      () => props.src,
      () => {
        isError.value = false;
        loading.value = true;
      }
    );
    const load = () => {
      isError.value = false;
      loading.value = false;
      emit2("load");
    };
    const error = () => {
      isError.value = true;
      loading.value = false;
      emit2("error");
    };
    const imageClick = (event) => {
      emit2("click", event);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(classes.value),
        style: normalizeStyle(stylebox.value),
        onClick: imageClick
      }, [
        createBaseVNode("img", {
          ref_key: "imgRef",
          ref: imgRef,
          class: "nut-img",
          src: _ctx.lazyLoad ? show.value ? _ctx.src : void 0 : _ctx.src,
          "data-src": _ctx.lazyLoad ? show.value ? void 0 : _ctx.src : void 0,
          alt: _ctx.alt,
          style: normalizeStyle(styles.value),
          onLoad: load,
          onError: error
        }, null, 44, _hoisted_1$17),
        loading.value ? (openBlock(), createElementBlock("div", _hoisted_2$X, [
          renderSlot(_ctx.$slots, "loading", {}, () => [
            createVNode(unref(y), {
              width: "16px",
              height: "20px",
              name: "image"
            })
          ])
        ])) : createCommentVNode("", true),
        isError.value && !loading.value ? (openBlock(), createElementBlock("div", _hoisted_3$M, [
          renderSlot(_ctx.$slots, "error", {}, () => [
            createVNode(unref(y$1), {
              width: "16px",
              height: "20px",
              name: "imageError"
            })
          ])
        ])) : createCommentVNode("", true)
      ], 6);
    };
  }
}));
withInstall(_sfc_main$1A);
const { create: create$_ } = createComponent("layout");
const _sfc_main$1z = create$_({});
withInstall(_sfc_main$1z);
const LAYOUT_KEY = Symbol("nut-layout");
var __defProp$19 = Object.defineProperty;
var __defProps$13 = Object.defineProperties;
var __getOwnPropDescs$13 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$15 = Object.getOwnPropertySymbols;
var __hasOwnProp$15 = Object.prototype.hasOwnProperty;
var __propIsEnum$15 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$19 = (obj, key, value) => key in obj ? __defProp$19(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$15 = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$15.call(b, prop))
      __defNormalProp$19(a2, prop, b[prop]);
  if (__getOwnPropSymbols$15)
    for (var prop of __getOwnPropSymbols$15(b)) {
      if (__propIsEnum$15.call(b, prop))
        __defNormalProp$19(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$13 = (a2, b) => __defProps$13(a2, __getOwnPropDescs$13(b));
const prefixCls$1 = "nut-col";
const _sfc_main$1y = /* @__PURE__ */ defineComponent(__spreadProps$13(__spreadValues$15({}, {
  name: "NutCol"
}), {
  __name: "col",
  props: {
    span: { default: 24 },
    offset: { default: 0 }
  },
  setup(__props) {
    const props = __props;
    const gutter = inject(LAYOUT_KEY);
    const classes = computed(() => {
      return {
        [prefixCls$1]: true,
        [prefixCls$1 + "-gutter"]: gutter,
        ["nut-col-" + props.span]: true,
        ["nut-col-offset-" + props.offset]: true
      };
    });
    const style = computed(() => {
      return {
        paddingLeft: gutter / 2 + "px",
        paddingRight: gutter / 2 + "px"
      };
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("view", {
        class: normalizeClass(classes.value),
        style: normalizeStyle(style.value)
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 6);
    };
  }
}));
withInstall(_sfc_main$1y);
var __defProp$18 = Object.defineProperty;
var __defProps$12 = Object.defineProperties;
var __getOwnPropDescs$12 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$14 = Object.getOwnPropertySymbols;
var __hasOwnProp$14 = Object.prototype.hasOwnProperty;
var __propIsEnum$14 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$18 = (obj, key, value) => key in obj ? __defProp$18(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$14 = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$14.call(b, prop))
      __defNormalProp$18(a2, prop, b[prop]);
  if (__getOwnPropSymbols$14)
    for (var prop of __getOwnPropSymbols$14(b)) {
      if (__propIsEnum$14.call(b, prop))
        __defNormalProp$18(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$12 = (a2, b) => __defProps$12(a2, __getOwnPropDescs$12(b));
const prefixCls = "nut-row";
const _sfc_main$1x = /* @__PURE__ */ defineComponent(__spreadProps$12(__spreadValues$14({}, {
  name: "NutRow"
}), {
  __name: "row",
  props: {
    type: { default: "" },
    gutter: { default: "" },
    justify: { default: "start" },
    align: { default: "flex-start" },
    flexWrap: { default: "nowrap" }
  },
  setup(__props) {
    const props = __props;
    provide(LAYOUT_KEY, props.gutter);
    const getClass = (prefix2, type) => {
      return prefix2 ? type ? `nut-row-${prefix2}-${type}` : "" : `nut-row-${type}`;
    };
    const classes = computed(() => {
      return [
        prefixCls,
        getClass("", props.type),
        getClass("justify", props.justify),
        getClass("align", props.align),
        getClass("flex", props.flexWrap)
      ];
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("view", {
        class: normalizeClass(classes.value)
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 2);
    };
  }
}));
withInstall(_sfc_main$1x);
const overflowScrollReg = /scroll|auto|overlay/i;
const defaultRoot = window;
function isElement(node) {
  const ELEMENT_NODE_TYPE = 1;
  return node.tagName !== "HTML" && node.tagName !== "BODY" && node.nodeType === ELEMENT_NODE_TYPE;
}
function getScrollParent(el, root = defaultRoot) {
  let node = el;
  while (node && node !== root && isElement(node)) {
    const { overflowY } = window.getComputedStyle(node);
    if (overflowScrollReg.test(overflowY)) {
      return node;
    }
    node = node.parentNode;
  }
  return root;
}
function useScrollParent(el, root = defaultRoot) {
  const scrollParent = ref();
  onMounted(() => {
    if (el.value) {
      scrollParent.value = getScrollParent(el.value, root);
    }
  });
  return scrollParent;
}
function isWindow(val) {
  return typeof window !== "undefined" && val === window;
}
const useRect = (elementRef) => {
  const element = unref(elementRef);
  if (isWindow(element)) {
    const width = element.innerWidth;
    const height = element.innerHeight;
    return {
      top: 0,
      left: 0,
      right: width,
      bottom: height,
      width,
      height
    };
  }
  if (element && element.getBoundingClientRect) {
    return element.getBoundingClientRect();
  }
  return {
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    width: 0,
    height: 0
  };
};
const { create: create$Z } = createComponent("sticky");
const _sfc_main$1w = create$Z({
  props: {
    position: {
      type: String,
      default: "top"
    },
    top: {
      type: [Number, String],
      default: 0
    },
    bottom: {
      type: [Number, String],
      default: 0
    },
    container: {
      type: Object,
      default: null
    },
    zIndex: {
      type: [Number, String],
      default: 99
    }
  },
  emits: ["change"],
  setup(props, { emit: emit2 }) {
    const rootRef = ref();
    const stickyRef = ref();
    const state = reactive({
      fixed: false,
      height: 0,
      width: 0,
      transform: 0
    });
    const threshold = computed(() => {
      return props.position === "top" ? Number(props.top) : Number(props.bottom);
    });
    const rootStyle = computed(() => {
      if (state.fixed) return { height: `${state.height}px` };
      return {};
    });
    const stickyStyle = computed(() => {
      if (!state.fixed) return {};
      return {
        [props.position]: `${threshold.value}px`,
        height: `${state.height}px`,
        width: `${state.width}px`,
        transform: state.transform ? `translate3d(0, ${state.transform}px, 0)` : void 0,
        position: state.fixed ? "fixed" : void 0,
        zIndex: Number(props.zIndex)
      };
    });
    const handleScroll = () => {
      const containerEle = props.container;
      if (!rootRef.value && !containerEle) return;
      const rootRect = useRect(rootRef);
      const stCurrent = stickyRef.value;
      const stickyRect = useRect(stCurrent);
      const containerRect = useRect(containerEle);
      state.height = rootRect.height;
      state.width = rootRect.width;
      const getFixed = () => {
        let fixed = false;
        if (props.position === "top") {
          fixed = containerEle ? threshold.value > rootRect.top && containerRect.bottom > 0 : threshold.value > rootRect.top;
        } else {
          const clientHeight = document.documentElement.clientHeight;
          fixed = containerEle ? containerRect.bottom > 0 && clientHeight - threshold.value - stickyRect.height > containerRect.top : clientHeight - threshold.value < rootRect.bottom;
        }
        return fixed;
      };
      const getTransform = () => {
        if (containerEle) {
          if (props.position === "top") {
            const diff = containerRect.bottom - threshold.value - stickyRect.height;
            return diff < 0 ? diff : 0;
          } else {
            const clientHeight = document.documentElement.clientHeight;
            const diff = containerRect.bottom - (clientHeight - threshold.value);
            return diff < 0 ? diff : 0;
          }
        }
        return 0;
      };
      state.transform = getTransform();
      state.fixed = getFixed();
    };
    watch(
      () => state.fixed,
      (val) => {
        emit2("change", val);
      }
    );
    onMounted(() => {
      handleScroll();
      const el = getScrollParent(rootRef.value);
      el.addEventListener("scroll", handleScroll, true);
    });
    onUnmounted(() => {
      const el = getScrollParent(rootRef.value);
      el.removeEventListener("scroll", handleScroll);
    });
    return { rootRef, rootStyle, stickyRef, stickyStyle };
  }
});
function _sfc_render$W(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "rootRef",
    class: "nut-sticky",
    style: normalizeStyle(_ctx.rootStyle)
  }, [
    createBaseVNode("div", {
      ref: "stickyRef",
      class: "nut-sticky__box",
      style: normalizeStyle(_ctx.stickyStyle)
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 4)
  ], 4);
}
const NutSticky = /* @__PURE__ */ _export_sfc(_sfc_main$1w, [["render", _sfc_render$W]]);
var __defProp$17 = Object.defineProperty;
var __defProps$11 = Object.defineProperties;
var __getOwnPropDescs$11 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$13 = Object.getOwnPropertySymbols;
var __hasOwnProp$13 = Object.prototype.hasOwnProperty;
var __propIsEnum$13 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$17 = (obj, key, value) => key in obj ? __defProp$17(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$13 = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$13.call(b, prop))
      __defNormalProp$17(a2, prop, b[prop]);
  if (__getOwnPropSymbols$13)
    for (var prop of __getOwnPropSymbols$13(b)) {
      if (__propIsEnum$13.call(b, prop))
        __defNormalProp$17(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$11 = (a2, b) => __defProps$11(a2, __getOwnPropDescs$11(b));
const _sfc_main$1v = /* @__PURE__ */ defineComponent(__spreadProps$11(__spreadValues$13({}, {
  name: "NutDivider"
}), {
  __name: "divider",
  props: {
    contentPosition: { default: "center" },
    dashed: { type: Boolean, default: false },
    hairline: { type: Boolean, default: true },
    direction: { default: "horizontal" }
  },
  setup(__props) {
    const props = __props;
    const slots = useSlots();
    const classes = computed(() => {
      const prefixCls2 = "nut-divider";
      if (props.direction === "horizontal") {
        return {
          [prefixCls2]: true,
          [`${prefixCls2}-center`]: slots.default,
          [`${prefixCls2}-left`]: props.contentPosition === "left",
          [`${prefixCls2}-right`]: props.contentPosition === "right",
          [`${prefixCls2}-dashed`]: props.dashed,
          [`${prefixCls2}-hairline`]: props.hairline
        };
      } else {
        return {
          [prefixCls2]: true,
          [`${prefixCls2}-vertical`]: props.direction === "vertical"
        };
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("view", {
        class: normalizeClass(classes.value)
      }, [
        _ctx.direction === "horizontal" ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("", true)
      ], 2);
    };
  }
}));
withInstall(_sfc_main$1v);
var __defProp$16 = Object.defineProperty;
var __getOwnPropSymbols$12 = Object.getOwnPropertySymbols;
var __hasOwnProp$12 = Object.prototype.hasOwnProperty;
var __propIsEnum$12 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$16 = (obj, key, value) => key in obj ? __defProp$16(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$12 = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$12.call(b, prop))
      __defNormalProp$16(a2, prop, b[prop]);
  if (__getOwnPropSymbols$12)
    for (var prop of __getOwnPropSymbols$12(b)) {
      if (__propIsEnum$12.call(b, prop))
        __defNormalProp$16(a2, prop, b[prop]);
    }
  return a2;
};
const useChildren = (key) => {
  const publicChildren = reactive([]);
  const internalChildren = reactive([]);
  const linkChildren = (value) => {
    const link = (child) => {
      if (child.proxy) {
        internalChildren.push(child);
        publicChildren.push(child.proxy);
      }
    };
    const unlink = (child) => {
      if (child.proxy) {
        const internalIndex = internalChildren.indexOf(child);
        if (internalIndex > -1) {
          internalChildren.splice(internalIndex, 1);
        }
        const publicIndex = publicChildren.indexOf(child.proxy);
        if (internalIndex > -1) {
          publicChildren.splice(publicIndex, 1);
        }
      }
    };
    provide(key, __spreadValues$12({
      unlink,
      link,
      children: publicChildren,
      internalChildren
    }, value));
  };
  return {
    children: publicChildren,
    linkChildren
  };
};
const GRID_KEY = Symbol("grid");
var __defProp$15 = Object.defineProperty;
var __defProps$10 = Object.defineProperties;
var __getOwnPropDescs$10 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$11 = Object.getOwnPropertySymbols;
var __hasOwnProp$11 = Object.prototype.hasOwnProperty;
var __propIsEnum$11 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$15 = (obj, key, value) => key in obj ? __defProp$15(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$11 = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$11.call(b, prop))
      __defNormalProp$15(a2, prop, b[prop]);
  if (__getOwnPropSymbols$11)
    for (var prop of __getOwnPropSymbols$11(b)) {
      if (__propIsEnum$11.call(b, prop))
        __defNormalProp$15(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$10 = (a2, b) => __defProps$10(a2, __getOwnPropDescs$10(b));
const _sfc_main$1u = /* @__PURE__ */ defineComponent(__spreadProps$10(__spreadValues$11({}, {
  name: "NutGrid"
}), {
  __name: "grid",
  props: {
    columnNum: { default: 4 },
    border: { type: Boolean, default: true },
    gutter: { default: 0 },
    center: { type: Boolean, default: true },
    square: { type: Boolean, default: false },
    reverse: { type: Boolean, default: false },
    direction: {},
    clickable: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    const { linkChildren } = useChildren(GRID_KEY);
    linkChildren({ props });
    const rootClass = computed(() => {
      const prefixCls2 = "nut-grid";
      return {
        [prefixCls2]: true,
        [`${prefixCls2}--border`]: props.border && !props.gutter
      };
    });
    const rootStyle = computed(() => {
      const style = {};
      if (props.gutter) {
        style.paddingLeft = pxCheck(props.gutter);
      }
      return style;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("view", {
        class: normalizeClass(rootClass.value),
        style: normalizeStyle(rootStyle.value)
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 6);
    };
  }
}));
withInstall(_sfc_main$1u);
const useParent = (key) => {
  const parent = inject(key, null);
  if (parent) {
    const instance = getCurrentInstance();
    const { link, unlink, internalChildren } = parent;
    link(instance);
    onUnmounted(() => {
      unlink(instance);
    });
    const index2 = computed(() => internalChildren.indexOf(instance));
    return { parent, index: index2 };
  }
  return {
    parent,
    index: computed(() => -1)
  };
};
var __defProp$14 = Object.defineProperty;
var __defProps$$ = Object.defineProperties;
var __getOwnPropDescs$$ = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$10 = Object.getOwnPropertySymbols;
var __hasOwnProp$10 = Object.prototype.hasOwnProperty;
var __propIsEnum$10 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$14 = (obj, key, value) => key in obj ? __defProp$14(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$10 = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$10.call(b, prop))
      __defNormalProp$14(a2, prop, b[prop]);
  if (__getOwnPropSymbols$10)
    for (var prop of __getOwnPropSymbols$10(b)) {
      if (__propIsEnum$10.call(b, prop))
        __defNormalProp$14(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$$ = (a2, b) => __defProps$$(a2, __getOwnPropDescs$$(b));
const _hoisted_1$16 = { class: "nut-grid-item__text" };
const _sfc_main$1t = /* @__PURE__ */ defineComponent(__spreadProps$$(__spreadValues$10({}, {
  name: "NutGridItem"
}), {
  __name: "grid-item",
  props: {
    text: {},
    to: {},
    url: { default: "" },
    replace: { type: Boolean, default: false }
  },
  emits: ["click"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const { parent: parentObj, index: index2 } = useParent(GRID_KEY);
    const parent = (parentObj == null ? void 0 : parentObj.props) || {};
    const rootStyle = computed(() => {
      const style = {
        flexBasis: `${100 / +parent.columnNum}%`
      };
      if (parent.square) {
        style.paddingTop = `${100 / +parent.columnNum}%`;
      } else if (parent.gutter) {
        style.paddingRight = pxCheck(parent.gutter);
        if (index2.value >= +parent.columnNum) {
          style.marginTop = pxCheck(parent.gutter);
        }
      }
      return style;
    });
    const contentClass = computed(() => {
      const prefixCls2 = `nut-grid-item__content`;
      return {
        [`${prefixCls2}`]: true,
        [`${prefixCls2}--border`]: parent.border,
        [`${prefixCls2}--surround`]: parent.border && parent.gutter,
        [`${prefixCls2}--center`]: parent.center,
        [`${prefixCls2}--square`]: parent.square,
        [`${prefixCls2}--reverse`]: parent.reverse,
        [`${prefixCls2}--${parent.direction}`]: !!parent.direction,
        [`${prefixCls2}--clickable`]: parent.clickable || props.to || props.url
      };
    });
    const router = useRouter();
    const handleClick = (event) => {
      emit2("click", event);
      if (props.to && router) {
        router[props.replace ? "replace" : "push"](props.to);
      } else if (props.url) {
        props.replace ? location.replace(props.url) : location.href = props.url;
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("view", {
        class: "nut-grid-item",
        style: normalizeStyle(rootStyle.value),
        onClick: handleClick
      }, [
        createBaseVNode("view", {
          class: normalizeClass(contentClass.value)
        }, [
          renderSlot(_ctx.$slots, "default"),
          createBaseVNode("view", _hoisted_1$16, [
            _ctx.text ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createTextVNode(toDisplayString(_ctx.text), 1)
            ], 64)) : renderSlot(_ctx.$slots, "text", { key: 1 })
          ])
        ], 2)
      ], 4);
    };
  }
}));
withInstall(_sfc_main$1t);
const { create: create$Y, componentName: componentName$6 } = createComponent("space");
const _sfc_main$1s = create$Y({
  props: {
    align: String,
    direction: {
      type: String,
      default: "horizontal"
    },
    justify: String,
    wrap: Boolean,
    gutter: [Number, String, Array],
    fill: Boolean
  },
  setup(props, { slots }) {
    const getMargin = (gutter) => {
      if (typeof gutter === "number") {
        return gutter + "px";
      }
      return gutter;
    };
    const getMarginStyle = (isLast) => {
      const style = {};
      if (!props.gutter) return style;
      const marginRight = `${getMargin(Array.isArray(props.gutter) ? props.gutter[0] : props.gutter)}`;
      const marginBottom = `${getMargin(Array.isArray(props.gutter) ? props.gutter[1] : props.gutter)}`;
      if (isLast) {
        return props.wrap ? { marginBottom } : {};
      }
      if (props.direction === "horizontal") {
        style.marginRight = marginRight;
      }
      if (props.direction === "vertical" || props.wrap) {
        style.marginBottom = marginBottom;
      }
      return style;
    };
    const filterEmpty = (children = []) => {
      const nodes = [];
      children.forEach((child) => {
        if (Array.isArray(child)) {
          nodes.push(...child);
        } else if (child.type === Fragment) {
          nodes.push(...filterEmpty(child.children));
        } else {
          nodes.push(child);
        }
      });
      return nodes.filter(
        (c2) => {
          var _a;
          return !(c2 && (c2.type === Comment || c2.type === Fragment && ((_a = c2.children) == null ? void 0 : _a.length) === 0 || c2.type === Text && c2.children.trim() === ""));
        }
      );
    };
    const { direction, wrap, fill, justify, align } = props;
    return () => {
      var _a;
      const children = filterEmpty((_a = slots.default) == null ? void 0 : _a.call(slots));
      const renderChildren = () => {
        return children.map((child, i2) => {
          return h$2(
            "div",
            {
              class: `${componentName$6}-item`,
              style: getMarginStyle(i2 === children.length - 1)
            },
            child
          );
        });
      };
      return h$2(
        "div",
        {
          class: [
            componentName$6,
            direction && `${componentName$6}-${direction}`,
            align && `${componentName$6}-align-${align}`,
            justify && `${componentName$6}-justify-${justify}`,
            wrap && `${componentName$6}-wrap`,
            fill && `${componentName$6}-fill`
          ]
        },
        renderChildren()
      );
    };
  }
});
var __defProp$13 = Object.defineProperty;
var __defProps$_ = Object.defineProperties;
var __getOwnPropDescs$_ = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$$ = Object.getOwnPropertySymbols;
var __hasOwnProp$$ = Object.prototype.hasOwnProperty;
var __propIsEnum$$ = Object.prototype.propertyIsEnumerable;
var __defNormalProp$13 = (obj, key, value) => key in obj ? __defProp$13(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$$ = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$$.call(b, prop))
      __defNormalProp$13(a2, prop, b[prop]);
  if (__getOwnPropSymbols$$)
    for (var prop of __getOwnPropSymbols$$(b)) {
      if (__propIsEnum$$.call(b, prop))
        __defNormalProp$13(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$_ = (a2, b) => __defProps$_(a2, __getOwnPropDescs$_(b));
const _hoisted_1$15 = {
  key: 1,
  class: "nut-navbar__text"
};
const _hoisted_2$W = { class: "nut-navbar__title" };
const _hoisted_3$L = {
  key: 0,
  class: "nut-navbar__text"
};
const _sfc_main$1r = /* @__PURE__ */ defineComponent(__spreadProps$_(__spreadValues$$({}, {
  name: "NutNavbar"
}), {
  __name: "navbar",
  props: {
    leftShow: { type: Boolean, default: false },
    title: { default: "" },
    titleIcon: { type: Boolean, default: false },
    leftText: { default: "" },
    desc: { default: "" },
    fixed: { type: Boolean, default: false },
    safeAreaInsetTop: { type: Boolean, default: false },
    border: { type: Boolean, default: false },
    placeholder: { type: Boolean, default: true },
    zIndex: { default: 10 }
  },
  emits: [
    "clickBack",
    "clickTitle",
    "clickIcon",
    "clickRight",
    // will be deprecated
    "onClickBack",
    "onClickTitle",
    "onClickIcon",
    "onClickRight"
  ],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const navHeight = ref("auto");
    const navbarRef = ref();
    const classes = computed(() => {
      const prefixCls2 = "nut-navbar";
      return {
        [prefixCls2]: true,
        [`${prefixCls2}--border`]: props.border,
        [`${prefixCls2}--fixed`]: props.fixed,
        [`${prefixCls2}--safe-area-inset-top`]: props.safeAreaInsetTop
      };
    });
    const rootStyle = computed(() => {
      if (props.fixed && props.placeholder) {
        return {
          height: navHeight.value
        };
      }
      return {};
    });
    const getNavHeight = () => {
      if (navbarRef.value) {
        const rect = navbarRef.value.getBoundingClientRect();
        navHeight.value = `${rect.height}px`;
      }
    };
    onMounted(() => {
      if (props.fixed && props.placeholder) {
        nextTick(() => {
          getNavHeight();
        });
      }
    });
    const handleLeft = () => {
      emit2("clickBack");
      emit2("onClickBack");
    };
    const handleCenter = () => {
      emit2("clickTitle");
      emit2("onClickTitle");
    };
    const handleCenterIcon = () => {
      emit2("clickIcon");
      emit2("onClickIcon");
    };
    const handleRight = () => {
      emit2("clickRight");
      emit2("onClickRight");
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("view", {
        class: "nut-navbar--placeholder",
        style: normalizeStyle(rootStyle.value)
      }, [
        createBaseVNode("view", {
          ref_key: "navbarRef",
          ref: navbarRef,
          class: normalizeClass(classes.value),
          style: normalizeStyle({ zIndex: _ctx.zIndex })
        }, [
          createBaseVNode("view", {
            class: "nut-navbar__left",
            onClick: handleLeft
          }, [
            _ctx.leftShow ? renderSlot(_ctx.$slots, "left-show", { key: 0 }, () => [
              createVNode(unref(v$7), {
                height: "12px",
                color: "#979797"
              })
            ]) : createCommentVNode("", true),
            _ctx.leftText ? (openBlock(), createElementBlock("view", _hoisted_1$15, toDisplayString(_ctx.leftText), 1)) : createCommentVNode("", true),
            renderSlot(_ctx.$slots, "left")
          ]),
          createBaseVNode("view", _hoisted_2$W, [
            _ctx.title ? (openBlock(), createElementBlock("view", {
              key: 0,
              class: "title",
              onClick: handleCenter
            }, toDisplayString(_ctx.title), 1)) : createCommentVNode("", true),
            _ctx.titleIcon ? (openBlock(), createElementBlock("view", {
              key: 1,
              class: "icon",
              onClick: handleCenterIcon
            }, [
              renderSlot(_ctx.$slots, "title-icon", { onClick: handleCenterIcon })
            ])) : createCommentVNode("", true),
            renderSlot(_ctx.$slots, "content")
          ]),
          createBaseVNode("view", {
            class: "nut-navbar__right",
            onClick: handleRight
          }, [
            _ctx.desc ? (openBlock(), createElementBlock("view", _hoisted_3$L, toDisplayString(_ctx.desc), 1)) : createCommentVNode("", true),
            renderSlot(_ctx.$slots, "right")
          ])
        ], 6)
      ], 4);
    };
  }
}));
withInstall(_sfc_main$1r);
class BaseLang {
}
var __defProp$12 = Object.defineProperty;
var __defNormalProp$12 = (obj, key, value) => key in obj ? __defProp$12(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$5 = (obj, key, value) => __defNormalProp$12(obj, typeof key !== "symbol" ? key + "" : key, value);
let Lang$1 = class Lang extends BaseLang {
  constructor() {
    super(...arguments);
    __publicField$5(this, "save", "保存");
    __publicField$5(this, "confirm", "确认");
    __publicField$5(this, "cancel", "取消");
    __publicField$5(this, "done", "完成");
    __publicField$5(this, "noData", "暂无数据");
    __publicField$5(this, "placeholder", "请输入");
    __publicField$5(this, "select", "请选择");
    __publicField$5(this, "video", {
      errorTip: "视频加载失败",
      clickRetry: "点击重试"
    });
    __publicField$5(this, "fixednav", {
      activeText: "收起导航",
      unActiveText: "快速导航"
    });
    __publicField$5(this, "pagination", {
      prev: "上一页",
      next: "下一页"
    });
    __publicField$5(this, "calendaritem", {
      weekdays: ["日", "一", "二", "三", "四", "五", "六"],
      end: "结束",
      start: "开始",
      title: "日期选择",
      monthTitle: (year, month) => `${year}年${month}月`,
      today: "今天"
    });
    __publicField$5(this, "calendarcard", {
      weekdays: ["日", "一", "二", "三", "四", "五", "六"],
      end: "结束",
      start: "开始",
      title: "日期选择",
      monthTitle: (year, month) => `${year}年${month}月`,
      today: "今天"
    });
    __publicField$5(this, "shortpassword", {
      title: "请输入密码",
      desc: "您使用了虚拟资产，请进行验证",
      tips: "忘记密码"
    });
    __publicField$5(this, "uploader", {
      ready: "准备完成",
      readyUpload: "准备上传",
      waitingUpload: "等待上传",
      uploading: "上传中",
      success: "上传成功",
      error: "上传失败"
    });
    __publicField$5(this, "countdown", {
      day: "天",
      hour: "时",
      minute: "分",
      second: "秒"
    });
    __publicField$5(this, "address", {
      selectRegion: "请选择所在地区",
      deliveryTo: "配送至",
      chooseAnotherAddress: "选择其他地址"
    });
    __publicField$5(this, "signature", {
      reSign: "重签",
      unSupportTpl: "对不起，当前浏览器不支持Canvas，无法使用本控件！"
    });
    __publicField$5(this, "ecard", {
      chooseText: "请选择电子卡面值",
      otherValueText: "其他面值",
      placeholder: "请输入1-5000整数"
    });
    __publicField$5(this, "timeselect", {
      pickupTime: "取件时间"
    });
    __publicField$5(this, "sku", {
      buyNow: "立即购买",
      buyNumber: "购买数量",
      addToCart: "加入购物车"
    });
    __publicField$5(this, "skuheader", {
      skuId: "商品编号"
    });
    __publicField$5(this, "addresslist", {
      addAddress: "新建地址",
      default: "默认"
    });
    __publicField$5(this, "comment", {
      complaintsText: "我要投诉",
      additionalReview: (day) => `购买${day}天后追评`,
      additionalImages: (length) => `${length}张追评图片`
    });
    __publicField$5(this, "infiniteloading", {
      loading: "加载中...",
      pullTxt: "松开刷新",
      loadMoreTxt: "哎呀，这里是底部了啦"
    });
    __publicField$5(this, "datepicker", {
      year: "年",
      month: "月",
      day: "日",
      hour: "时",
      min: "分",
      seconds: "秒"
    });
    __publicField$5(this, "audiooperate", {
      back: "倒退",
      start: "开始",
      pause: "暂停",
      forward: "快进",
      mute: "静音"
    });
    __publicField$5(this, "pullrefresh", {
      pulling: "下拉刷新",
      loosing: "释放刷新",
      loading: "加载中...",
      complete: "刷新成功"
    });
  }
};
var __defProp$11 = Object.defineProperty;
var __defNormalProp$11 = (obj, key, value) => key in obj ? __defProp$11(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$4 = (obj, key, value) => __defNormalProp$11(obj, typeof key !== "symbol" ? key + "" : key, value);
class Lang2 extends BaseLang {
  constructor() {
    super(...arguments);
    __publicField$4(this, "save", "Save");
    __publicField$4(this, "confirm", "Confirm");
    __publicField$4(this, "cancel", "Cancel");
    __publicField$4(this, "done", "Done");
    __publicField$4(this, "noData", "No Data");
    __publicField$4(this, "placeholder", "Placeholder");
    __publicField$4(this, "select", "Select");
    __publicField$4(this, "video", {
      errorTip: "Error Tip",
      clickRetry: "Click Retry"
    });
    __publicField$4(this, "fixednav", {
      activeText: "Close Nav",
      unActiveText: "Open Nav"
    });
    __publicField$4(this, "pagination", {
      prev: "Previous",
      next: "Next"
    });
    __publicField$4(this, "calendaritem", {
      weekdays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      end: "End",
      start: "Start",
      title: "Calendar",
      monthTitle: (year, month) => `${year}/${month}`,
      today: "Today"
    });
    __publicField$4(this, "calendarcard", {
      weekdays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      end: "End",
      start: "Start",
      title: "Calendar",
      monthTitle: (year, month) => `${year}/${month}`,
      today: "Today"
    });
    __publicField$4(this, "shortpassword", {
      title: "Please input a password",
      desc: "Verify",
      tips: "Forget password"
    });
    __publicField$4(this, "uploader", {
      ready: "Ready",
      readyUpload: "Ready to upload",
      waitingUpload: "Waiting for upload",
      uploading: "Uploading",
      success: "Upload successful",
      error: "Upload failed"
    });
    __publicField$4(this, "countdown", {
      day: " Day ",
      hour: " Hour ",
      minute: " Minute ",
      second: " Second "
    });
    __publicField$4(this, "address", {
      selectRegion: "Select Region",
      deliveryTo: "Delivery To",
      chooseAnotherAddress: "Choose Another Address"
    });
    __publicField$4(this, "signature", {
      reSign: "Re Sign",
      unSupportTpl: `Sorry, the current browser doesn't support canvas, so we can't use this control!`
    });
    __publicField$4(this, "ecard", {
      chooseText: "Select",
      otherValueText: "Other Value",
      placeholder: "Placeholder"
    });
    __publicField$4(this, "timeselect", {
      pickupTime: "Pickup Time"
    });
    __publicField$4(this, "sku", {
      buyNow: "Buy Now",
      buyNumber: "Buy Number",
      addToCart: "Add to Cart"
    });
    __publicField$4(this, "skuheader", {
      skuId: "Sku Number"
    });
    __publicField$4(this, "addresslist", {
      addAddress: "Add New Address",
      default: "default"
    });
    __publicField$4(this, "comment", {
      complaintsText: "I have a complaint",
      additionalReview: (day) => `Review after ${day} days of purchase`,
      additionalImages: (length) => `There are ${length} follow-up comments`
    });
    __publicField$4(this, "infiniteloading", {
      loading: "Loading...",
      pullTxt: "Loose to refresh",
      loadMoreTxt: "Oops, this is the bottom"
    });
    __publicField$4(this, "datepicker", {
      year: "Year",
      month: "Month",
      day: "Day",
      hour: "Hour",
      min: "Minute",
      seconds: "Second"
    });
    __publicField$4(this, "audiooperate", {
      back: "Back",
      start: "Start",
      pause: "Pause",
      forward: "Forward",
      mute: "Mute"
    });
    __publicField$4(this, "pullrefresh", {
      pulling: "Pull to refresh...",
      loosing: "Loose to refresh...",
      loading: "Loading...",
      complete: "Refresh successfully"
    });
  }
}
var __defProp$10 = Object.defineProperty;
var __defNormalProp$10 = (obj, key, value) => key in obj ? __defProp$10(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$3 = (obj, key, value) => __defNormalProp$10(obj, key + "", value);
const isObject = (val) => val !== null && typeof val === "object";
const deepMerge = (target, newObj) => {
  Object.keys(newObj).forEach((key) => {
    const targetValue = target[key];
    const newObjValue = newObj[key];
    if (isObject(targetValue) && isObject(newObjValue)) {
      deepMerge(targetValue, newObjValue);
    } else {
      target[key] = newObjValue;
    }
  });
  return target;
};
const langs = reactive({
  "zh-CN": new Lang$1(),
  "en-US": new Lang2()
});
class Locale {
  static languages() {
    return langs[this.currentLang.value];
  }
  static use(lang, newLanguages) {
    if (newLanguages) {
      langs[lang] = new newLanguages();
    }
    this.currentLang.value = lang;
  }
  static merge(lang, newLanguages) {
    if (newLanguages) {
      if (langs[lang]) {
        deepMerge(langs[lang], newLanguages);
      } else {
        this.use(lang, newLanguages);
      }
    }
  }
}
__publicField$3(Locale, "currentLang", ref("zh-CN"));
const useLocale = (name = "") => {
  return (keyPath, ...args) => {
    name = name.toLocaleLowerCase();
    const languages = Locale.languages();
    let text = keyPath;
    if (name && name.startsWith("nut")) {
      text = `${name.slice(3)}.${keyPath}`;
    }
    const res = getPropByPath(languages, text) || getPropByPath(languages, keyPath);
    return isFunction(res) ? res(...args) : res;
  };
};
const { create: create$X } = createComponent("fixed-nav");
const cN$o = "NutFixedNav";
const _sfc_main$1q = create$X({
  components: {
    NutOverlay: _sfc_main$1D,
    Left: v$7
  },
  props: {
    visible: {
      type: Boolean,
      default: false
    },
    overlay: {
      type: Boolean,
      default: true
    },
    navList: {
      default: () => [],
      type: Array
    },
    activeColor: {
      default: "",
      type: String
    },
    activeText: {
      default: "",
      type: String
    },
    unActiveText: {
      default: "",
      type: String
    },
    position: {
      default: () => {
        return {
          top: "auto",
          bottom: "auto"
        };
      },
      type: Object
    },
    type: {
      default: "right",
      type: String
    }
  },
  emits: ["update:visible", "selected"],
  setup(props, { emit: emit2 }) {
    const translate = useLocale(cN$o);
    const classes = computed(() => {
      const prefixCls2 = "nut-fixed-nav";
      return {
        [prefixCls2]: true,
        active: props.visible,
        [props.type]: true
      };
    });
    const current = ref(-1);
    const updateValue = (value = !props.visible) => {
      emit2("update:visible", value);
    };
    const selected = (item, event) => {
      emit2("selected", {
        item,
        event
      });
      current.value = item.id;
    };
    return { classes, updateValue, selected, translate, current };
  }
});
const _hoisted_1$14 = { class: "nut-fixed-nav__list" };
const _hoisted_2$V = ["onClick"];
const _hoisted_3$K = ["src"];
const _hoisted_4$C = { class: "span" };
const _hoisted_5$s = {
  key: 0,
  class: "b"
};
const _hoisted_6$p = { class: "text" };
function _sfc_render$V(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_overlay = resolveComponent("nut-overlay");
  const _component_Left = resolveComponent("Left");
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes),
    style: normalizeStyle(_ctx.position)
  }, [
    _ctx.overlay ? (openBlock(), createBlock(_component_nut_overlay, {
      key: 0,
      visible: _ctx.visible,
      "z-index": 200,
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.updateValue(false))
    }, null, 8, ["visible"])) : createCommentVNode("", true),
    renderSlot(_ctx.$slots, "list", {}, () => [
      createBaseVNode("view", _hoisted_1$14, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.navList, (item, index2) => {
          return openBlock(), createElementBlock("view", {
            key: item.id || index2,
            class: normalizeClass(["nut-fixed-nav__list-item", { active: item.id == _ctx.current }]),
            onClick: ($event) => _ctx.selected(item, $event)
          }, [
            createBaseVNode("img", {
              src: item.icon
            }, null, 8, _hoisted_3$K),
            createBaseVNode("view", _hoisted_4$C, toDisplayString(item.text), 1),
            item.num ? (openBlock(), createElementBlock("view", _hoisted_5$s, toDisplayString(item.num), 1)) : createCommentVNode("", true)
          ], 10, _hoisted_2$V);
        }), 128))
      ])
    ]),
    createBaseVNode("div", {
      class: "nut-fixed-nav__btn",
      onClick: _cache[1] || (_cache[1] = ($event) => _ctx.updateValue())
    }, [
      renderSlot(_ctx.$slots, "btn", {}, () => [
        createVNode(_component_Left, { color: "#fff" }),
        createBaseVNode("view", _hoisted_6$p, toDisplayString(_ctx.visible ? _ctx.activeText || _ctx.translate("activeText") : _ctx.unActiveText || _ctx.translate("unActiveText")), 1)
      ])
    ])
  ], 6);
}
const index$E = /* @__PURE__ */ _export_sfc(_sfc_main$1q, [["render", _sfc_render$V]]);
const MENU_KEY = Symbol("nut-menu");
const { componentName: componentName$5, create: create$W } = createComponent("menu");
const _sfc_main$1p = create$W({
  components: {
    RectUp: v$3,
    RectDown: v$4
  },
  props: {
    activeColor: {
      type: String,
      default: ""
    },
    overlay: {
      type: Boolean,
      default: true
    },
    lockScroll: {
      type: Boolean,
      default: true
    },
    duration: {
      type: [Number, String],
      default: 0.3
    },
    closeOnClickOverlay: {
      type: Boolean,
      default: true
    },
    direction: {
      type: String,
      default: "down"
    },
    scrollFixed: {
      type: [Boolean, String, Number],
      default: false
    },
    titleClass: {
      type: String,
      default: ""
    }
  },
  setup(props) {
    const barRef = ref();
    const offset = ref(0);
    const isScrollFixed = ref(false);
    const { children, linkChildren } = useChildren(MENU_KEY);
    const opened = computed(() => children.some((item) => item.state.showWrapper));
    const classes = computed(() => {
      const prefixCls2 = componentName$5;
      return {
        [prefixCls2]: true,
        "scroll-fixed": isScrollFixed.value
      };
    });
    const updateOffset = () => {
      if (barRef.value) {
        const rect = useRect(barRef);
        if (props.direction === "down") {
          offset.value = rect.bottom;
        } else {
          offset.value = window.innerHeight - rect.top;
        }
      }
    };
    linkChildren({ props, offset });
    const toggleItem = (active) => {
      children.forEach((item, index2) => {
        if (index2 === active) {
          updateOffset();
          item.toggle();
        } else if (item.state.showPopup) {
          item.toggle(false, { immediate: true });
        }
      });
    };
    const getScrollTop = (el) => {
      return Math.max(0, "scrollTop" in el ? el.scrollTop : el.pageYOffset);
    };
    const onScroll = () => {
      const { scrollFixed } = props;
      const scrollTop = getScrollTop(window);
      isScrollFixed.value = scrollTop > (typeof scrollFixed === "boolean" ? 30 : Number(scrollFixed));
    };
    const getClasses = (showPopup) => {
      let str = "";
      const { titleClass } = props;
      if (showPopup) {
        str += "active";
      }
      if (titleClass) {
        str += ` ${titleClass}`;
      }
      return str;
    };
    onMounted(() => {
      const { scrollFixed } = props;
      if (scrollFixed) {
        window.addEventListener("scroll", onScroll);
      }
    });
    onUnmounted(() => {
      const { scrollFixed } = props;
      if (scrollFixed) {
        window.removeEventListener("scroll", onScroll);
      }
    });
    return {
      toggleItem,
      children,
      opened,
      classes,
      barRef,
      getClasses
    };
  }
});
const _hoisted_1$13 = ["onClick"];
const _hoisted_2$U = { class: "nut-menu__title-text" };
const _hoisted_3$J = { class: "nut-menu__title-icon" };
function _sfc_render$U(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_RectUp = resolveComponent("RectUp");
  const _component_RectDown = resolveComponent("RectDown");
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes)
  }, [
    createBaseVNode("view", {
      ref: "barRef",
      class: normalizeClass(["nut-menu__bar", { opened: _ctx.opened }])
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.children, (item, index2) => {
        return openBlock(), createElementBlock("view", {
          key: index2,
          class: normalizeClass(["nut-menu__item", { disabled: item.disabled, active: item.state.showPopup }]),
          style: normalizeStyle({ color: item.state.showPopup ? _ctx.activeColor : "" }),
          onClick: ($event) => !item.disabled && _ctx.toggleItem(index2)
        }, [
          createBaseVNode("view", {
            class: normalizeClass(["nut-menu__title", _ctx.getClasses(item.state.showPopup)])
          }, [
            createBaseVNode("view", _hoisted_2$U, toDisplayString(item.renderTitle()), 1),
            createBaseVNode("span", _hoisted_3$J, [
              renderSlot(_ctx.$slots, "icon", {}, () => [
                _ctx.direction === "up" ? (openBlock(), createBlock(_component_RectUp, { key: 0 })) : (openBlock(), createBlock(_component_RectDown, { key: 1 }))
              ])
            ])
          ], 2)
        ], 14, _hoisted_1$13);
      }), 128))
    ], 2),
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
const index$D = /* @__PURE__ */ _export_sfc(_sfc_main$1p, [["render", _sfc_render$U]]);
var __defProp$$ = Object.defineProperty;
var __defProps$Z = Object.defineProperties;
var __getOwnPropDescs$Z = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$_ = Object.getOwnPropertySymbols;
var __hasOwnProp$_ = Object.prototype.hasOwnProperty;
var __propIsEnum$_ = Object.prototype.propertyIsEnumerable;
var __defNormalProp$$ = (obj, key, value) => key in obj ? __defProp$$(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$_ = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$_.call(b, prop))
      __defNormalProp$$(a2, prop, b[prop]);
  if (__getOwnPropSymbols$_)
    for (var prop of __getOwnPropSymbols$_(b)) {
      if (__propIsEnum$_.call(b, prop))
        __defNormalProp$$(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$Z = (a2, b) => __defProps$Z(a2, __getOwnPropDescs$Z(b));
const { create: create$V } = createComponent("menu-item");
const _sfc_main$1o = create$V({
  props: {
    title: String,
    options: {
      type: Array,
      default: []
    },
    disabled: {
      type: Boolean,
      default: false
    },
    modelValue: null,
    cols: {
      type: Number,
      default: 1
    },
    activeTitleClass: String,
    inactiveTitleClass: String
  },
  components: {
    NutPopup,
    Check: g$6
  },
  emits: ["update:modelValue", "change", "open", "close"],
  setup(props, { emit: emit2 }) {
    const state = reactive({
      showPopup: false,
      showWrapper: false
    });
    const { parent } = useParent(MENU_KEY);
    const style = computed(() => {
      return parent.props.direction === "down" ? {
        top: parent.offset.value + "px"
      } : {
        bottom: parent.offset.value + "px"
      };
    });
    const placeholderElementStyle = computed(() => {
      const heightStyle = { height: parent.offset.value + "px" };
      if (parent.props.direction === "down") {
        return __spreadProps$Z(__spreadValues$_({}, heightStyle), { top: "0px" });
      } else {
        return __spreadProps$Z(__spreadValues$_({}, heightStyle), { bottom: "0px" });
      }
    });
    const toggle = (show = !state.showPopup) => {
      if (show === state.showPopup) {
        return;
      }
      state.showPopup = show;
      if (show) {
        state.showWrapper = true;
        emit2("open");
      }
    };
    const renderTitle = () => {
      var _a;
      if (props.title) {
        return props.title;
      }
      const match = (_a = props.options) == null ? void 0 : _a.find((option) => option.value === props.modelValue);
      return match ? match.text : "";
    };
    const onClick = (option) => {
      state.showPopup = false;
      if (option.value !== props.modelValue) {
        emit2("update:modelValue", option.value);
        emit2("change", option.value);
      }
    };
    const handleClose = () => {
      emit2("close");
      state.showWrapper = false;
    };
    const handleClickOutside = () => {
      state.showPopup = false;
      emit2("close");
    };
    return {
      style,
      placeholderElementStyle,
      renderTitle,
      state,
      parent,
      toggle,
      onClick,
      handleClose,
      handleClickOutside
    };
  }
});
const _hoisted_1$12 = { class: "nut-menu-item__content nut-menu-item__overflow" };
const _hoisted_2$T = ["onClick"];
function _sfc_render$T(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Check = resolveComponent("Check");
  const _component_nut_popup = resolveComponent("nut-popup");
  return withDirectives((openBlock(), createElementBlock("view", {
    class: "nut-menu-item",
    style: normalizeStyle(_ctx.style)
  }, [
    withDirectives(createBaseVNode("div", {
      class: "nut-menu-item-placeholder-element",
      style: normalizeStyle(_ctx.placeholderElementStyle),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClickOutside && _ctx.handleClickOutside(...args))
    }, null, 4), [
      [vShow, _ctx.state.showPopup]
    ]),
    createVNode(_component_nut_popup, mergeProps(_ctx.$attrs, {
      visible: _ctx.state.showPopup,
      "onUpdate:visible": _cache[1] || (_cache[1] = ($event) => _ctx.state.showPopup = $event),
      style: { position: "absolute" },
      "overlay-style": { position: "absolute" },
      position: _ctx.parent.props.direction === "down" ? "top" : "bottom",
      duration: _ctx.parent.props.duration,
      "destroy-on-close": false,
      overlay: _ctx.parent.props.overlay,
      "lock-scroll": _ctx.parent.props.lockScroll,
      "teleport-disable": false,
      "close-on-click-overlay": _ctx.parent.props.closeOnClickOverlay,
      onClosed: _ctx.handleClose
    }), {
      default: withCtx(() => [
        createBaseVNode("view", _hoisted_1$12, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.options, (option, index2) => {
            return openBlock(), createElementBlock("view", {
              key: index2,
              class: normalizeClass(["nut-menu-item__option", [{ active: option.value === _ctx.modelValue }]]),
              style: normalizeStyle({ "flex-basis": 100 / _ctx.cols + "%" }),
              onClick: ($event) => _ctx.onClick(option)
            }, [
              option.value === _ctx.modelValue ? (openBlock(), createElementBlock("span", {
                key: 0,
                class: normalizeClass(["nut-menu-item__span", [option.value === _ctx.modelValue ? _ctx.activeTitleClass : _ctx.inactiveTitleClass]])
              }, [
                renderSlot(_ctx.$slots, "icon", {}, () => [
                  createVNode(_component_Check, mergeProps({ ref_for: true }, _ctx.$attrs, {
                    color: _ctx.parent.props.activeColor
                  }), null, 16, ["color"])
                ])
              ], 2)) : createCommentVNode("", true),
              createBaseVNode("view", {
                class: normalizeClass([option.value === _ctx.modelValue ? _ctx.activeTitleClass : _ctx.inactiveTitleClass]),
                style: normalizeStyle({ color: option.value === _ctx.modelValue ? _ctx.parent.props.activeColor : "" })
              }, toDisplayString(option.text), 7)
            ], 14, _hoisted_2$T);
          }), 128)),
          renderSlot(_ctx.$slots, "default")
        ])
      ]),
      _: 3
    }, 16, ["visible", "position", "duration", "overlay", "lock-scroll", "close-on-click-overlay", "onClosed"])
  ], 4)), [
    [vShow, _ctx.state.showWrapper]
  ]);
}
const index$C = /* @__PURE__ */ _export_sfc(_sfc_main$1o, [["render", _sfc_render$T]]);
const TABBAR_KEY = Symbol("nut-tabbar");
var __defProp$_ = Object.defineProperty;
var __defProps$Y = Object.defineProperties;
var __getOwnPropDescs$Y = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$Z = Object.getOwnPropertySymbols;
var __hasOwnProp$Z = Object.prototype.hasOwnProperty;
var __propIsEnum$Z = Object.prototype.propertyIsEnumerable;
var __defNormalProp$_ = (obj, key, value) => key in obj ? __defProp$_(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$Z = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$Z.call(b, prop))
      __defNormalProp$_(a2, prop, b[prop]);
  if (__getOwnPropSymbols$Z)
    for (var prop of __getOwnPropSymbols$Z(b)) {
      if (__propIsEnum$Z.call(b, prop))
        __defNormalProp$_(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$Y = (a2, b) => __defProps$Y(a2, __getOwnPropDescs$Y(b));
var __async$5 = (__this, __arguments, generator) => {
  return new Promise((resolve2, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve2(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const _sfc_main$1n = /* @__PURE__ */ defineComponent(__spreadProps$Y(__spreadValues$Z({}, {
  name: "NutTabbar"
}), {
  __name: "tabbar",
  props: {
    modelValue: { default: 0 },
    bottom: { type: Boolean, default: false },
    unactiveColor: { default: "" },
    activeColor: { default: "" },
    safeAreaInsetBottom: { type: Boolean, default: false },
    placeholder: { type: Boolean, default: false },
    beforeSwitch: { type: Function, default: () => true }
  },
  emits: ["tabSwitch", "update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const height = ref();
    const nutTabbar = ref(null);
    const activeIndex = ref(props.modelValue);
    const classes = computed(() => {
      const prefixCls2 = "nut-tabbar";
      return {
        [prefixCls2]: true,
        "nut-tabbar-bottom": props.bottom,
        "nut-tabbar-safebottom": props.safeAreaInsetBottom
      };
    });
    const { children, linkChildren } = useChildren(TABBAR_KEY);
    const changeIndex = (index2, active) => __async$5(this, null, function* () {
      const res = yield props.beforeSwitch(children[index2], active);
      if (res === false) {
        return Promise.reject();
      }
      activeIndex.value = active;
      emit2("update:modelValue", active);
      emit2("tabSwitch", children[index2], active);
    });
    linkChildren({ props, activeIndex, changeIndex });
    watch(
      () => props.modelValue,
      (val) => {
        activeIndex.value = val;
      }
    );
    const updateHeight = () => {
      if (props.bottom && props.placeholder) {
        nextTick(() => {
          var _a;
          const nutTabbarHeight = (_a = nutTabbar.value) == null ? void 0 : _a.getBoundingClientRect().height;
          if (nutTabbarHeight) {
            height.value = nutTabbarHeight;
          }
        });
      }
    };
    onMounted(updateHeight);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass({ "nut-tabbar__placeholder": _ctx.bottom && _ctx.placeholder }),
        style: normalizeStyle({ height: height.value + "px" })
      }, [
        createBaseVNode("view", {
          ref_key: "nutTabbar",
          ref: nutTabbar,
          class: normalizeClass(classes.value)
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 2)
      ], 6);
    };
  }
}));
withInstall(_sfc_main$1n);
const renderIcon = (icon, props) => {
  if (icon) return h$2(icon, props);
  return "";
};
var __defProp$Z = Object.defineProperty;
var __defProps$X = Object.defineProperties;
var __getOwnPropDescs$X = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$Y = Object.getOwnPropertySymbols;
var __hasOwnProp$Y = Object.prototype.hasOwnProperty;
var __propIsEnum$Y = Object.prototype.propertyIsEnumerable;
var __defNormalProp$Z = (obj, key, value) => key in obj ? __defProp$Z(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$Y = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$Y.call(b, prop))
      __defNormalProp$Z(a2, prop, b[prop]);
  if (__getOwnPropSymbols$Y)
    for (var prop of __getOwnPropSymbols$Y(b)) {
      if (__propIsEnum$Y.call(b, prop))
        __defNormalProp$Z(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$X = (a2, b) => __defProps$X(a2, __getOwnPropDescs$X(b));
const _hoisted_1$11 = { class: "nut-badge" };
const _sfc_main$1m = /* @__PURE__ */ defineComponent(__spreadProps$X(__spreadValues$Y({}, {
  name: "NutBadge"
}), {
  __name: "badge",
  props: {
    value: {},
    max: { default: 1e4 },
    dot: { type: Boolean, default: false },
    bubble: { type: Boolean, default: false },
    hidden: { type: Boolean, default: false },
    top: { default: "0" },
    right: { default: "0" },
    zIndex: { default: 9 },
    color: { default: "" }
  },
  setup(__props) {
    const props = __props;
    const style = computed(() => {
      return {
        top: `${props.top}px`,
        right: `${props.right}px`,
        zIndex: props.zIndex,
        background: props.color
      };
    });
    const content = computed(() => {
      if (props.dot) return;
      const value = props.value;
      const max = props.max;
      if (typeof value === "number" && typeof max === "number") {
        return max < value ? `${max}+` : value;
      }
      return value;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("view", _hoisted_1$11, [
        withDirectives(createBaseVNode("view", {
          class: "nut-badge__icon",
          style: normalizeStyle(style.value)
        }, [
          renderSlot(_ctx.$slots, "icon")
        ], 4), [
          [vShow, !_ctx.hidden && !_ctx.dot && _ctx.$slots.icon]
        ]),
        renderSlot(_ctx.$slots, "default"),
        withDirectives(createBaseVNode("view", {
          class: normalizeClass(["nut-badge__content nut-badge__content--sup", { "nut-badge__content--dot": _ctx.dot, "nut-badge__content--bubble": !_ctx.dot && _ctx.bubble }]),
          style: normalizeStyle(style.value)
        }, toDisplayString(content.value), 7), [
          [vShow, !_ctx.hidden && (content.value || _ctx.dot)]
        ])
      ]);
    };
  }
}));
withInstall(_sfc_main$1m);
var __defProp$Y = Object.defineProperty;
var __defProps$W = Object.defineProperties;
var __getOwnPropDescs$W = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$X = Object.getOwnPropertySymbols;
var __hasOwnProp$X = Object.prototype.hasOwnProperty;
var __propIsEnum$X = Object.prototype.propertyIsEnumerable;
var __defNormalProp$Y = (obj, key, value) => key in obj ? __defProp$Y(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$X = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$X.call(b, prop))
      __defNormalProp$Y(a2, prop, b[prop]);
  if (__getOwnPropSymbols$X)
    for (var prop of __getOwnPropSymbols$X(b)) {
      if (__propIsEnum$X.call(b, prop))
        __defNormalProp$Y(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$W = (a2, b) => __defProps$W(a2, __getOwnPropDescs$W(b));
var __async$4 = (__this, __arguments, generator) => {
  return new Promise((resolve2, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve2(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const _hoisted_1$10 = { class: "nut-tabbar-item_icon-box" };
const _hoisted_2$S = {
  key: 0,
  class: "nut-tabbar-item_icon-box_icon"
};
const _hoisted_3$I = { key: 1 };
const _hoisted_4$B = { key: 0 };
const _sfc_main$1l = /* @__PURE__ */ defineComponent(__spreadProps$W(__spreadValues$X({}, {
  name: "NutTabbarItem"
}), {
  __name: "tabbar-item",
  props: {
    tabTitle: { default: "" },
    name: {},
    icon: {},
    href: { default: "" },
    to: {}
  },
  setup(__props) {
    const props = __props;
    const router = useRouter();
    const { parent, index: index2 } = useParent(TABBAR_KEY);
    const active = computed(() => {
      var _a;
      return ((_a = props.name) != null ? _a : index2.value) === parent.activeIndex.value;
    });
    const activeColor = computed(() => active.value ? parent.props.activeColor : parent.props.unactiveColor);
    const change = () => __async$4(this, null, function* () {
      var _a, _b, _c;
      try {
        const key = (_a = props.name) != null ? _a : index2.value;
        yield parent.changeIndex(index2.value, key);
        if ((_b = parent.children[index2.value]) == null ? void 0 : _b.href) {
          window.location.href = parent.children[index2.value].href;
          return;
        }
        if ((_c = parent.children[index2.value]) == null ? void 0 : _c.to) {
          const to = parent.children[index2.value].to;
          if (to && router) {
            router.push(to);
          } else {
            location.replace(to);
          }
        }
      } catch (err) {
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["nut-tabbar-item", { "nut-tabbar-item__icon--unactive": !active.value }]),
        style: normalizeStyle({
          color: activeColor.value
        }),
        onClick: change
      }, [
        createVNode(unref(_sfc_main$1m), normalizeProps(guardReactiveProps(_ctx.$attrs)), {
          default: withCtx(() => [
            createBaseVNode("view", _hoisted_1$10, [
              _ctx.$slots.icon ? (openBlock(), createElementBlock("div", _hoisted_2$S, [
                renderSlot(_ctx.$slots, "icon", { active: active.value })
              ])) : createCommentVNode("", true),
              _ctx.icon && !_ctx.$slots.icon ? (openBlock(), createElementBlock("view", _hoisted_3$I, [
                (openBlock(), createBlock(resolveDynamicComponent(unref(renderIcon)(_ctx.icon)), { class: "nut-popover-item-img" }))
              ])) : createCommentVNode("", true),
              createBaseVNode("view", {
                class: normalizeClass(["nut-tabbar-item_icon-box_nav-word", { "nut-tabbar-item_icon-box_big-word": !_ctx.icon && !_ctx.$slots.icon }])
              }, [
                renderSlot(_ctx.$slots, "default", {}, () => [
                  _ctx.tabTitle ? (openBlock(), createElementBlock("view", _hoisted_4$B, toDisplayString(_ctx.tabTitle), 1)) : createCommentVNode("", true)
                ])
              ], 2)
            ])
          ]),
          _: 3
        }, 16)
      ], 6);
    };
  }
}));
withInstall(_sfc_main$1l);
var __defProp$X = Object.defineProperty;
var __defProps$V = Object.defineProperties;
var __getOwnPropDescs$V = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$W = Object.getOwnPropertySymbols;
var __hasOwnProp$W = Object.prototype.hasOwnProperty;
var __propIsEnum$W = Object.prototype.propertyIsEnumerable;
var __defNormalProp$X = (obj, key, value) => key in obj ? __defProp$X(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$W = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$W.call(b, prop))
      __defNormalProp$X(a2, prop, b[prop]);
  if (__getOwnPropSymbols$W)
    for (var prop of __getOwnPropSymbols$W(b)) {
      if (__propIsEnum$W.call(b, prop))
        __defNormalProp$X(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$V = (a2, b) => __defProps$V(a2, __getOwnPropDescs$V(b));
const { create: create$U } = createComponent("elevator");
const _sfc_main$1k = create$U({
  props: {
    height: {
      type: [Number, String],
      default: "200px"
    },
    acceptKey: {
      type: [String],
      default: "title"
    },
    indexList: {
      type: Array,
      default: () => []
    },
    isSticky: {
      type: [Boolean],
      default: false
    },
    spaceHeight: {
      type: [Number],
      default: 23
    },
    titleHeight: {
      type: [Number],
      default: 35
    }
  },
  emits: ["clickItem", "clickIndex", "change"],
  setup(props, { emit: emit2, expose }) {
    const listview = ref(null);
    const state = reactive({
      anchorIndex: 0,
      codeIndex: 0,
      listHeight: [],
      listGroup: [],
      touchState: {
        y1: 0,
        y2: 0
      },
      scrollStart: false,
      currentIndex: 0,
      currentData: {},
      currentKey: "",
      scrollY: 0,
      diff: -1,
      fixedTop: 0
    });
    const clientHeight = computed(() => {
      return listview.value.clientHeight;
    });
    const getData = (el, name) => {
      const prefix2 = "data-";
      return el.getAttribute(prefix2 + name);
    };
    const setListGroup = (el) => {
      nextTick(() => {
        if (!state.listGroup.includes(el) && el != null) {
          state.listGroup.push(el);
        }
      });
    };
    const calculateHeight = () => {
      let height = 0;
      state.listHeight.push(height);
      for (let i2 = 0; i2 < state.listGroup.length; i2++) {
        let item = state.listGroup[i2];
        height += Math.floor(item.clientHeight);
        state.listHeight.push(height);
      }
    };
    const scrollTo = (index2) => {
      if (!index2 && index2 !== 0) {
        return;
      }
      if (index2 < 0) index2 = 0;
      if (index2 > state.listHeight.length - 2) index2 = state.listHeight.length - 2;
      state.codeIndex = index2;
      listview.value.scrollTo(0, state.listHeight[index2]);
    };
    const touchStart = (e) => {
      state.scrollStart = true;
      let index2 = getData(e.target, "index");
      let firstTouch = e.touches[0];
      state.touchState.y1 = firstTouch.pageY;
      state.anchorIndex = +index2;
      state.codeIndex = +index2;
      scrollTo(+index2);
    };
    const touchMove = (e) => {
      let firstTouch = e.touches[0];
      state.touchState.y2 = firstTouch.pageY;
      let delta = (state.touchState.y2 - state.touchState.y1) / props.spaceHeight | 0;
      state.codeIndex = state.anchorIndex + delta;
      scrollTo(state.codeIndex);
    };
    const touchEnd = () => {
      state.scrollStart = false;
    };
    const handleClickItem = (key, item) => {
      emit2("clickItem", key, item);
      state.currentData = item;
      state.currentKey = key;
    };
    const handleClickIndex = (key) => {
      emit2("clickIndex", key);
    };
    const listViewScroll = (e) => {
      let target = e.target;
      let scrollTop = target.scrollTop;
      const listHeight = state.listHeight;
      state.scrollY = scrollTop;
      for (let i2 = 0; i2 < listHeight.length - 1; i2++) {
        let height1 = listHeight[i2];
        let height2 = listHeight[i2 + 1];
        if (state.scrollY >= height1 && state.scrollY < height2) {
          state.currentIndex = i2;
          state.diff = height2 - state.scrollY;
          return;
        }
      }
      state.currentIndex = listHeight.length - 2;
    };
    onMounted(() => {
      if (listview.value) {
        listview.value.addEventListener("scroll", listViewScroll);
      }
    });
    expose({
      scrollTo
    });
    watch(
      () => state.listGroup.length,
      () => {
        state.listHeight = [];
        nextTick(calculateHeight);
      }
    );
    watch(
      () => state.diff,
      (newVal) => {
        const listHeight = state.listHeight;
        let fixedTop = newVal > 0 && newVal < props.titleHeight ? newVal - props.titleHeight : 0;
        if (state.scrollY + clientHeight.value === listHeight[listHeight.length - 1]) {
          if (fixedTop !== 0) fixedTop = 0;
        }
        if (state.fixedTop === fixedTop) return;
        state.fixedTop = fixedTop;
      }
    );
    watch(
      () => state.currentIndex,
      (newVal) => {
        emit2("change", newVal);
      }
    );
    return __spreadProps$V(__spreadValues$W({}, toRefs(state)), {
      clientHeight,
      setListGroup,
      listview,
      touchStart,
      touchMove,
      touchEnd,
      handleClickItem,
      handleClickIndex
    });
  }
});
const _hoisted_1$$ = { class: "nut-elevator" };
const _hoisted_2$R = { class: "nut-elevator__list__item__code" };
const _hoisted_3$H = ["onClick"];
const _hoisted_4$A = ["innerHTML"];
const _hoisted_5$r = { class: "nut-elevator__list__fixed" };
const _hoisted_6$o = { class: "nut-elevator__list__fixed-title" };
const _hoisted_7$k = { class: "nut-elevator__bars__inner" };
const _hoisted_8$e = ["data-index", "onClick"];
function _sfc_render$S(_ctx, _cache, $props, $setup, $data, $options) {
  var _a, _b;
  return openBlock(), createElementBlock("view", _hoisted_1$$, [
    createBaseVNode("view", {
      ref: "listview",
      class: "nut-elevator__list",
      style: normalizeStyle({ height: isNaN(+_ctx.height) ? _ctx.height : `${_ctx.height}px` })
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.indexList, (item) => {
        return openBlock(), createElementBlock("view", {
          key: item[_ctx.acceptKey],
          ref_for: true,
          ref: _ctx.setListGroup,
          class: "nut-elevator__list__item"
        }, [
          createBaseVNode("view", _hoisted_2$R, toDisplayString(item[_ctx.acceptKey]), 1),
          (openBlock(true), createElementBlock(Fragment, null, renderList(item.list, (subitem) => {
            return openBlock(), createElementBlock("view", {
              key: subitem["id"],
              class: normalizeClass(["nut-elevator__list__item__name", {
                "nut-elevator__list__item__name--highcolor": _ctx.currentData.id === subitem.id && _ctx.currentKey === item[_ctx.acceptKey]
              }]),
              onClick: ($event) => _ctx.handleClickItem(item[_ctx.acceptKey], subitem)
            }, [
              !_ctx.$slots.default ? (openBlock(), createElementBlock("span", {
                key: 0,
                innerHTML: subitem.name
              }, null, 8, _hoisted_4$A)) : renderSlot(_ctx.$slots, "default", {
                key: 1,
                item: subitem
              })
            ], 10, _hoisted_3$H);
          }), 128))
        ]);
      }), 128))
    ], 4),
    withDirectives(createBaseVNode("view", _hoisted_5$r, [
      createBaseVNode("view", _hoisted_6$o, toDisplayString((_b = (_a = _ctx.indexList) == null ? void 0 : _a[_ctx.currentIndex]) == null ? void 0 : _b[_ctx.acceptKey]), 1)
    ], 512), [
      [vShow, _ctx.scrollY > 0 && _ctx.isSticky]
    ]),
    _ctx.indexList.length ? withDirectives((openBlock(), createElementBlock("view", {
      key: 0,
      class: "nut-elevator__code--current"
    }, toDisplayString(_ctx.indexList[_ctx.codeIndex][_ctx.acceptKey]), 513)), [
      [vShow, _ctx.scrollStart]
    ]) : createCommentVNode("", true),
    createBaseVNode("view", {
      class: "nut-elevator__bars",
      onTouchstart: _cache[0] || (_cache[0] = (...args) => _ctx.touchStart && _ctx.touchStart(...args)),
      onTouchmove: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.touchMove && _ctx.touchMove(...args), ["stop", "prevent"])),
      onTouchend: _cache[2] || (_cache[2] = (...args) => _ctx.touchEnd && _ctx.touchEnd(...args))
    }, [
      createBaseVNode("view", _hoisted_7$k, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.indexList, (item, index2) => {
          return openBlock(), createElementBlock("view", {
            key: item[_ctx.acceptKey],
            class: normalizeClass(["nut-elevator__bars__inner__item", { active: item[_ctx.acceptKey] === _ctx.indexList[_ctx.currentIndex][_ctx.acceptKey] }]),
            "data-index": index2,
            onClick: ($event) => _ctx.handleClickIndex(item[_ctx.acceptKey])
          }, toDisplayString(item[_ctx.acceptKey]), 11, _hoisted_8$e);
        }), 128))
      ])
    ], 32)
  ]);
}
const NutElevator = /* @__PURE__ */ _export_sfc(_sfc_main$1k, [["render", _sfc_render$S]]);
const { create: create$T } = createComponent("pagination");
const cN$n = "NutPagination";
const _sfc_main$1j = create$T({
  props: {
    modelValue: {
      type: Number,
      default: 1
    },
    mode: {
      type: String,
      default: "multi"
    },
    prevText: {
      type: String,
      default: ""
    },
    nextText: {
      type: String,
      default: ""
    },
    pageCount: {
      type: [String, Number],
      default: ""
    },
    totalItems: {
      type: [String, Number],
      default: "0"
    },
    itemsPerPage: {
      type: [String, Number],
      default: "10"
    },
    showPageSize: {
      type: [String, Number],
      default: "5"
    },
    forceEllipses: {
      type: Boolean,
      default: false
    }
  },
  components: {},
  emits: ["change", "update:modelValue"],
  setup(props, { emit: emit2 }) {
    const translate = useLocale(cN$n);
    const { modelValue, mode, showPageSize, forceEllipses } = toRefs(props);
    const countRef = computed(() => {
      const { pageCount, totalItems, itemsPerPage } = toRefs(props);
      const num = +pageCount.value || Math.ceil(+totalItems.value / +itemsPerPage.value);
      return Math.max(1, num);
    });
    const select = (curPage, isSelect) => {
      if (curPage > countRef.value || curPage < 1) return;
      if (curPage != modelValue.value) emit2("update:modelValue", curPage);
      if (isSelect) emit2("change", curPage);
    };
    const setPage = (number, text, active = false) => {
      return { number, text, active };
    };
    const pages = computed(() => {
      if (mode.value == "simple") return;
      let items = [];
      const pageCount = countRef.value;
      const pageSize = +showPageSize.value;
      let startPage = 1;
      let endPage = pageCount;
      const partialShow = pageCount > pageSize;
      if (partialShow) {
        startPage = Math.max(modelValue.value - Math.floor(pageSize / 2), 1);
        endPage = startPage + +pageSize - 1;
        if (endPage > pageCount) {
          endPage = pageCount;
          startPage = endPage - +pageSize + 1;
        }
      }
      for (var i2 = startPage; i2 <= endPage; i2++) {
        const page = setPage(i2, i2, modelValue.value == i2);
        items.push(page);
      }
      if (partialShow && pageSize > 0 && forceEllipses.value) {
        if (startPage > 1) {
          const prevPage = setPage(startPage - 1, "...");
          items.unshift(prevPage);
        }
        if (endPage < pageCount) {
          const nextPage = setPage(endPage + 1, "...");
          items.push(nextPage);
        }
      }
      return items;
    });
    watchEffect(() => {
      select(modelValue.value, false);
    });
    return {
      modelValue,
      select,
      countRef,
      mode,
      pages,
      forceEllipses,
      translate
    };
  }
});
const _hoisted_1$_ = { class: "nut-pagination" };
const _hoisted_2$Q = {
  key: 0,
  class: "nut-pagination-contain"
};
const _hoisted_3$G = ["onClick"];
const _hoisted_4$z = {
  key: 1,
  class: "nut-pagination-contain"
};
const _hoisted_5$q = { class: "nut-pagination-simple" };
function _sfc_render$R(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", _hoisted_1$_, [
    createBaseVNode("view", {
      class: normalizeClass(["nut-pagination-prev", _ctx.mode == "multi" ? "" : "simple-border", _ctx.modelValue == 1 ? "disabled" : ""]),
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.select(_ctx.modelValue - 1, true))
    }, [
      renderSlot(_ctx.$slots, "prev-text", {}, () => [
        createTextVNode(toDisplayString(_ctx.prevText || _ctx.translate("prev")), 1)
      ])
    ], 2),
    _ctx.mode == "multi" ? (openBlock(), createElementBlock("view", _hoisted_2$Q, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.pages, (item, index2) => {
        return openBlock(), createElementBlock("view", {
          key: index2 + "pagination",
          class: normalizeClass(["nut-pagination-item", item.active ? "active" : ""]),
          onClick: ($event) => _ctx.select(item.number, true)
        }, [
          renderSlot(_ctx.$slots, "page", { item }, () => [
            createTextVNode(toDisplayString(item.text), 1)
          ])
        ], 10, _hoisted_3$G);
      }), 128))
    ])) : createCommentVNode("", true),
    _ctx.mode == "simple" ? (openBlock(), createElementBlock("view", _hoisted_4$z, [
      createBaseVNode("view", _hoisted_5$q, toDisplayString(_ctx.modelValue) + "/" + toDisplayString(_ctx.countRef), 1)
    ])) : createCommentVNode("", true),
    createBaseVNode("view", {
      class: normalizeClass(["nut-pagination-next", _ctx.modelValue >= _ctx.countRef ? "disabled" : ""]),
      onClick: _cache[1] || (_cache[1] = ($event) => _ctx.select(_ctx.modelValue + 1, true))
    }, [
      renderSlot(_ctx.$slots, "next-text", {}, () => [
        createTextVNode(toDisplayString(_ctx.nextText || _ctx.translate("next")), 1)
      ])
    ], 2)
  ]);
}
const index$B = /* @__PURE__ */ _export_sfc(_sfc_main$1j, [["render", _sfc_render$R]]);
const _window = window;
const inBrowser = typeof window !== "undefined";
function requestAniFrame() {
  if (typeof _window !== "undefined") {
    return _window.requestAnimationFrame || _window.webkitRequestAnimationFrame || function(callback) {
      _window.setTimeout(callback, 1e3 / 60);
    };
  } else {
    return function(callback) {
      setTimeout(callback, 1e3 / 60);
    };
  }
}
function cancelRaf(id) {
  if (inBrowser) {
    cancelAnimationFrame(id);
  } else {
    clearTimeout(id);
  }
}
const requestAniFrame$1 = requestAniFrame();
const MIN_DISTANCE = 10;
function getDirection(x, y2) {
  if (x > y2 && x > MIN_DISTANCE) {
    return "horizontal";
  }
  if (y2 > x && y2 > MIN_DISTANCE) {
    return "vertical";
  }
  return "";
}
function useTouch() {
  const startX = ref(0);
  const startY = ref(0);
  const moveX = ref(0);
  const moveY = ref(0);
  const deltaX = ref(0);
  const deltaY = ref(0);
  const offsetX = ref(0);
  const offsetY = ref(0);
  const direction = ref("");
  const isVertical = () => direction.value === "vertical";
  const isHorizontal = () => direction.value === "horizontal";
  const reset = () => {
    deltaX.value = 0;
    deltaY.value = 0;
    offsetX.value = 0;
    offsetY.value = 0;
    direction.value = "";
  };
  const start = (event) => {
    reset();
    startX.value = event.touches[0].clientX;
    startY.value = event.touches[0].clientY;
  };
  const move = (event) => {
    const touch = event.touches[0];
    deltaX.value = touch.clientX - startX.value;
    deltaY.value = touch.clientY - startY.value;
    moveX.value = touch.clientX;
    moveY.value = touch.clientY;
    offsetX.value = Math.abs(deltaX.value);
    offsetY.value = Math.abs(deltaY.value);
    if (!direction.value) {
      direction.value = getDirection(offsetX.value, offsetY.value);
    }
  };
  return {
    move,
    start,
    reset,
    startX,
    startY,
    moveX,
    moveY,
    deltaX,
    deltaY,
    offsetX,
    offsetY,
    direction,
    isVertical,
    isHorizontal
  };
}
const TABS_KEY = Symbol("nut-tab");
var __defProp$W = Object.defineProperty;
var __getOwnPropSymbols$V = Object.getOwnPropertySymbols;
var __hasOwnProp$V = Object.prototype.hasOwnProperty;
var __propIsEnum$V = Object.prototype.propertyIsEnumerable;
var __defNormalProp$W = (obj, key, value) => key in obj ? __defProp$W(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$V = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$V.call(b, prop))
      __defNormalProp$W(a2, prop, b[prop]);
  if (__getOwnPropSymbols$V)
    for (var prop of __getOwnPropSymbols$V(b)) {
      if (__propIsEnum$V.call(b, prop))
        __defNormalProp$W(a2, prop, b[prop]);
    }
  return a2;
};
var __publicField$2 = (obj, key, value) => __defNormalProp$W(obj, typeof key !== "symbol" ? key + "" : key, value);
var __async$3 = (__this, __arguments, generator) => {
  return new Promise((resolve2, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve2(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const useTabContentTouch = (props, tabMethods, taro, useTaroRect) => {
  const tabsContentRef = ref();
  const tabsContentRefRect = ref({ width: 0, height: 0 });
  const initTaroWidth = () => __async$3(void 0, null, function* () {
    var _a, _b;
    {
      tabsContentRefRect.value.width = ((_a = tabsContentRef.value) == null ? void 0 : _a.clientWidth) || 0;
      tabsContentRefRect.value.height = ((_b = tabsContentRef.value) == null ? void 0 : _b.clientHeight) || 0;
    }
  });
  onMounted(() => {
    setTimeout(() => {
      initTaroWidth();
    }, 100);
  });
  const touchState = reactive({
    offset: 0,
    moving: false
  });
  const touch = useTouch();
  let position = "";
  const setoffset = (deltaX, deltaY) => {
    var _a;
    let offset = deltaX;
    if (props.direction == "horizontal") {
      position = deltaX > 0 ? "right" : "left";
      offset = Math.abs(offset) / tabsContentRefRect.value.width * 100;
    } else {
      position = deltaY > 0 ? "bottom" : "top";
      offset = deltaY;
      offset = Math.abs(offset) / ((_a = tabsContentRefRect.value) == null ? void 0 : _a.height) * 100;
    }
    if (offset > 85) {
      offset = 85;
    }
    switch (position) {
      case "left":
      case "top":
        if (tabMethods.isEnd()) {
          offset = 0;
          touchState.moving = false;
        }
        break;
      case "right":
      case "bottom":
        offset = -offset;
        if (tabMethods.isBegin()) {
          offset = 0;
          touchState.moving = false;
        }
        break;
    }
    touchState.offset = offset;
  };
  const touchMethods = {
    onTouchStart(event) {
      if (!props.swipeable) return;
      touch.start(event);
    },
    onTouchMove(event) {
      if (!props.swipeable) return;
      touch.move(event);
      touchState.moving = true;
      setoffset(touch.deltaX.value, touch.deltaY.value);
      if (props.direction == "horizontal" && touch.isHorizontal()) {
        event.preventDefault();
        event.stopPropagation();
      }
      if (props.direction == "vertical" && touch.isVertical()) {
        event.preventDefault();
        event.stopPropagation();
      }
    },
    onTouchEnd() {
      if (touchState.moving) {
        touchState.moving = false;
        switch (position) {
          case "left":
          case "top":
            if (touchState.offset > 35) {
              tabMethods.next();
            }
            break;
          case "right":
          case "bottom":
            if (touchState.offset < -35) {
              tabMethods.prev();
            }
            break;
        }
      }
    }
  };
  return { touchMethods, touchState, tabsContentRef };
};
class Title {
  constructor() {
    __publicField$2(this, "title", "");
    __publicField$2(this, "titleSlot");
    __publicField$2(this, "paneKey", "");
    __publicField$2(this, "disabled", false);
  }
}
const { create: create$S } = createComponent("tabs");
const _sfc_main$1i = create$S({
  components: { NutSticky, JoySmile: g$1 },
  props: {
    modelValue: {
      type: [String, Number],
      default: 0
    },
    color: {
      type: String,
      default: ""
    },
    direction: {
      type: String,
      default: "horizontal"
    },
    size: {
      type: String,
      default: "normal"
    },
    type: {
      type: String,
      default: "line"
    },
    titleScroll: {
      type: Boolean,
      default: false
    },
    ellipsis: {
      type: Boolean,
      default: true
    },
    swipeable: {
      type: Boolean,
      default: false
    },
    autoHeight: {
      type: Boolean,
      default: false
    },
    background: {
      type: String,
      default: ""
    },
    animatedTime: {
      type: [Number, String],
      default: 300
    },
    titleGutter: {
      type: [Number, String],
      default: 0
    },
    sticky: {
      type: Boolean,
      default: false
    },
    top: {
      type: Number,
      default: 0
    },
    align: {
      type: String,
      default: "center"
    }
  },
  emits: ["update:modelValue", "click", "change"],
  setup(props, { emit: emit2, slots }) {
    const container = ref(null);
    let stickyFixed;
    provide(TABS_KEY, {
      activeKey: computed(() => props.modelValue || "0"),
      autoHeight: computed(() => props.autoHeight),
      animatedTime: computed(() => props.animatedTime)
    });
    const titles = ref([]);
    const renderTitles = (vnodes) => {
      vnodes.forEach((vnode, index2) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i;
        let type = vnode.type;
        type = type.name || type;
        if (type == "NutTabPane") {
          let title = new Title();
          if (((_a = vnode.props) == null ? void 0 : _a.title) || ((_b = vnode.props) == null ? void 0 : _b["pane-key"]) || ((_c = vnode.props) == null ? void 0 : _c["paneKey"])) {
            let paneKeyType = TypeOfFun((_d = vnode.props) == null ? void 0 : _d["pane-key"]);
            let paneIndex = paneKeyType == "number" || paneKeyType == "string" ? String((_e = vnode.props) == null ? void 0 : _e["pane-key"]) : null;
            let camelPaneKeyType = TypeOfFun((_f = vnode.props) == null ? void 0 : _f["paneKey"]);
            let camelPaneIndex = camelPaneKeyType == "number" || camelPaneKeyType == "string" ? String((_g = vnode.props) == null ? void 0 : _g["paneKey"]) : null;
            title.title = (_h = vnode.props) == null ? void 0 : _h.title;
            title.paneKey = paneIndex || camelPaneIndex || String(index2);
            title.disabled = (_i = vnode.props) == null ? void 0 : _i.disabled;
          }
          titles.value.push(title);
        } else {
          if (vnode.children == " ") {
            return;
          }
          renderTitles(vnode.children);
        }
      });
    };
    const currentIndex = ref(props.modelValue || 0);
    const findTabsIndex = (value) => {
      let index2 = titles.value.findIndex((item) => item.paneKey == value);
      if (titles.value.length == 0) ;
      else if (index2 == -1) ;
      else {
        currentIndex.value = index2;
      }
    };
    const getScrollY = computed(() => {
      return props.titleScroll && props.direction === "vertical";
    });
    const navRef = ref();
    const titleRef = ref([]);
    const scrollIntoView = (immediate) => {
      const nav = navRef.value;
      const _titles = titleRef.value;
      if (!nav || !_titles || !_titles[currentIndex.value]) {
        return;
      }
      const title = _titles[currentIndex.value];
      let to = 0;
      if (props.direction === "vertical") {
        const runTop = title.offsetTop - nav.offsetTop + 10;
        to = runTop - (nav.offsetHeight - title.offsetHeight) / 2;
      } else {
        to = title.offsetLeft - (nav.offsetWidth - title.offsetWidth) / 2;
      }
      scrollDirection(nav, to, 0.3, props.direction);
    };
    const scrollDirection = (nav, to, duration, direction) => {
      let count2 = 0;
      const from = direction === "horizontal" ? nav.scrollLeft : nav.scrollTop;
      const frames = Math.round(duration * 1e3 / 16);
      function animate() {
        if (direction === "horizontal") {
          nav.scrollLeft += (to - from) / frames;
        } else {
          nav.scrollTop += (to - from) / frames;
        }
        if (++count2 < frames) {
          requestAniFrame$1(animate);
        }
      }
      animate();
    };
    const init = (vnodes = ((_a) => (_a = slots.default) == null ? void 0 : _a.call(slots))()) => {
      titles.value = [];
      vnodes = vnodes == null ? void 0 : vnodes.filter((item) => typeof item.children !== "string");
      if (vnodes && vnodes.length) {
        renderTitles(vnodes);
      }
      findTabsIndex(props.modelValue);
      nextTick(() => {
        scrollIntoView();
      });
    };
    const onStickyScroll = (params) => {
      stickyFixed = params.fixed;
    };
    watch(
      () => {
        var _a;
        return (_a = slots.default) == null ? void 0 : _a.call(slots);
      },
      (vnodes) => {
        init(vnodes);
      }
    );
    const getScrollTopRoot2 = () => {
      return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
    };
    watch(
      () => props.modelValue,
      (value) => {
        findTabsIndex(value);
        scrollIntoView();
        if (stickyFixed) {
          let top = useRect(container.value).top + getScrollTopRoot2();
          let value2 = Math.ceil(top - props.top);
          window.scrollTo({
            top: value2,
            behavior: "smooth"
          });
        }
      }
    );
    onMounted(init);
    onActivated(init);
    const tabMethods = {
      isBegin: () => {
        return currentIndex.value == 0;
      },
      isEnd: () => {
        return currentIndex.value == titles.value.length - 1;
      },
      next: () => {
        currentIndex.value += 1;
        const nextDisabled = titles.value[currentIndex.value].disabled;
        if (tabMethods.isEnd() && nextDisabled) {
          tabMethods.prev();
          return;
        }
        if (nextDisabled && currentIndex.value < titles.value.length - 1) {
          tabMethods.next();
          return;
        }
        tabMethods.updateValue(titles.value[currentIndex.value]);
      },
      prev: () => {
        currentIndex.value -= 1;
        const prevDisabled = titles.value[currentIndex.value].disabled;
        if (tabMethods.isBegin() && prevDisabled) {
          tabMethods.next();
          return;
        }
        if (prevDisabled && currentIndex.value > 0) {
          tabMethods.prev();
          return;
        }
        tabMethods.updateValue(titles.value[currentIndex.value]);
      },
      updateValue: (item) => {
        emit2("update:modelValue", item.paneKey);
        emit2("change", item);
      },
      tabChange: (item, index2) => {
        emit2("click", item);
        if (item.disabled || currentIndex.value == index2) {
          return;
        }
        currentIndex.value = index2;
        tabMethods.updateValue(item);
      },
      setTabItemRef: (el, index2) => {
        titleRef.value[index2] = el;
      }
    };
    const { tabsContentRef, touchState, touchMethods } = useTabContentTouch(props, tabMethods);
    const contentStyle = computed(() => {
      let offsetPercent = currentIndex.value * 100;
      if (touchState.moving) {
        offsetPercent += touchState.offset;
      }
      let style = {
        transform: props.direction == "horizontal" ? `translate3d(-${offsetPercent}%, 0, 0)` : `translate3d( 0,-${offsetPercent}%, 0)`,
        transitionDuration: touchState.moving ? void 0 : `${props.animatedTime}ms`
      };
      if (props.animatedTime == 0) {
        style = {};
      }
      return style;
    });
    const tabsNavStyle = computed(() => {
      return {
        background: props.background
      };
    });
    const tabsActiveStyle = computed(() => {
      return {
        color: props.type == "smile" ? props.color : "",
        background: props.type == "line" ? props.color : ""
      };
    });
    const titleStyle = computed(() => {
      if (!props.titleGutter) return {};
      const px = pxCheck(props.titleGutter);
      if (props.direction === "vertical") {
        return { paddingTop: px, paddingBottom: px };
      }
      return { paddingLeft: px, paddingRight: px };
    });
    return __spreadValues$V(__spreadValues$V({
      navRef,
      tabsContentRef,
      titles,
      contentStyle,
      tabsNavStyle,
      titleStyle,
      tabsActiveStyle,
      container,
      getScrollY,
      onStickyScroll
    }, tabMethods), touchMethods);
  }
});
const _hoisted_1$Z = ["onClick"];
const _hoisted_2$P = ["onClick"];
function _sfc_render$Q(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_JoySmile = resolveComponent("JoySmile");
  const _component_nut_sticky = resolveComponent("nut-sticky");
  return openBlock(), createElementBlock("view", {
    ref: "container",
    class: normalizeClass(["nut-tabs", [_ctx.direction]])
  }, [
    _ctx.sticky ? (openBlock(), createBlock(_component_nut_sticky, {
      key: 0,
      top: _ctx.top,
      container: _ctx.container,
      onScroll: _ctx.onStickyScroll
    }, {
      default: withCtx(() => [
        createBaseVNode("view", {
          ref: "navRef",
          class: normalizeClass(["nut-tabs__titles", {
            "nut-tabs__titles-left": _ctx.align === "left",
            [_ctx.type]: _ctx.type,
            scrollable: _ctx.titleScroll,
            [_ctx.size]: _ctx.size
          }]),
          style: normalizeStyle(_ctx.tabsNavStyle)
        }, [
          _ctx.$slots.titles ? renderSlot(_ctx.$slots, "titles", { key: 0 }) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(_ctx.titles, (item, index2) => {
            return openBlock(), createElementBlock("view", {
              key: item.paneKey,
              class: normalizeClass(["nut-tabs__titles-item", {
                "nut-tabs__titles-item-left": _ctx.align === "left",
                active: item.paneKey == _ctx.modelValue,
                disabled: item.disabled
              }]),
              style: normalizeStyle(_ctx.titleStyle),
              onClick: ($event) => _ctx.tabChange(item, index2)
            }, [
              _ctx.type == "line" ? (openBlock(), createElementBlock("view", {
                key: 0,
                class: "nut-tabs__titles-item__line",
                style: normalizeStyle(_ctx.tabsActiveStyle)
              }, null, 4)) : createCommentVNode("", true),
              _ctx.type == "smile" ? (openBlock(), createElementBlock("view", {
                key: 1,
                class: "nut-tabs__titles-item__smile",
                style: normalizeStyle(_ctx.tabsActiveStyle)
              }, [
                createVNode(_component_JoySmile, { color: _ctx.color }, null, 8, ["color"])
              ], 4)) : createCommentVNode("", true),
              createBaseVNode("view", {
                class: normalizeClass(["nut-tabs__titles-item__text", { ellipsis: _ctx.ellipsis }])
              }, toDisplayString(item.title), 3)
            ], 14, _hoisted_1$Z);
          }), 128))
        ], 6)
      ]),
      _: 3
    }, 8, ["top", "container", "onScroll"])) : (openBlock(), createElementBlock("view", {
      key: 1,
      ref: "navRef",
      class: normalizeClass(["nut-tabs__titles", { "nut-tabs__titles-left": _ctx.align === "left", [_ctx.type]: _ctx.type, scrollable: _ctx.titleScroll, [_ctx.size]: _ctx.size }]),
      style: normalizeStyle(_ctx.tabsNavStyle)
    }, [
      _ctx.$slots.titles ? renderSlot(_ctx.$slots, "titles", { key: 0 }) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(_ctx.titles, (item, index2) => {
        return openBlock(), createElementBlock("view", {
          key: item.paneKey,
          ref_for: true,
          ref: (e) => _ctx.setTabItemRef(e, index2),
          class: normalizeClass(["nut-tabs__titles-item", {
            "nut-tabs__titles-item-left": _ctx.align === "left",
            active: item.paneKey == _ctx.modelValue,
            disabled: item.disabled
          }]),
          style: normalizeStyle(_ctx.titleStyle),
          onClick: ($event) => _ctx.tabChange(item, index2)
        }, [
          _ctx.type == "line" ? (openBlock(), createElementBlock("view", {
            key: 0,
            class: "nut-tabs__titles-item__line",
            style: normalizeStyle(_ctx.tabsActiveStyle)
          }, null, 4)) : createCommentVNode("", true),
          _ctx.type == "smile" ? (openBlock(), createElementBlock("view", {
            key: 1,
            class: "nut-tabs__titles-item__smile",
            style: normalizeStyle(_ctx.tabsActiveStyle)
          }, [
            createVNode(_component_JoySmile, { color: _ctx.color }, null, 8, ["color"])
          ], 4)) : createCommentVNode("", true),
          createBaseVNode("view", {
            class: normalizeClass(["nut-tabs__titles-item__text", { ellipsis: _ctx.ellipsis }])
          }, toDisplayString(item.title), 3)
        ], 14, _hoisted_2$P);
      }), 128))
    ], 6)),
    createBaseVNode("view", {
      ref: "tabsContentRef",
      class: "nut-tabs__content",
      style: normalizeStyle(_ctx.contentStyle),
      onTouchstart: _cache[0] || (_cache[0] = (...args) => _ctx.onTouchStart && _ctx.onTouchStart(...args)),
      onTouchmove: _cache[1] || (_cache[1] = (...args) => _ctx.onTouchMove && _ctx.onTouchMove(...args)),
      onTouchend: _cache[2] || (_cache[2] = (...args) => _ctx.onTouchEnd && _ctx.onTouchEnd(...args)),
      onTouchcancel: _cache[3] || (_cache[3] = (...args) => _ctx.onTouchEnd && _ctx.onTouchEnd(...args))
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 36)
  ], 2);
}
const NutTabs = /* @__PURE__ */ _export_sfc(_sfc_main$1i, [["render", _sfc_render$Q]]);
var __defProp$V = Object.defineProperty;
var __defProps$U = Object.defineProperties;
var __getOwnPropDescs$U = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$U = Object.getOwnPropertySymbols;
var __hasOwnProp$U = Object.prototype.hasOwnProperty;
var __propIsEnum$U = Object.prototype.propertyIsEnumerable;
var __defNormalProp$V = (obj, key, value) => key in obj ? __defProp$V(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$U = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$U.call(b, prop))
      __defNormalProp$V(a2, prop, b[prop]);
  if (__getOwnPropSymbols$U)
    for (var prop of __getOwnPropSymbols$U(b)) {
      if (__propIsEnum$U.call(b, prop))
        __defNormalProp$V(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$U = (a2, b) => __defProps$U(a2, __getOwnPropDescs$U(b));
const { create: create$R } = createComponent("tab-pane");
const _sfc_main$1h = create$R({
  props: {
    title: {
      type: [String, Number],
      default: ""
    },
    paneKey: {
      type: [String, Number],
      default: ""
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  emits: ["click"],
  setup(props) {
    const parentOption = inject(TABS_KEY);
    const paneStyle = computed(() => {
      return {
        display: (parentOption == null ? void 0 : parentOption.animatedTime.value) == 0 && props.paneKey != (parentOption == null ? void 0 : parentOption.activeKey.value) ? "none" : void 0
      };
    });
    return __spreadProps$U(__spreadValues$U({}, parentOption), {
      paneStyle
    });
  }
});
function _sfc_render$P(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(["nut-tab-pane", { inactive: _ctx.paneKey != _ctx.activeKey && _ctx.autoHeight }]),
    style: normalizeStyle(_ctx.paneStyle)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 6);
}
const NutTabPane = /* @__PURE__ */ _export_sfc(_sfc_main$1h, [["render", _sfc_render$P]]);
var __defProp$U = Object.defineProperty;
var __defProps$T = Object.defineProperties;
var __getOwnPropDescs$T = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$T = Object.getOwnPropertySymbols;
var __hasOwnProp$T = Object.prototype.hasOwnProperty;
var __propIsEnum$T = Object.prototype.propertyIsEnumerable;
var __defNormalProp$U = (obj, key, value) => key in obj ? __defProp$U(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$T = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$T.call(b, prop))
      __defNormalProp$U(a2, prop, b[prop]);
  if (__getOwnPropSymbols$T)
    for (var prop of __getOwnPropSymbols$T(b)) {
      if (__propIsEnum$T.call(b, prop))
        __defNormalProp$U(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$T = (a2, b) => __defProps$T(a2, __getOwnPropDescs$T(b));
const _hoisted_1$Y = {
  key: 0,
  class: "nut-indicator--number"
};
const _hoisted_2$O = {
  key: 1,
  class: "nut-indicator--dot"
};
const _sfc_main$1g = /* @__PURE__ */ defineComponent(__spreadProps$T(__spreadValues$T({}, {
  name: "NutIndicator"
}), {
  __name: "indicator",
  props: {
    size: { default: 3 },
    current: { default: 1 },
    block: { type: Boolean, default: false },
    align: { default: "center" },
    fillZero: { type: Boolean, default: true }
  },
  setup(__props) {
    const props = __props;
    const classes = computed(() => {
      const prefixCls2 = "nut-indicator";
      return {
        [prefixCls2]: true,
        [`${prefixCls2}--block`]: props.block,
        [`${prefixCls2}--align__${props.align}`]: props.block && props.align
      };
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("view", {
        class: normalizeClass(classes.value)
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.size, (item) => {
          return openBlock(), createElementBlock(Fragment, { key: item }, [
            item === _ctx.current ? (openBlock(), createElementBlock("view", _hoisted_1$Y, toDisplayString(_ctx.fillZero && unref(padZero)(item) || item), 1)) : (openBlock(), createElementBlock("view", _hoisted_2$O))
          ], 64);
        }), 128))
      ], 2);
    };
  }
}));
withInstall(_sfc_main$1g);
var __defProp$T = Object.defineProperty;
var __defProps$S = Object.defineProperties;
var __getOwnPropDescs$S = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$S = Object.getOwnPropertySymbols;
var __hasOwnProp$S = Object.prototype.hasOwnProperty;
var __propIsEnum$S = Object.prototype.propertyIsEnumerable;
var __defNormalProp$T = (obj, key, value) => key in obj ? __defProp$T(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$S = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$S.call(b, prop))
      __defNormalProp$T(a2, prop, b[prop]);
  if (__getOwnPropSymbols$S)
    for (var prop of __getOwnPropSymbols$S(b)) {
      if (__propIsEnum$S.call(b, prop))
        __defNormalProp$T(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$S = (a2, b) => __defProps$S(a2, __getOwnPropDescs$S(b));
const { create: create$Q } = createComponent("side-navbar");
const _sfc_main$1f = create$Q({
  props: {
    offset: {
      type: [String, Number],
      default: 15
    }
  },
  setup: (props) => {
    const list = ref(null);
    const state = reactive({
      count: 1,
      observer: null
    });
    const setPaddingLeft = (nodeList, level = 1) => {
      var _a;
      for (let i2 = 0; i2 < nodeList.length; i2++) {
        let item = nodeList[i2];
        if ((_a = item == null ? void 0 : item.children) == null ? void 0 : _a[0]) {
          item.children[0].style.paddingLeft = +props.offset * level + "px";
          if (!item.className.includes("nut-side-navbar-item")) {
            setPaddingLeft(Array.from(item.children[1].children), ++state.count);
          }
        }
      }
      state.count--;
    };
    const handleSlots = () => {
      let childNodes = list.value.childNodes;
      if (childNodes == null ? void 0 : childNodes.length) {
        childNodes = Array.from(childNodes).filter((item) => item.nodeType !== 3).map((item) => {
          return item;
        });
        setPaddingLeft(childNodes);
      }
    };
    onMounted(() => {
      handleSlots();
      state.observer = new MutationObserver(function() {
        state.count = 1;
        handleSlots();
      });
      state.observer.observe(list.value, {
        attributes: false,
        childList: true,
        characterData: false,
        subtree: true
      });
    });
    return __spreadProps$S(__spreadValues$S({}, toRefs(state)), {
      list
    });
  }
});
const _hoisted_1$X = { class: "nut-side-navbar" };
const _hoisted_2$N = { class: "nut-side-navbar__content" };
const _hoisted_3$F = {
  ref: "list",
  class: "nut-side-navbar__content__list"
};
function _sfc_render$O(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", _hoisted_1$X, [
    createBaseVNode("view", _hoisted_2$N, [
      createBaseVNode("view", _hoisted_3$F, [
        renderSlot(_ctx.$slots, "default")
      ], 512)
    ])
  ]);
}
const index$A = /* @__PURE__ */ _export_sfc(_sfc_main$1f, [["render", _sfc_render$O]]);
const { create: create$P } = createComponent("side-navbar-item");
const _sfc_main$1e = create$P({
  props: {
    title: {
      type: String,
      default: ""
    }
  }
});
const _hoisted_1$W = { class: "nut-side-navbar-item" };
const _hoisted_2$M = { class: "nut-side-navbar-item__title" };
function _sfc_render$N(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", _hoisted_1$W, [
    createBaseVNode("span", _hoisted_2$M, toDisplayString(_ctx.title), 1)
  ]);
}
const index$z = /* @__PURE__ */ _export_sfc(_sfc_main$1e, [["render", _sfc_render$N]]);
var __defProp$S = Object.defineProperty;
var __defProps$R = Object.defineProperties;
var __getOwnPropDescs$R = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$R = Object.getOwnPropertySymbols;
var __hasOwnProp$R = Object.prototype.hasOwnProperty;
var __propIsEnum$R = Object.prototype.propertyIsEnumerable;
var __defNormalProp$S = (obj, key, value) => key in obj ? __defProp$S(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$R = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$R.call(b, prop))
      __defNormalProp$S(a2, prop, b[prop]);
  if (__getOwnPropSymbols$R)
    for (var prop of __getOwnPropSymbols$R(b)) {
      if (__propIsEnum$R.call(b, prop))
        __defNormalProp$S(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$R = (a2, b) => __defProps$R(a2, __getOwnPropDescs$R(b));
const { create: create$O } = createComponent("sub-side-navbar");
const _sfc_main$1d = create$O({
  props: {
    title: {
      type: String,
      default: ""
    },
    open: {
      type: Boolean,
      default: true
    }
  },
  components: { ArrowDown2: v$9, ArrowUp2: v$8 },
  emits: ["titleClick"],
  setup: (props, { emit: emit2 }) => {
    const state = reactive({
      direction: ""
    });
    const style = computed(() => {
      return {
        height: !state.direction ? "auto" : "0px"
      };
    });
    const handleClick = () => {
      emit2("titleClick");
      state.direction = !state.direction ? "up" : "";
    };
    onMounted(() => {
      state.direction = props.open ? "" : "up";
    });
    return __spreadProps$R(__spreadValues$R({}, toRefs(state)), {
      style,
      handleClick
    });
  }
});
const _hoisted_1$V = { class: "nut-sub-side-navbar" };
const _hoisted_2$L = { class: "nut-sub-side-navbar__title__text" };
const _hoisted_3$E = { class: "nut-sub-side-navbar__title__icon" };
function _sfc_render$M(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ArrowDown2 = resolveComponent("ArrowDown2");
  const _component_ArrowUp2 = resolveComponent("ArrowUp2");
  return openBlock(), createElementBlock("view", _hoisted_1$V, [
    createBaseVNode("view", {
      class: "nut-sub-side-navbar__title",
      onClick: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.handleClick && _ctx.handleClick(...args), ["stop"]))
    }, [
      createBaseVNode("span", _hoisted_2$L, toDisplayString(_ctx.title), 1),
      createBaseVNode("span", _hoisted_3$E, [
        !_ctx.direction ? (openBlock(), createBlock(_component_ArrowDown2, { key: 0 })) : (openBlock(), createBlock(_component_ArrowUp2, { key: 1 }))
      ])
    ]),
    withDirectives(createBaseVNode("view", {
      class: normalizeClass(["nut-sub-side-navbar__list", !_ctx.direction ? "nutFadeIn" : "nutFadeOut"]),
      style: normalizeStyle(_ctx.style)
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 6), [
      [vShow, !_ctx.direction]
    ])
  ]);
}
const index$y = /* @__PURE__ */ _export_sfc(_sfc_main$1d, [["render", _sfc_render$M]]);
const FORM_KEY = Symbol("nut-form");
const FORM_DISABLED_KEY = Symbol("nut-form-disabled");
const FORM_TIP_KEY = Symbol("nut-form-tip");
const useFormDisabled = (disabled) => {
  const { parent } = useParent(FORM_DISABLED_KEY);
  return computed(() => {
    var _a;
    return disabled.value || ((_a = parent == null ? void 0 : parent.props) == null ? void 0 : _a.disabled) || false;
  });
};
var __defProp$R = Object.defineProperty;
var __defProps$Q = Object.defineProperties;
var __getOwnPropDescs$Q = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$Q = Object.getOwnPropertySymbols;
var __hasOwnProp$Q = Object.prototype.hasOwnProperty;
var __propIsEnum$Q = Object.prototype.propertyIsEnumerable;
var __defNormalProp$R = (obj, key, value) => key in obj ? __defProp$R(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$Q = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$Q.call(b, prop))
      __defNormalProp$R(a2, prop, b[prop]);
  if (__getOwnPropSymbols$Q)
    for (var prop of __getOwnPropSymbols$Q(b)) {
      if (__propIsEnum$Q.call(b, prop))
        __defNormalProp$R(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$Q = (a2, b) => __defProps$Q(a2, __getOwnPropDescs$Q(b));
const { componentName: componentName$4, create: create$N } = createComponent("range");
const _sfc_main$1c = create$N({
  props: {
    range: {
      type: Boolean,
      default: false
    },
    disabled: Boolean,
    activeColor: String,
    inactiveColor: String,
    buttonColor: String,
    vertical: {
      type: Boolean,
      default: false
    },
    marks: {
      type: Object,
      default: {}
    },
    hiddenRange: {
      type: Boolean,
      default: false
    },
    hiddenTag: {
      type: Boolean,
      default: false
    },
    min: {
      type: [Number, String],
      default: 0
    },
    max: {
      type: [Number, String],
      default: 100
    },
    step: {
      type: [Number, String],
      default: 1
    },
    modelValue: {
      type: [Number, Array],
      default: 0
    }
  },
  emits: ["change", "dragEnd", "dragStart", "update:modelValue"],
  setup(props, { emit: emit2 }) {
    const disabled = useFormDisabled(toRef(props, "disabled"));
    const buttonIndex = ref(0);
    let startValue;
    let currentValue;
    const root = ref();
    const dragStatus = ref();
    const touch = useTouch();
    const marksList = computed(() => {
      const { marks, max, min } = props;
      const marksKeys = Object.keys(marks);
      const list = marksKeys.map(parseFloat).sort((a2, b) => a2 - b).filter((point) => point >= +min && point <= +max);
      return list;
    });
    const scope = computed(() => Number(props.max) - Number(props.min));
    const classes = computed(() => {
      const prefixCls2 = componentName$4;
      return {
        [prefixCls2]: true,
        [`${prefixCls2}-disabled`]: disabled.value,
        [`${prefixCls2}-vertical`]: props.vertical,
        [`${prefixCls2}-show-number`]: !props.hiddenRange
      };
    });
    const containerClasses = computed(() => {
      const prefixCls2 = "nut-range-container";
      return {
        [prefixCls2]: true,
        [`${prefixCls2}-vertical`]: props.vertical
      };
    });
    const wrapperStyle = computed(() => {
      return {
        background: props.inactiveColor
      };
    });
    const buttonStyle = computed(() => {
      return {
        borderColor: props.buttonColor
      };
    });
    const isRange = (val) => !!props.range && Array.isArray(val);
    const calcMainAxis = () => {
      const { modelValue, min } = props;
      if (isRange(modelValue)) {
        return `${(modelValue[1] - modelValue[0]) * 100 / scope.value}%`;
      }
      return `${(modelValue - Number(min)) * 100 / scope.value}%`;
    };
    const calcOffset = () => {
      const { modelValue, min } = props;
      if (isRange(modelValue)) {
        return `${(modelValue[0] - Number(min)) * 100 / scope.value}%`;
      }
      return `0%`;
    };
    const barStyle = computed(() => {
      if (props.vertical) {
        return {
          height: calcMainAxis(),
          top: calcOffset(),
          background: props.activeColor,
          transition: dragStatus.value ? "none" : void 0
        };
      } else {
        return {
          width: calcMainAxis(),
          left: calcOffset(),
          background: props.activeColor,
          transition: dragStatus.value ? "none" : void 0
        };
      }
    });
    const markClassName = (mark) => {
      const classPrefix = "nut-range-mark";
      const { modelValue, max, min } = props;
      let lowerBound = Number(min);
      let upperBound = Number(max);
      if (props.range) {
        const [left, right] = modelValue;
        lowerBound = left;
        upperBound = right;
      } else {
        upperBound = modelValue;
      }
      let isActive = mark <= +upperBound && mark >= lowerBound;
      return {
        [`${classPrefix}-text`]: true,
        [`${classPrefix}-text-active`]: isActive
      };
    };
    const marksStyle = (mark) => {
      const { min, vertical } = props;
      let style = {
        left: `${(mark - Number(min)) / scope.value * 100}%`
      };
      if (vertical) {
        style = {
          top: `${(mark - Number(min)) / scope.value * 100}%`
        };
      }
      return style;
    };
    const tickStyle = (mark) => {
      const { modelValue, max, min } = props;
      let lowerBound = Number(min);
      let upperBound = Number(max);
      if (props.range) {
        const [left, right] = modelValue;
        lowerBound = left;
        upperBound = right;
      }
      let isActive = mark <= upperBound && mark >= lowerBound;
      let style = {
        background: !isActive ? props.inactiveColor : props.activeColor
      };
      return style;
    };
    const format2 = (value) => {
      const { min, max, step } = props;
      value = Math.max(+min, Math.min(value, +max));
      return Math.round(value / +step) * +step;
    };
    const isSameValue = (newValue, oldValue) => JSON.stringify(newValue) === JSON.stringify(oldValue);
    const handleOverlap = (value) => {
      if (value[0] > value[1]) {
        return value.slice(0).reverse();
      }
      return value;
    };
    const updateValue = (value, end) => {
      if (isRange(value)) {
        value = handleOverlap(value).map(format2);
      } else {
        value = format2(value);
      }
      if (!isSameValue(value, props.modelValue)) {
        emit2("update:modelValue", value);
      }
      if (end && !isSameValue(value, startValue)) {
        emit2("change", value);
      }
    };
    const onClick = (event) => {
      if (disabled.value) {
        return;
      }
      const { min, modelValue } = props;
      const rect = useRect(root);
      let delta = event.clientX - rect.left;
      let total = rect.width;
      if (props.vertical) {
        delta = event.clientY - rect.top;
        total = rect.height;
      }
      const value = Number(min) + delta / total * scope.value;
      if (isRange(modelValue)) {
        const [left, right] = modelValue;
        const middle = (left + right) / 2;
        if (value <= middle) {
          updateValue([value, right], true);
        } else {
          updateValue([left, value], true);
        }
      } else {
        updateValue(value, true);
      }
    };
    const onTouchStart = (event) => {
      if (disabled.value) {
        return;
      }
      touch.start(event);
      currentValue = props.modelValue;
      if (isRange(currentValue)) {
        startValue = currentValue.map(format2);
      } else {
        startValue = format2(currentValue);
      }
      dragStatus.value = "start";
    };
    const onTouchMove = (event) => {
      if (disabled.value) {
        return;
      }
      if (dragStatus.value === "start") {
        emit2("dragStart");
      }
      touch.move(event);
      dragStatus.value = "draging";
      const rect = useRect(root);
      let delta = touch.deltaX.value;
      let total = rect.width;
      let diff = delta / total * scope.value;
      if (props.vertical) {
        delta = touch.deltaY.value;
        total = rect.height;
        diff = delta / total * scope.value;
      }
      if (isRange(startValue)) {
        currentValue[buttonIndex.value] = startValue[buttonIndex.value] + diff;
      } else {
        currentValue = startValue + diff;
      }
      updateValue(currentValue);
    };
    const onTouchEnd = () => {
      if (disabled.value) {
        return;
      }
      if (dragStatus.value === "draging") {
        updateValue(currentValue, true);
        emit2("dragEnd");
      }
      dragStatus.value = "";
    };
    const curValue = (idx) => {
      const value = isArray(props.modelValue) && typeof idx === "number" ? props.modelValue[idx] : Number(props.modelValue);
      return value;
    };
    return __spreadProps$Q(__spreadValues$Q({
      root,
      classes,
      wrapperStyle,
      buttonStyle,
      onClick,
      onTouchStart,
      onTouchMove,
      onTouchEnd
    }, toRefs(props)), {
      barStyle,
      curValue,
      buttonIndex,
      containerClasses,
      markClassName,
      marksStyle,
      marksList,
      tickStyle,
      disabled
    });
  }
});
const _hoisted_1$U = {
  key: 0,
  class: "nut-range-min"
};
const _hoisted_2$K = {
  key: 0,
  class: "nut-range-mark"
};
const _hoisted_3$D = ["tabindex", "aria-valuemin", "aria-valuenow", "aria-valuemax", "onTouchstart"];
const _hoisted_4$y = {
  key: 0,
  class: "number"
};
const _hoisted_5$p = ["tabindex", "aria-valuemin", "aria-valuenow", "aria-valuemax"];
const _hoisted_6$n = {
  key: 0,
  class: "number"
};
const _hoisted_7$j = {
  key: 1,
  class: "nut-range-max"
};
function _sfc_render$L(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.containerClasses)
  }, [
    !_ctx.hiddenRange ? (openBlock(), createElementBlock("view", _hoisted_1$U, toDisplayString(+_ctx.min), 1)) : createCommentVNode("", true),
    createBaseVNode("view", {
      ref: "root",
      style: normalizeStyle(_ctx.wrapperStyle),
      class: normalizeClass(_ctx.classes),
      onClick: _cache[9] || (_cache[9] = withModifiers((...args) => _ctx.onClick && _ctx.onClick(...args), ["stop"]))
    }, [
      _ctx.marksList.length > 0 ? (openBlock(), createElementBlock("view", _hoisted_2$K, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.marksList, (marks) => {
          return openBlock(), createElementBlock("span", {
            key: marks,
            class: normalizeClass(_ctx.markClassName(marks)),
            style: normalizeStyle(_ctx.marksStyle(marks))
          }, [
            createTextVNode(toDisplayString(marks) + " ", 1),
            createBaseVNode("span", {
              class: "nut-range-tick",
              style: normalizeStyle(_ctx.tickStyle(marks))
            }, null, 4)
          ], 6);
        }), 128))
      ])) : createCommentVNode("", true),
      createBaseVNode("view", {
        class: "nut-range-bar",
        style: normalizeStyle(_ctx.barStyle)
      }, [
        _ctx.range ? (openBlock(), createElementBlock(Fragment, { key: 0 }, renderList([0, 1], (index2) => {
          return createBaseVNode("view", {
            key: index2,
            role: "slider",
            class: normalizeClass({
              "nut-range-button-wrapper-left": index2 == 0,
              "nut-range-button-wrapper-right": index2 == 1
            }),
            tabindex: _ctx.disabled ? -1 : 0,
            "aria-valuemin": +_ctx.min,
            "aria-valuenow": _ctx.curValue(index2),
            "aria-valuemax": +_ctx.max,
            "aria-orientation": "horizontal",
            onTouchstart: withModifiers(
              (e) => {
                if (typeof index2 === "number") {
                  _ctx.buttonIndex = index2;
                }
                _ctx.onTouchStart(e);
              },
              ["stop", "prevent"]
            ),
            onTouchmove: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.onTouchMove && _ctx.onTouchMove(...args), ["stop", "prevent"])),
            onTouchend: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.onTouchEnd && _ctx.onTouchEnd(...args), ["stop", "prevent"])),
            onTouchcancel: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.onTouchEnd && _ctx.onTouchEnd(...args), ["stop", "prevent"])),
            onClick: _cache[3] || (_cache[3] = (e) => e.stopPropagation())
          }, [
            _ctx.$slots.button ? renderSlot(_ctx.$slots, "button", { key: 0 }) : (openBlock(), createElementBlock("view", {
              key: 1,
              class: "nut-range-button",
              style: normalizeStyle(_ctx.buttonStyle)
            }, [
              !_ctx.hiddenTag ? (openBlock(), createElementBlock("view", _hoisted_4$y, toDisplayString(_ctx.curValue(index2)), 1)) : createCommentVNode("", true)
            ], 4))
          ], 42, _hoisted_3$D);
        }), 64)) : (openBlock(), createElementBlock("view", {
          key: 1,
          role: "slider",
          class: "nut-range-button-wrapper",
          tabindex: _ctx.disabled ? -1 : 0,
          "aria-valuemin": +_ctx.min,
          "aria-valuenow": _ctx.curValue(),
          "aria-valuemax": +_ctx.max,
          "aria-orientation": "horizontal",
          onTouchstart: _cache[4] || (_cache[4] = withModifiers(
            (e) => {
              _ctx.onTouchStart(e);
            },
            ["stop", "prevent"]
          )),
          onTouchmove: _cache[5] || (_cache[5] = withModifiers((...args) => _ctx.onTouchMove && _ctx.onTouchMove(...args), ["stop", "prevent"])),
          onTouchend: _cache[6] || (_cache[6] = withModifiers((...args) => _ctx.onTouchEnd && _ctx.onTouchEnd(...args), ["stop", "prevent"])),
          onTouchcancel: _cache[7] || (_cache[7] = withModifiers((...args) => _ctx.onTouchEnd && _ctx.onTouchEnd(...args), ["stop", "prevent"])),
          onClick: _cache[8] || (_cache[8] = (e) => e.stopPropagation())
        }, [
          _ctx.$slots.button ? renderSlot(_ctx.$slots, "button", { key: 0 }) : (openBlock(), createElementBlock("view", {
            key: 1,
            class: "nut-range-button",
            style: normalizeStyle(_ctx.buttonStyle)
          }, [
            !_ctx.hiddenTag ? (openBlock(), createElementBlock("view", _hoisted_6$n, toDisplayString(_ctx.curValue()), 1)) : createCommentVNode("", true)
          ], 4))
        ], 40, _hoisted_5$p))
      ], 4)
    ], 6),
    !_ctx.hiddenRange ? (openBlock(), createElementBlock("view", _hoisted_7$j, toDisplayString(+_ctx.max), 1)) : createCommentVNode("", true)
  ], 2);
}
const NutRange = /* @__PURE__ */ _export_sfc(_sfc_main$1c, [["render", _sfc_render$L]]);
var __defProp$Q = Object.defineProperty;
var __defProps$P = Object.defineProperties;
var __getOwnPropDescs$P = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$P = Object.getOwnPropertySymbols;
var __hasOwnProp$P = Object.prototype.hasOwnProperty;
var __propIsEnum$P = Object.prototype.propertyIsEnumerable;
var __defNormalProp$Q = (obj, key, value) => key in obj ? __defProp$Q(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$P = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$P.call(b, prop))
      __defNormalProp$Q(a2, prop, b[prop]);
  if (__getOwnPropSymbols$P)
    for (var prop of __getOwnPropSymbols$P(b)) {
      if (__propIsEnum$P.call(b, prop))
        __defNormalProp$Q(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$P = (a2, b) => __defProps$P(a2, __getOwnPropDescs$P(b));
const { create: create$M } = createComponent("searchbar");
const cN$m = "NutSearchbar";
const _sfc_main$1b = create$M({
  props: {
    modelValue: {
      type: [String, Number],
      default: ""
    },
    inputType: {
      type: String,
      default: "text"
    },
    label: {
      type: String,
      default: ""
    },
    shape: {
      type: String,
      default: "round"
    },
    maxLength: {
      type: [String, Number],
      default: "9999"
    },
    placeholder: {
      type: String,
      default: ""
    },
    clearable: {
      type: Boolean,
      default: true
    },
    clearIcon: {
      type: Object,
      default: () => z$1
    },
    background: {
      type: String,
      default: ""
    },
    inputBackground: {
      type: String,
      default: ""
    },
    focusStyle: {
      type: Object,
      default: () => ({})
    },
    autofocus: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    readonly: {
      type: Boolean,
      default: false
    },
    inputAlign: {
      type: String,
      default: "left"
    },
    safeAreaInsetBottom: {
      type: Boolean,
      default: false
    }
  },
  emits: [
    "change",
    "update:modelValue",
    "blur",
    "focus",
    "clear",
    "search",
    "clickInput",
    "clickLeftIcon",
    "clickRightIcon"
  ],
  setup(props, { emit: emit2 }) {
    const disabled = useFormDisabled(toRef(props, "disabled"));
    const translate = useLocale(cN$m);
    const state = reactive({
      active: false
    });
    const searchbarStyle = computed(() => {
      return {
        background: props.background
      };
    });
    const inputSearchbarStyle = computed(() => {
      return {
        background: props.inputBackground
      };
    });
    const valueChange = (event) => {
      const input = event.target;
      let val = input.value;
      if (props.maxLength && val.length > Number(props.maxLength)) {
        val = val.slice(0, Number(props.maxLength));
      }
      emit2("update:modelValue", val, event);
      emit2("change", val, event);
    };
    const focusCss = ref({});
    const valueFocus = (event) => {
      const input = event.target;
      let value = input.value;
      state.active = true;
      focusCss.value = props.focusStyle;
      emit2("focus", value, event);
    };
    const valueBlur = (event) => {
      setTimeout(() => {
        state.active = false;
      }, 0);
      const input = event.target;
      let value = input.value;
      if (props.maxLength && value.length > Number(props.maxLength)) {
        value = value.slice(0, Number(props.maxLength));
      }
      focusCss.value = {};
      emit2("blur", value, event);
    };
    const handleClear = (event) => {
      emit2("update:modelValue", "", event);
      emit2("change", "", event);
      emit2("clear", "");
    };
    const handleSubmit = () => {
      emit2("search", props.modelValue);
    };
    const clickInput = (event) => {
      emit2("clickInput", event);
    };
    const leftIconClick = (event) => {
      emit2("clickLeftIcon", props.modelValue, event);
    };
    const rightIconClick = (event) => {
      emit2("clickRightIcon", props.modelValue, event);
    };
    const styleSearchbar = computed(() => {
      const style = {
        textAlign: props.inputAlign
      };
      return style;
    });
    const inputsearch = ref(null);
    onMounted(() => {
      if (props.autofocus) {
        inputsearch.value.focus();
      }
    });
    return __spreadProps$P(__spreadValues$P({
      renderIcon,
      inputsearch
    }, toRefs(state)), {
      valueChange,
      valueFocus,
      valueBlur,
      handleClear,
      handleSubmit,
      searchbarStyle,
      inputSearchbarStyle,
      focusCss,
      translate,
      clickInput,
      leftIconClick,
      rightIconClick,
      styleSearchbar,
      disabled
    });
  }
});
const _hoisted_1$T = {
  key: 0,
  class: "nut-searchbar__search-label"
};
const _hoisted_2$J = {
  key: 1,
  class: "nut-searchbar__search-icon nut-searchbar__left-search-icon"
};
const _hoisted_3$C = ["type", "maxlength", "placeholder", "value", "disabled", "readonly"];
const _hoisted_4$x = {
  key: 1,
  class: "nut-searchbar__search-icon nut-searchbar__iptright-search-icon"
};
const _hoisted_5$o = {
  key: 2,
  class: "nut-searchbar__search-icon nut-searchbar__right-search-icon"
};
function _sfc_render$K(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(["nut-searchbar", { "safe-area-inset-bottom": _ctx.safeAreaInsetBottom }]),
    style: normalizeStyle(_ctx.searchbarStyle)
  }, [
    _ctx.label ? (openBlock(), createElementBlock("span", _hoisted_1$T, toDisplayString(_ctx.label), 1)) : createCommentVNode("", true),
    _ctx.$slots.leftout ? (openBlock(), createElementBlock("view", _hoisted_2$J, [
      renderSlot(_ctx.$slots, "leftout")
    ])) : createCommentVNode("", true),
    createBaseVNode("view", {
      class: normalizeClass([`nut-searchbar__search-input`, _ctx.shape]),
      style: normalizeStyle(__spreadValues$P(__spreadValues$P({}, _ctx.inputSearchbarStyle), _ctx.focusCss))
    }, [
      _ctx.$slots.leftin ? (openBlock(), createElementBlock("view", {
        key: 0,
        class: "nut-searchbar__search-icon nut-searchbar__iptleft-search-icon",
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.leftIconClick && _ctx.leftIconClick(...args))
      }, [
        renderSlot(_ctx.$slots, "leftin")
      ])) : createCommentVNode("", true),
      createBaseVNode("view", {
        class: normalizeClass(["nut-searchbar__input-inner", _ctx.$slots.rightin && "nut-searchbar__input-inner-absolute"])
      }, [
        createBaseVNode("form", {
          class: "nut-searchbar__input-form",
          action: "#",
          onSubmit: _cache[5] || (_cache[5] = withModifiers((...args) => _ctx.handleSubmit && _ctx.handleSubmit(...args), ["prevent"]))
        }, [
          createBaseVNode("input", {
            ref: "inputsearch",
            class: normalizeClass(["nut-searchbar__input-bar", _ctx.clearable && "nut-searchbar__input-bar_clear"]),
            type: _ctx.inputType,
            maxlength: _ctx.maxLength,
            placeholder: _ctx.placeholder || _ctx.translate("placeholder"),
            value: _ctx.modelValue,
            disabled: _ctx.disabled,
            readonly: _ctx.readonly,
            style: normalizeStyle(_ctx.styleSearchbar),
            onClick: _cache[1] || (_cache[1] = (...args) => _ctx.clickInput && _ctx.clickInput(...args)),
            onInput: _cache[2] || (_cache[2] = (...args) => _ctx.valueChange && _ctx.valueChange(...args)),
            onFocus: _cache[3] || (_cache[3] = (...args) => _ctx.valueFocus && _ctx.valueFocus(...args)),
            onBlur: _cache[4] || (_cache[4] = (...args) => _ctx.valueBlur && _ctx.valueBlur(...args))
          }, null, 46, _hoisted_3$C)
        ], 32)
      ], 2),
      createBaseVNode("view", {
        class: normalizeClass(["nut-searchbar__input-inner-icon", _ctx.$slots.rightin && "nut-searchbar__input-inner-icon-absolute"])
      }, [
        _ctx.clearable ? withDirectives((openBlock(), createElementBlock("view", {
          key: 0,
          class: "nut-searchbar__search-icon nut-searchbar__input-clear",
          onClick: _cache[6] || (_cache[6] = (...args) => _ctx.handleClear && _ctx.handleClear(...args))
        }, [
          _ctx.$slots["clear-icon"] ? renderSlot(_ctx.$slots, "clear-icon", { key: 0 }) : (openBlock(), createBlock(resolveDynamicComponent(_ctx.renderIcon(_ctx.clearIcon)), { key: 1 }))
        ], 512)), [
          [vShow, String(_ctx.modelValue).length > 0]
        ]) : createCommentVNode("", true),
        _ctx.$slots.rightin ? (openBlock(), createElementBlock("view", _hoisted_4$x, [
          renderSlot(_ctx.$slots, "rightin")
        ])) : createCommentVNode("", true)
      ], 2)
    ], 6),
    _ctx.$slots.rightout ? (openBlock(), createElementBlock("view", _hoisted_5$o, [
      renderSlot(_ctx.$slots, "rightout")
    ])) : createCommentVNode("", true)
  ], 6);
}
const index$x = /* @__PURE__ */ _export_sfc(_sfc_main$1b, [["render", _sfc_render$K]]);
var __defProp$P = Object.defineProperty;
var __defProps$O = Object.defineProperties;
var __getOwnPropDescs$O = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$O = Object.getOwnPropertySymbols;
var __hasOwnProp$O = Object.prototype.hasOwnProperty;
var __propIsEnum$O = Object.prototype.propertyIsEnumerable;
var __defNormalProp$P = (obj, key, value) => key in obj ? __defProp$P(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$O = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$O.call(b, prop))
      __defNormalProp$P(a2, prop, b[prop]);
  if (__getOwnPropSymbols$O)
    for (var prop of __getOwnPropSymbols$O(b)) {
      if (__propIsEnum$O.call(b, prop))
        __defNormalProp$P(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$O = (a2, b) => __defProps$O(a2, __getOwnPropDescs$O(b));
var __restKey = (key) => typeof key === "symbol" ? key : key + "";
var __objRest$1 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$O.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$O)
    for (var prop of __getOwnPropSymbols$O(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$O.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __publicField$1 = (obj, key, value) => __defNormalProp$P(obj, typeof key !== "symbol" ? key + "" : key, value);
var __async$2 = (__this, __arguments, generator) => {
  return new Promise((resolve2, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve2(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const formatTree = (tree, parent, config) => tree.map((node) => {
  const { value: valueKey = "value", text: textKey = "text", children: childrenKey = "children" } = config;
  const _a = node, { [valueKey]: value, [textKey]: text, [childrenKey]: children } = _a, others = __objRest$1(_a, [__restKey(valueKey), __restKey(textKey), __restKey(childrenKey)]);
  const newNode = __spreadProps$O(__spreadValues$O({
    loading: false
  }, others), {
    level: parent ? (parent && parent.level || 0) + 1 : 0,
    value,
    text,
    children,
    _parent: parent
  });
  if (newNode.children && newNode.children.length) {
    newNode.children = formatTree(newNode.children, newNode, config);
  }
  return newNode;
});
const eachTree = (tree, cb) => {
  let i2 = 0;
  let node;
  while (node = tree[i2++]) {
    if (cb(node) === true) {
      break;
    }
    if (node.children && node.children.length) {
      eachTree(node.children, cb);
    }
  }
};
const defaultConvertConfig = {
  topId: null,
  idKey: "id",
  pidKey: "pid",
  sortKey: ""
};
const convertListToOptions = (list, options) => {
  const mergedOptions = __spreadValues$O(__spreadValues$O({}, defaultConvertConfig), options || {});
  const { topId, idKey, pidKey, sortKey } = mergedOptions;
  let result = [];
  let map = {};
  list.forEach((node) => {
    node = __spreadValues$O({}, node);
    const { [idKey]: id, [pidKey]: pid } = node;
    const children = map[pid] = map[pid] || [];
    if (!result.length && pid === topId) {
      result = children;
    }
    children.push(node);
    node.children = map[id] || (map[id] = []);
  });
  if (sortKey) {
    Object.keys(map).forEach((i2) => {
      if (map[i2].length > 1) {
        map[i2].sort((a2, b) => a2[sortKey] - b[sortKey]);
      }
    });
  }
  map = null;
  return result;
};
class Tree {
  constructor(nodes, config) {
    __publicField$1(this, "nodes");
    __publicField$1(this, "config");
    this.config = __spreadValues$O({
      value: "value",
      text: "text",
      children: "children"
    }, config || {});
    this.nodes = formatTree(nodes, null, this.config);
  }
  updateChildren(nodes, parent) {
    if (!parent) {
      this.nodes = formatTree(nodes, null, this.config);
    } else {
      parent.children = formatTree(nodes, parent, this.config);
    }
  }
  // for test
  getNodeByValue(value) {
    let foundNode;
    eachTree(this.nodes, (node) => {
      if (node.value === value) {
        foundNode = node;
        return true;
      }
    });
    return foundNode;
  }
  getPathNodesByValue(value) {
    if (!value.length) {
      return [];
    }
    const pathNodes = [];
    let currentNodes = this.nodes;
    while (currentNodes && currentNodes.length) {
      const foundNode = currentNodes.find((node) => node.value === value[node.level]);
      if (!foundNode) {
        break;
      }
      pathNodes.push(foundNode);
      currentNodes = foundNode.children;
    }
    return pathNodes;
  }
  isLeaf(node, lazy) {
    const { leaf, children } = node;
    const hasChildren = Array.isArray(children) && Boolean(children.length);
    return leaf || !hasChildren && !lazy;
  }
  hasChildren(node, lazy) {
    const isLeaf = this.isLeaf(node, lazy);
    if (isLeaf) {
      return false;
    }
    const { children } = node;
    return Array.isArray(children) && Boolean(children.length);
  }
}
const { create: create$1$6 } = createComponent("cascader-item");
const _sfc_main$1$7 = create$1$6({
  components: {
    Loading: u,
    Checklist: k,
    NutTabs,
    NutTabPane
  },
  props: {
    visible: Boolean,
    modelValue: Array,
    options: {
      type: Array,
      default: () => []
    },
    lazy: Boolean,
    lazyLoad: Function,
    valueKey: {
      type: String,
      default: "value"
    },
    textKey: {
      type: String,
      default: "text"
    },
    childrenKey: {
      type: String,
      default: "children"
    },
    convertConfig: Object
  },
  emits: ["update:modelValue", "change", "pathChange"],
  setup(props, { emit: emit2 }) {
    const translate = useLocale();
    const configs = computed(() => ({
      lazy: props.lazy,
      lazyLoad: props.lazyLoad,
      valueKey: props.valueKey,
      textKey: props.textKey,
      childrenKey: props.childrenKey,
      convertConfig: props.convertConfig
    }));
    const tabsCursor = ref(0);
    const initLoading = ref(false);
    const innerValue = ref(props.modelValue);
    const tree = ref(new Tree([], {}));
    const panes = ref([]);
    const isLazy = computed(() => configs.value.lazy && Boolean(configs.value.lazyLoad));
    const lazyLoadMap = /* @__PURE__ */ new Map();
    let currentProcessNode;
    const init = () => __async$2(this, null, function* () {
      lazyLoadMap.clear();
      panes.value = [];
      tabsCursor.value = 0;
      initLoading.value = false;
      currentProcessNode = null;
      let { options } = props;
      if (configs.value.convertConfig) {
        options = convertListToOptions(options, configs.value.convertConfig);
      }
      tree.value = new Tree(options, {
        value: configs.value.valueKey,
        text: configs.value.textKey,
        children: configs.value.childrenKey
      });
      if (isLazy.value && !tree.value.nodes.length) {
        yield invokeLazyLoad({
          root: true,
          loading: true,
          text: "",
          value: ""
        });
      }
      panes.value = [{ nodes: tree.value.nodes, selectedNode: null }];
      syncValue();
    });
    const syncValue = () => __async$2(this, null, function* () {
      const currentValue = innerValue.value;
      if (currentValue === void 0 || !tree.value.nodes.length) {
        return;
      }
      if (currentValue.length === 0) {
        tabsCursor.value = 0;
        panes.value = [{ nodes: tree.value.nodes, selectedNode: null }];
        return;
      }
      let needToSync = currentValue;
      if (isLazy.value && Array.isArray(currentValue) && currentValue.length) {
        needToSync = [];
        let parent = tree.value.nodes.find((node) => node.value === currentValue[0]);
        if (parent) {
          needToSync = [parent.value];
          initLoading.value = true;
          const last = yield currentValue.slice(1).reduce((p2, value) => __async$2(this, null, function* () {
            var _a2;
            const parent2 = yield p2;
            yield invokeLazyLoad(parent2);
            const node = (_a2 = parent2 == null ? void 0 : parent2.children) == null ? void 0 : _a2.find((item) => item.value === value);
            if (node) {
              needToSync.push(value);
            }
            return Promise.resolve(node);
          }), Promise.resolve(parent));
          yield invokeLazyLoad(last);
          initLoading.value = false;
        }
      }
      if (needToSync.length && currentValue === props.modelValue) {
        const pathNodes = tree.value.getPathNodesByValue(needToSync);
        pathNodes.map((node, index2) => {
          tabsCursor.value = index2;
          methods.handleNode(node, true);
        });
      }
    });
    const invokeLazyLoad = (node) => __async$2(this, null, function* () {
      if (!node) {
        return;
      }
      if (!configs.value.lazyLoad) {
        node.leaf = true;
        return;
      }
      if (tree.value.isLeaf(node, isLazy.value) || tree.value.hasChildren(node, isLazy.value)) {
        return;
      }
      node.loading = true;
      const parent = node.root ? null : node;
      let lazyLoadPromise = lazyLoadMap.get(node);
      if (!lazyLoadPromise) {
        lazyLoadPromise = new Promise((resolve2) => {
          var _a2, _b;
          (_b = (_a2 = configs.value).lazyLoad) == null ? void 0 : _b.call(_a2, node, resolve2);
        });
        lazyLoadMap.set(node, lazyLoadPromise);
      }
      const nodes = yield lazyLoadPromise;
      if (Array.isArray(nodes) && nodes.length > 0) {
        tree.value.updateChildren(nodes, parent);
      } else {
        node.leaf = true;
      }
      node.loading = false;
      lazyLoadMap.delete(node);
    });
    const emitChange = (pathNodes) => {
      const emitValue = pathNodes.map((node) => node.value);
      innerValue.value = emitValue;
      emit2("change", emitValue, pathNodes);
      emit2("update:modelValue", emitValue, pathNodes);
    };
    const methods = {
      // 选中一个节点，静默模式不触发事件
      handleNode(node, silent) {
        return __async$2(this, null, function* () {
          const { disabled, loading } = node;
          if (!silent && disabled || !panes.value[tabsCursor.value]) {
            return;
          }
          if (tree.value.isLeaf(node, isLazy.value)) {
            node.leaf = true;
            panes.value[tabsCursor.value].selectedNode = node;
            panes.value = panes.value.slice(0, node.level + 1);
            if (!silent) {
              const pathNodes = panes.value.map((pane) => pane.selectedNode);
              emitChange(pathNodes);
              emit2("pathChange", pathNodes);
            }
            return;
          }
          if (tree.value.hasChildren(node, isLazy.value)) {
            const level = node.level + 1;
            panes.value[tabsCursor.value].selectedNode = node;
            panes.value = panes.value.slice(0, level);
            panes.value.push({
              nodes: node.children || [],
              selectedNode: null
            });
            tabsCursor.value = level;
            if (!silent) {
              const pathNodes = panes.value.map((pane) => pane.selectedNode);
              emit2("pathChange", pathNodes);
            }
            return;
          }
          currentProcessNode = node;
          if (loading) {
            return;
          }
          yield invokeLazyLoad(node);
          if (currentProcessNode === node) {
            panes.value[tabsCursor.value].selectedNode = node;
            methods.handleNode(node, silent);
          }
        });
      },
      handleTabClick(tab) {
        currentProcessNode = null;
        tabsCursor.value = Number(tab.paneKey);
      },
      formatTabTitle(pane) {
        return pane.selectedNode ? pane.selectedNode.text : translate("select");
      },
      isSelected(pane, node) {
        var _a2;
        return ((_a2 = pane == null ? void 0 : pane.selectedNode) == null ? void 0 : _a2.value) === node.value;
      }
    };
    watch(
      [configs, () => props.options],
      () => {
        init();
      },
      {
        deep: true,
        immediate: true
      }
    );
    watch(
      () => props.modelValue,
      (value) => {
        if (value !== innerValue.value) {
          innerValue.value = value;
          syncValue();
        }
      }
    );
    watch(
      () => props.visible,
      (val) => {
        if (val && Array.isArray(innerValue.value) && innerValue.value.length > 0) {
          syncValue();
        }
      }
    );
    return __spreadValues$O({ panes, initLoading, tabsCursor }, methods);
  }
});
const _hoisted_1$1$5 = {
  role: "menu",
  class: "nut-cascader-pane"
};
const _hoisted_2$I = ["aria-checked", "aria-disabled", "onClick"];
const _hoisted_3$B = { class: "nut-cascader-item__title" };
const _hoisted_4$w = /* @__PURE__ */ createBaseVNode("view", { class: "nut-cascader-pane" }, null, -1);
function _sfc_render$1$6(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Loading = resolveComponent("Loading");
  const _component_Checklist = resolveComponent("Checklist");
  const _component_nut_tab_pane = resolveComponent("nut-tab-pane");
  const _component_nut_tabs = resolveComponent("nut-tabs");
  return openBlock(), createBlock(_component_nut_tabs, {
    modelValue: _ctx.tabsCursor,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.tabsCursor = $event),
    class: "nut-cascader",
    "title-scroll": "",
    onClick: _ctx.handleTabClick
  }, {
    default: withCtx(() => [
      !_ctx.initLoading && _ctx.panes.length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.panes, (pane, index2) => {
        return openBlock(), createBlock(_component_nut_tab_pane, {
          key: index2,
          title: _ctx.formatTabTitle(pane)
        }, {
          default: withCtx(() => [
            createBaseVNode("view", _hoisted_1$1$5, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(pane.nodes, (node) => {
                return openBlock(), createElementBlock("view", {
                  key: node.value,
                  class: normalizeClass(["nut-cascader-item", { active: _ctx.isSelected(pane, node), disabled: node.disabled }]),
                  "aria-checked": _ctx.isSelected(pane, node),
                  "aria-disabled": node.disabled || void 0,
                  role: "menuitemradio",
                  onClick: ($event) => _ctx.handleNode(node, false)
                }, [
                  createBaseVNode("view", _hoisted_3$B, toDisplayString(node.text), 1),
                  node.loading ? (openBlock(), createBlock(_component_Loading, {
                    key: 0,
                    class: "nut-cascader-item__icon-loading",
                    name: "loading"
                  })) : (openBlock(), createBlock(_component_Checklist, {
                    key: 1,
                    class: "nut-cascader-item__icon-check",
                    name: "checklist"
                  }))
                ], 10, _hoisted_2$I);
              }), 128))
            ])
          ]),
          _: 2
        }, 1032, ["title"]);
      }), 128)) : (openBlock(), createBlock(_component_nut_tab_pane, {
        key: 1,
        title: "Loading..."
      }, {
        default: withCtx(() => [
          _hoisted_4$w
        ]),
        _: 1
      }))
    ]),
    _: 1
  }, 8, ["modelValue", "onClick"]);
}
const NutCascaderItem = /* @__PURE__ */ _export_sfc(_sfc_main$1$7, [["render", _sfc_render$1$6]]);
const { create: create$L } = createComponent("cascader");
const _sfc_main$1a = create$L({
  components: {
    NutCascaderItem,
    NutPopup
  },
  props: __spreadProps$O(__spreadValues$O({}, popupProps), {
    modelValue: Array,
    visible: Boolean,
    title: String,
    options: {
      type: Array,
      default: () => []
    },
    lazy: Boolean,
    lazyLoad: Function,
    valueKey: {
      type: String,
      default: "value"
    },
    textKey: {
      type: String,
      default: "text"
    },
    childrenKey: {
      type: String,
      default: "children"
    },
    poppable: {
      type: Boolean,
      default: true
    },
    convertConfig: Object
  }),
  emits: ["update:modelValue", "change", "pathChange", "update:visible"],
  setup(props, { emit: emit2 }) {
    const innerValue = ref(props.modelValue);
    const innerVisible = computed({
      get() {
        return props.visible;
      },
      set(value) {
        emit2("update:visible", value);
      }
    });
    const onChange = (value, pathNodes) => {
      innerValue.value = value;
      innerVisible.value = false;
      emit2("change", value, pathNodes);
      emit2("update:modelValue", value);
    };
    const onPathChange = (pathNodes) => {
      emit2("pathChange", pathNodes);
    };
    watch(
      () => props.modelValue,
      (value) => {
        if (value !== innerValue.value) {
          innerValue.value = value;
        }
      }
    );
    return {
      onChange,
      onPathChange,
      innerValue,
      innerVisible
    };
  }
});
const _hoisted_1$S = ["innerHTML"];
function _sfc_render$J(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_cascader_item = resolveComponent("nut-cascader-item");
  const _component_nut_popup = resolveComponent("nut-popup");
  return _ctx.poppable ? (openBlock(), createBlock(_component_nut_popup, {
    key: 0,
    visible: _ctx.innerVisible,
    "onUpdate:visible": _cache[0] || (_cache[0] = ($event) => _ctx.innerVisible = $event),
    position: "bottom",
    "pop-class": "nut-cascader__popup",
    round: "",
    "lock-scroll": _ctx.lockScroll,
    teleport: _ctx.teleport,
    "teleport-disable": _ctx.teleportDisable,
    closeable: _ctx.closeable,
    "destroy-on-close": false,
    "close-icon-position": _ctx.closeIconPosition,
    "z-index": _ctx.zIndex
  }, {
    default: withCtx(() => [
      _ctx.title ? (openBlock(), createElementBlock("view", {
        key: 0,
        class: "nut-cascader__bar",
        innerHTML: _ctx.title
      }, null, 8, _hoisted_1$S)) : createCommentVNode("", true),
      createVNode(_component_nut_cascader_item, {
        "model-value": _ctx.innerValue,
        options: _ctx.options,
        lazy: _ctx.lazy,
        "lazy-load": _ctx.lazyLoad,
        "value-key": _ctx.valueKey,
        "text-key": _ctx.textKey,
        "children-key": _ctx.childrenKey,
        "convert-config": _ctx.convertConfig,
        visible: _ctx.innerVisible,
        onChange: _ctx.onChange,
        onPathChange: _ctx.onPathChange
      }, null, 8, ["model-value", "options", "lazy", "lazy-load", "value-key", "text-key", "children-key", "convert-config", "visible", "onChange", "onPathChange"])
    ]),
    _: 1
  }, 8, ["visible", "lock-scroll", "teleport", "teleport-disable", "closeable", "close-icon-position", "z-index"])) : (openBlock(), createBlock(_component_nut_cascader_item, {
    key: 1,
    "model-value": _ctx.innerValue,
    options: _ctx.options,
    lazy: _ctx.lazy,
    "lazy-load": _ctx.lazyLoad,
    "value-key": _ctx.valueKey,
    "text-key": _ctx.textKey,
    "children-key": _ctx.childrenKey,
    "convert-config": _ctx.convertConfig,
    visible: _ctx.innerVisible,
    onChange: _ctx.onChange,
    onPathChange: _ctx.onPathChange
  }, null, 8, ["model-value", "options", "lazy", "lazy-load", "value-key", "text-key", "children-key", "convert-config", "visible", "onChange", "onPathChange"]));
}
const index$w = /* @__PURE__ */ _export_sfc(_sfc_main$1a, [["render", _sfc_render$J]]);
const Utils = {
  /**
   * 是否为闫年
   * @return {Boolse} true|false
   */
  isLeapYear: function(y2) {
    return y2 % 4 == 0 && y2 % 100 != 0 || y2 % 400 == 0;
  },
  /**
   * 返回星期数
   * @return {String}
   */
  getWhatDay: function(year, month, day) {
    const date = /* @__PURE__ */ new Date(year + "/" + month + "/" + day);
    const index2 = date.getDay();
    const dayNames = ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"];
    return dayNames[index2];
  },
  /**
   * 返回星期数
   * @return {Number}
   */
  getMonthPreDay: function(year, month) {
    const date = /* @__PURE__ */ new Date(year + "/" + month + "/01");
    let day = date.getDay();
    if (day == 0) {
      day = 7;
    }
    return day;
  },
  /**
   * 返回月份天数
   * @return {Number}
   */
  getMonthDays: function(year, month) {
    if (/^0/.test(month)) {
      month = month.split("")[1];
    }
    return [0, 31, this.isLeapYear(Number(year)) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
  },
  /**
   * 补齐数字位数
   * @return {string}
   */
  getNumTwoBit: function(n) {
    n = Number(n);
    return (n > 9 ? "" : "0") + n;
  },
  /**
   * 日期对象转成字符串
   * @return {string}
   */
  date2Str: function(date, split) {
    split = split || "-";
    const y2 = date.getFullYear();
    const m2 = this.getNumTwoBit(date.getMonth() + 1);
    const d2 = this.getNumTwoBit(date.getDate());
    return [y2, m2, d2].join(split);
  },
  /**
   * 返回日期格式字符串
   * @param {Number} 0返回今天的日期、1返回明天的日期，2返回后天得日期，依次类推
   * @return {string} '2014-12-31'
   */
  getDay: function(i2) {
    i2 = i2 || 0;
    let date = /* @__PURE__ */ new Date();
    const diff = i2 * (1e3 * 60 * 60 * 24);
    date = new Date(date.getTime() + diff);
    return this.date2Str(date);
  },
  /**
   * 时间比较
   * @return {Boolean}
   */
  compareDate: function(date1, date2) {
    const startTime = new Date(date1.replace("-", "/").replace("-", "/"));
    const endTime = new Date(date2.replace("-", "/").replace("-", "/"));
    if (startTime >= endTime) {
      return false;
    }
    return true;
  },
  /**
   * 时间是否相等
   * @return {Boolean}
   */
  isEqual: function(date1, date2) {
    const startTime = new Date(date1).getTime();
    const endTime = new Date(date2).getTime();
    if (startTime == endTime) {
      return true;
    }
    return false;
  },
  getMonthWeek: function(year, month, date, firstDayOfWeek = 0) {
    const dateNow = new Date(Number(year), parseInt(month) - 1, Number(date));
    let w2 = dateNow.getDay();
    const d2 = dateNow.getDate();
    let remainder = 6 - w2;
    if (firstDayOfWeek !== 0) {
      w2 = w2 == 0 ? 7 : w2;
      remainder = 7 - w2;
    }
    return Math.ceil((d2 + remainder) / 7);
  },
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getYearWeek: function(year, month, date, firstDayOfWeek = 0) {
    const dateNow = new Date(Number(year), parseInt(month) - 1, Number(date));
    const dateFirst = new Date(Number(year), 0, 1);
    const dataNumber = Math.round((dateNow.valueOf() - dateFirst.valueOf()) / 864e5);
    return Math.ceil((dataNumber + (dateFirst.getDay() + 1 - 1)) / 7);
  },
  getWeekDate: function(year, month, date, firstDayOfWeek = 0) {
    const dateNow = new Date(Number(year), parseInt(month) - 1, Number(date));
    const nowTime = dateNow.getTime();
    let day = dateNow.getDay();
    if (firstDayOfWeek === 0) {
      const oneDayTime = 24 * 60 * 60 * 1e3;
      const SundayTime = nowTime - day * oneDayTime;
      const SaturdayTime = nowTime + (6 - day) * oneDayTime;
      const sunday = this.date2Str(new Date(SundayTime));
      const saturday = this.date2Str(new Date(SaturdayTime));
      return [sunday, saturday];
    } else {
      day = day == 0 ? 7 : day;
      const oneDayTime = 24 * 60 * 60 * 1e3;
      const MondayTime = nowTime - (day - 1) * oneDayTime;
      const SundayTime = nowTime + (7 - day) * oneDayTime;
      const monday = this.date2Str(new Date(MondayTime));
      const sunday = this.date2Str(new Date(SundayTime));
      return [monday, sunday];
    }
  },
  formatResultDate: function(date) {
    const days = [...date.split("-")];
    days[2] = Utils.getNumTwoBit(Number(days[2]));
    days[3] = `${days[0]}-${days[1]}-${days[2]}`;
    days[4] = Utils.getWhatDay(+days[0], +days[1], +days[2]);
    return days;
  }
};
var __defProp$O = Object.defineProperty;
var __defProps$N = Object.defineProperties;
var __getOwnPropDescs$N = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$N = Object.getOwnPropertySymbols;
var __hasOwnProp$N = Object.prototype.hasOwnProperty;
var __propIsEnum$N = Object.prototype.propertyIsEnumerable;
var __defNormalProp$O = (obj, key, value) => key in obj ? __defProp$O(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$N = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$N.call(b, prop))
      __defNormalProp$O(a2, prop, b[prop]);
  if (__getOwnPropSymbols$N)
    for (var prop of __getOwnPropSymbols$N(b)) {
      if (__propIsEnum$N.call(b, prop))
        __defNormalProp$O(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$N = (a2, b) => __defProps$N(a2, __getOwnPropDescs$N(b));
const { create: create$1$5 } = createComponent("calendar-item");
const cN$l = "NutCalendarItem";
const _sfc_main$1$6 = create$1$5({
  props: {
    type: {
      type: String,
      default: "one"
    },
    isAutoBackFill: {
      type: Boolean,
      default: false
    },
    toDateAnimation: {
      type: Boolean,
      default: true
    },
    poppable: {
      type: Boolean,
      default: true
    },
    showTitle: {
      type: Boolean,
      default: true
    },
    showSubTitle: {
      type: Boolean,
      default: true
    },
    showToday: {
      type: Boolean,
      default: true
    },
    title: {
      type: String,
      default: ""
    },
    confirmText: {
      type: String,
      default: ""
    },
    startText: {
      type: String,
      default: ""
    },
    endText: {
      type: String,
      default: ""
    },
    defaultValue: {
      type: [String, Array],
      default: ""
    },
    startDate: {
      type: String,
      default: Utils.getDay(0)
    },
    endDate: {
      type: String,
      default: Utils.getDay(365)
    },
    firstDayOfWeek: {
      type: Number,
      default: 0
    },
    disabledDate: Function
  },
  emits: ["choose", "update", "close", "select"],
  setup(props, { emit: emit2, slots, expose }) {
    const translate = useLocale(cN$l);
    const weekdays = translate("weekdays").map((day, index2) => ({
      day,
      weekend: index2 === 0 || index2 === 6
    }));
    const weeks = ref([...weekdays.slice(props.firstDayOfWeek, 7), ...weekdays.slice(0, props.firstDayOfWeek)]);
    const months = ref(null);
    const monthsPanel = ref(null);
    const weeksPanel = ref(null);
    const viewArea = ref(null);
    const viewHeight = ref(0);
    const compConthsData = computed(() => {
      return state.monthsData.slice(state.defaultRange[0], state.defaultRange[1]);
    });
    const showTopBtn = computed(() => {
      return slots.btn;
    });
    const topInfo = computed(() => {
      return slots["top-info"];
    });
    const bottomInfo = computed(() => {
      return slots["bottom-info"];
    });
    const state = reactive({
      yearMonthTitle: "",
      defaultRange: [],
      currDate: "",
      propStartDate: "",
      propEndDate: "",
      unLoadPrev: false,
      touchParams: {
        startY: 0,
        endY: 0,
        startTime: 0,
        endTime: 0,
        lastY: 0,
        lastTime: 0
      },
      transformY: 0,
      translateY: 0,
      scrollDistance: 0,
      defaultData: [],
      chooseData: [],
      monthsData: [],
      dayPrefix: "nut-calendar__day",
      startData: "",
      endData: "",
      isRange: props.type === "range",
      timer: 0,
      currentIndex: 0,
      avgHeight: 0,
      monthsNum: 0
    });
    const splitDate = (date) => {
      return date.split("-");
    };
    const isStart = (currDate) => {
      return Utils.isEqual(state.currDate[0], currDate);
    };
    const isEnd = (currDate) => {
      return Utils.isEqual(state.currDate[1], currDate);
    };
    const isMultiple = (currDate) => {
      var _a, _b;
      if (((_a = state.currDate) == null ? void 0 : _a.length) > 0) {
        return (_b = state.currDate) == null ? void 0 : _b.some((item) => {
          return Utils.isEqual(item, currDate);
        });
      } else {
        return false;
      }
    };
    const getCurrDate = (day, month) => {
      return month.curData[0] + "-" + month.curData[1] + "-" + Utils.getNumTwoBit(+day.day);
    };
    const getClass = (day, month, index2) => {
      const res = [];
      if (typeof index2 === "number" && ((index2 + 1 + props.firstDayOfWeek) % 7 === 0 || (index2 + props.firstDayOfWeek) % 7 === 0)) {
        res.push("weekend");
      }
      const currDate = getCurrDate(day, month);
      const { type } = props;
      if (day.type == "curr") {
        if (Utils.isEqual(state.currDate, currDate) || (type == "range" || type == "week") && (isStart(currDate) || isEnd(currDate)) || type == "multiple" && isMultiple(currDate)) {
          res.push(`${state.dayPrefix}--active`);
        } else if (state.propStartDate && Utils.compareDate(currDate, state.propStartDate) || state.propEndDate && Utils.compareDate(state.propEndDate, currDate) || props.disabledDate && props.disabledDate(currDate)) {
          res.push(`${state.dayPrefix}--disabled`);
        } else if ((type == "range" || type == "week") && Array.isArray(state.currDate) && Object.values(state.currDate).length == 2 && Utils.compareDate(state.currDate[0], currDate) && Utils.compareDate(currDate, state.currDate[1])) {
          res.push(`${state.dayPrefix}--choose`);
        }
      } else {
        res.push(`${state.dayPrefix}--disabled`);
      }
      return res;
    };
    const confirm = () => {
      const { type } = props;
      if (type == "range" && state.chooseData.length == 2 || type != "range") {
        let selectData = state.chooseData.slice(0);
        if (type == "week") {
          if (state.chooseData.length !== 2) {
            return;
          }
          selectData = {
            weekDate: [handleWeekDate(state.chooseData[0]), handleWeekDate(state.chooseData[1])]
          };
        }
        emit2("choose", selectData);
        if (props.poppable) {
          emit2("update");
        }
      }
    };
    const chooseDay = (day, month, isFirst = false) => {
      var _a, _b;
      if (!getClass(day, month).includes(`${state.dayPrefix}--disabled`)) {
        const { type } = props;
        let [y2, m2] = month.curData;
        let days = [...month.curData];
        days[2] = Utils.getNumTwoBit(Number(day.day));
        days[3] = `${days[0]}-${days[1]}-${days[2]}`;
        days[4] = Utils.getWhatDay(+days[0], +days[1], +days[2]);
        if (type == "multiple") {
          if (((_a = state.currDate) == null ? void 0 : _a.length) > 0) {
            let hasIndex = void 0;
            (_b = state.currDate) == null ? void 0 : _b.forEach((item, index2) => {
              if (item == days[3]) {
                hasIndex = index2;
              }
            });
            if (isFirst) {
              state.chooseData.push([...days]);
            } else {
              if (hasIndex !== void 0) {
                state.currDate.splice(hasIndex, 1);
                state.chooseData.splice(hasIndex, 1);
              } else {
                state.currDate.push(days[3]);
                state.chooseData.push([...days]);
              }
            }
          } else {
            state.currDate = [days[3]];
            state.chooseData = [[...days]];
          }
        } else if (type == "range") {
          let curDataLength = Object.values(state.currDate).length;
          if (curDataLength == 2 || curDataLength == 0) {
            state.currDate = [days[3]];
          } else {
            if (Utils.compareDate(state.currDate[0], days[3])) {
              Array.isArray(state.currDate) && state.currDate.push(days[3]);
            } else {
              Array.isArray(state.currDate) && state.currDate.unshift(days[3]);
            }
          }
          if (state.chooseData.length == 2 || !state.chooseData.length) {
            state.chooseData = [[...days]];
          } else {
            if (Utils.compareDate(state.chooseData[0][3], days[3])) {
              state.chooseData = [...state.chooseData, [...days]];
            } else {
              state.chooseData = [[...days], ...state.chooseData];
            }
          }
        } else if (type == "week") {
          let weekArr = Utils.getWeekDate(y2, m2, day.day, props.firstDayOfWeek);
          if (state.propStartDate && Utils.compareDate(weekArr[0], state.propStartDate)) {
            weekArr.splice(0, 1, state.propStartDate);
          }
          if (state.propEndDate && Utils.compareDate(state.propEndDate, weekArr[1])) {
            weekArr.splice(1, 1, state.propEndDate);
          }
          state.currDate = weekArr;
          state.chooseData = [Utils.formatResultDate(weekArr[0]), Utils.formatResultDate(weekArr[1])];
        } else {
          state.currDate = days[3];
          state.chooseData = [...days];
        }
        if (!isFirst) {
          let selectData = state.chooseData;
          if (type == "week") {
            selectData = {
              weekDate: [
                handleWeekDate(state.chooseData[0]),
                handleWeekDate(state.chooseData[1])
              ]
            };
          }
          emit2("select", selectData);
          if (props.isAutoBackFill || !props.poppable) {
            confirm();
          }
        }
      }
    };
    const handleWeekDate = (weekDate) => {
      let [y2, m2, d2] = weekDate;
      let obj = {
        date: weekDate,
        monthWeekNum: Utils.getMonthWeek(y2, m2, d2, props.firstDayOfWeek),
        yearWeekNum: Utils.getYearWeek(y2, m2, d2, props.firstDayOfWeek)
      };
      return obj;
    };
    const getCurrData = (type) => {
      const monthData = state.monthsData[state.monthsData.length - 1];
      let year = parseInt(monthData.curData[0]);
      let month = parseInt(monthData.curData[1].toString().replace(/^0/, ""));
      switch (type) {
        case "prev":
          month == 1 && (year -= 1);
          month = month == 1 ? 12 : --month;
          break;
        case "next":
          month == 12 && (year += 1);
          month = month == 12 ? 1 : ++month;
          break;
      }
      return [year + "", Utils.getNumTwoBit(month), Utils.getMonthDays(String(year), String(month)) + ""];
    };
    const getDaysStatus = (days, type, dateInfo) => {
      let { year, month } = dateInfo;
      return Array.from(Array(days), (v2, k2) => {
        return {
          day: String(k2 + 1),
          type,
          year,
          month
        };
      });
    };
    const getPreDaysStatus = (days, type, dateInfo, preCurrMonthDays) => {
      days = days - props.firstDayOfWeek;
      let { year, month } = dateInfo;
      if (days >= 7) {
        days -= 7;
      }
      let months2 = Array.from(Array(preCurrMonthDays), (v2, k2) => {
        return {
          day: String(k2 + 1),
          type,
          year,
          month
        };
      });
      return months2.slice(preCurrMonthDays - days);
    };
    const getMonth = (curData, type) => {
      const preMonthDays = Utils.getMonthPreDay(+curData[0], +curData[1]);
      let preMonth = Number(curData[1]) - 1;
      let preYear = Number(curData[0]);
      if (preMonth <= 0) {
        preMonth = 12;
        preYear += 1;
      }
      const currMonthDays = Utils.getMonthDays(String(curData[0]), String(curData[1]));
      const preCurrMonthDays = Utils.getMonthDays(preYear + "", preMonth + "");
      const title = {
        year: curData[0],
        month: curData[1]
      };
      const monthInfo = {
        curData,
        title: translate("monthTitle", title.year, title.month),
        monthData: [
          ...getPreDaysStatus(
            preMonthDays,
            "prev",
            { month: String(preMonth), year: String(preYear) },
            preCurrMonthDays
          ),
          ...getDaysStatus(currMonthDays, "curr", title)
        ],
        cssHeight: 0,
        cssScrollHeight: 0
      };
      monthInfo.cssHeight = 39 + (monthInfo.monthData.length > 35 ? 384 : 320);
      let cssScrollHeight = 0;
      if (state.monthsData.length > 0) {
        cssScrollHeight = state.monthsData[state.monthsData.length - 1].cssScrollHeight + state.monthsData[state.monthsData.length - 1].cssHeight;
      }
      monthInfo.cssScrollHeight = cssScrollHeight;
      {
        if (!state.endData || !Utils.compareDate(
          `${state.endData[0]}-${state.endData[1]}-${Utils.getMonthDays(state.endData[0], state.endData[1])}`,
          `${curData[0]}-${curData[1]}-${curData[2]}`
        )) {
          state.monthsData.push(monthInfo);
        }
      }
    };
    const initData = () => {
      let propStartDate = props.startDate ? props.startDate : Utils.getDay(0);
      let propEndDate = props.endDate ? props.endDate : Utils.getDay(365);
      state.propStartDate = propStartDate;
      state.propEndDate = propEndDate;
      state.startData = splitDate(propStartDate);
      state.endData = splitDate(propEndDate);
      if (props.defaultValue || Array.isArray(props.defaultValue) && props.defaultValue.length > 0) {
        state.currDate = props.type !== "one" ? [...props.defaultValue] : props.defaultValue;
      }
      const startDate = {
        year: Number(state.startData[0]),
        month: Number(state.startData[1])
      };
      const endDate = {
        year: Number(state.endData[0]),
        month: Number(state.endData[1])
      };
      let monthsNum = endDate.month - startDate.month;
      if (endDate.year - startDate.year > 0) {
        monthsNum = monthsNum + 12 * (endDate.year - startDate.year);
      }
      if (monthsNum <= 0) {
        monthsNum = 1;
      }
      getMonth(state.startData);
      let i2 = 1;
      do {
        getMonth(getCurrData("next"));
      } while (i2++ < monthsNum);
      state.monthsNum = monthsNum;
      if (props.type == "range" && Array.isArray(state.currDate)) {
        if (state.currDate.length > 0) {
          if (propStartDate && Utils.compareDate(state.currDate[0], propStartDate)) {
            state.currDate.splice(0, 1, propStartDate);
          }
          if (propEndDate && Utils.compareDate(propEndDate, state.currDate[1])) {
            state.currDate.splice(1, 1, propEndDate);
          }
          state.defaultData = [...splitDate(state.currDate[0]), ...splitDate(state.currDate[1])];
        }
      } else if (props.type == "multiple" && Array.isArray(state.currDate)) {
        if (state.currDate.length > 0) {
          let defaultArr = [];
          let obj = {};
          state.currDate.forEach((item) => {
            if (propStartDate && !Utils.compareDate(item, propStartDate) && propEndDate && !Utils.compareDate(propEndDate, item)) {
              if (!Object.hasOwnProperty.call(obj, item)) {
                defaultArr.push(item);
                obj[item] = item;
              }
            }
          });
          state.currDate = [...defaultArr];
          state.defaultData = [...splitDate(defaultArr[0])];
        }
      } else if (props.type == "week" && Array.isArray(state.currDate)) {
        if (state.currDate.length > 0) {
          let [y2, m2, d2] = splitDate(state.currDate[0]);
          let weekArr = Utils.getWeekDate(y2, m2, d2, props.firstDayOfWeek);
          state.currDate = weekArr;
          if (propStartDate && Utils.compareDate(state.currDate[0], propStartDate)) {
            state.currDate.splice(0, 1, propStartDate);
          }
          if (propEndDate && Utils.compareDate(propEndDate, state.currDate[1])) {
            state.currDate.splice(1, 1, propEndDate);
          }
          state.defaultData = [...splitDate(state.currDate[0]), ...splitDate(state.currDate[1])];
        }
      } else {
        if (state.currDate) {
          if (propStartDate && Utils.compareDate(state.currDate, propStartDate)) {
            state.currDate = propStartDate;
          } else if (propEndDate && !Utils.compareDate(state.currDate, propEndDate)) {
            state.currDate = propEndDate;
          }
          state.defaultData = [...splitDate(state.currDate)];
        }
      }
      let current = 0;
      let lastCurrent = 0;
      if (state.defaultData.length > 0) {
        state.monthsData.forEach((item, index2) => {
          if (item.title == translate("monthTitle", state.defaultData[0], state.defaultData[1])) {
            current = index2;
          }
          if (props.type == "range" || props.type == "week") {
            if (item.title == translate("monthTitle", state.defaultData[3], state.defaultData[4])) {
              lastCurrent = index2;
            }
          }
        });
      }
      setDefaultRange(monthsNum, current);
      state.currentIndex = current;
      state.yearMonthTitle = state.monthsData[state.currentIndex].title;
      if (state.defaultData.length > 0) {
        if (state.isRange) {
          chooseDay({ day: state.defaultData[2], type: "curr" }, state.monthsData[state.currentIndex], true);
          chooseDay({ day: state.defaultData[5], type: "curr" }, state.monthsData[lastCurrent], true);
        } else if (props.type == "week") {
          chooseDay({ day: state.defaultData[2], type: "curr" }, state.monthsData[state.currentIndex], true);
        } else if (props.type == "multiple") {
          [...state.currDate].forEach((item) => {
            let dateArr = splitDate(item);
            let current2 = state.currentIndex;
            state.monthsData.forEach((item2, index2) => {
              if (item2.title == translate("monthTitle", dateArr[0], dateArr[1])) {
                current2 = index2;
              }
            });
            chooseDay({ day: dateArr[2], type: "curr" }, state.monthsData[current2], true);
          });
        } else {
          chooseDay({ day: state.defaultData[2], type: "curr" }, state.monthsData[state.currentIndex], true);
        }
      }
      let lastItem = state.monthsData[state.monthsData.length - 1];
      let containerHeight = lastItem.cssHeight + lastItem.cssScrollHeight;
      requestAniFrame$1(() => {
        if ((months == null ? void 0 : months.value) && (monthsPanel == null ? void 0 : monthsPanel.value) && (viewArea == null ? void 0 : viewArea.value)) {
          viewHeight.value = months.value.clientHeight;
          monthsPanel.value.style.height = `${containerHeight}px`;
          months.value.scrollTop = state.monthsData[state.currentIndex].cssScrollHeight;
        }
      });
      state.avgHeight = Math.floor(containerHeight / (monthsNum + 1));
    };
    const scrollToDate = (date) => {
      if (Utils.compareDate(date, state.propStartDate)) {
        date = state.propStartDate;
      } else if (!Utils.compareDate(date, state.propEndDate)) {
        date = state.propEndDate;
      }
      let dateArr = splitDate(date);
      state.monthsData.forEach((item, index2) => {
        if (item.title == translate("monthTitle", dateArr[0], dateArr[1])) {
          if (months.value) {
            let distance = state.monthsData[index2].cssScrollHeight - months.value.scrollTop;
            if (props.toDateAnimation) {
              let flag = 0;
              let interval = setInterval(() => {
                flag++;
                if (months.value) {
                  let offset = distance / 10;
                  months.value.scrollTop = months.value.scrollTop + offset;
                }
                if (flag >= 10) {
                  clearInterval(interval);
                  if (months.value) {
                    months.value.scrollTop = state.monthsData[index2].cssScrollHeight;
                  }
                }
              }, 40);
            } else {
              months.value.scrollTop = state.monthsData[index2].cssScrollHeight;
            }
          }
        }
      });
    };
    const initPosition = () => {
      if (months == null ? void 0 : months.value) {
        months.value.scrollTop = state.monthsData[state.currentIndex].cssScrollHeight;
      }
    };
    expose({
      scrollToDate,
      initPosition
    });
    const setDefaultRange = (monthsNum, current) => {
      if (monthsNum >= 3) {
        if (current > 0 && current < monthsNum) {
          state.defaultRange = [current - 1, current + 3];
        } else if (current == 0) {
          state.defaultRange = [current, current + 4];
        } else if (current == monthsNum) {
          state.defaultRange = [current - 2, current + 2];
        }
      } else {
        state.defaultRange = [0, monthsNum + 2];
      }
      let defaultScrollTop = state.monthsData[state.defaultRange[0]].cssScrollHeight;
      state.translateY = defaultScrollTop;
    };
    const isActive = (day, month) => {
      return (props.type == "range" || props.type == "week") && day.type == "curr" && getClass(day, month).includes("nut-calendar__day--active");
    };
    const isStartTip = (day, month) => {
      return isActive(day, month) && isStart(getCurrDate(day, month));
    };
    const isEndTip = (day, month) => {
      if (state.currDate.length >= 2 && isEnd(getCurrDate(day, month))) {
        return isActive(day, month);
      }
      return false;
    };
    const rangeTip = () => {
      if (state.currDate.length >= 2) {
        return Utils.isEqual(state.currDate[0], state.currDate[1]);
      }
    };
    const isCurrDay = (dateInfo) => {
      const date = `${dateInfo.year}-${dateInfo.month}-${Number(dateInfo.day) < 10 ? "0" + dateInfo.day : dateInfo.day}`;
      return Utils.isEqual(date, Utils.date2Str(/* @__PURE__ */ new Date()));
    };
    const mothsViewScroll = (e) => {
      if (state.monthsData.length <= 1) {
        return;
      }
      const currentScrollTop = e.target.scrollTop;
      let current = Math.floor(currentScrollTop / state.avgHeight);
      if (current == 0) {
        if (currentScrollTop >= state.monthsData[current + 1].cssScrollHeight) {
          current += 1;
        }
      } else if (current > 0 && current < state.monthsNum - 1) {
        if (currentScrollTop >= state.monthsData[current + 1].cssScrollHeight) {
          current += 1;
        }
        if (currentScrollTop < state.monthsData[current].cssScrollHeight) {
          current -= 1;
        }
      } else {
        const viewPosition = Math.round(currentScrollTop + viewHeight.value);
        if (viewPosition < state.monthsData[current].cssScrollHeight + state.monthsData[current].cssHeight && currentScrollTop > state.monthsData[current - 1].cssScrollHeight) {
          current -= 1;
        }
        if (current + 1 <= state.monthsNum && viewPosition >= state.monthsData[current + 1].cssScrollHeight + state.monthsData[current + 1].cssHeight) {
          current += 1;
        }
        if (current >= 1 && currentScrollTop < state.monthsData[current - 1].cssScrollHeight) {
          current -= 1;
        }
      }
      if (state.currentIndex !== current) {
        state.currentIndex = current;
        setDefaultRange(state.monthsNum, current);
      }
      state.yearMonthTitle = state.monthsData[current].title;
    };
    const resetRender = () => {
      state.chooseData.splice(0);
      state.monthsData.splice(0);
      initData();
    };
    onMounted(() => {
      initData();
    });
    watch(
      () => props.defaultValue,
      (val) => {
        if (val) {
          if (props.poppable) {
            resetRender();
          }
        }
      }
    );
    return __spreadProps$N(__spreadValues$N(__spreadValues$N({
      weeks,
      compConthsData,
      showTopBtn,
      topInfo,
      bottomInfo,
      rangeTip,
      mothsViewScroll,
      getClass,
      isStartTip,
      isEndTip,
      chooseDay,
      isCurrDay,
      confirm,
      months
    }, toRefs(state)), toRefs(props)), {
      translate,
      monthsPanel,
      weeksPanel,
      viewArea
    });
  }
});
const _hoisted_1$R = { class: "nut-calendar__header" };
const _hoisted_2$H = {
  key: 0,
  class: "nut-calendar__header-title"
};
const _hoisted_3$A = {
  key: 1,
  class: "nut-calendar__header-slot"
};
const _hoisted_4$v = {
  key: 2,
  class: "nut-calendar__header-subtitle"
};
const _hoisted_5$n = {
  ref: "weeksPanel",
  class: "nut-calendar__weekdays"
};
const _hoisted_6$m = {
  ref: "monthsPanel",
  class: "nut-calendar__panel"
};
const _hoisted_7$i = { class: "nut-calendar__month-title" };
const _hoisted_8$d = { class: "nut-calendar__days" };
const _hoisted_9$8 = ["onClick"];
const _hoisted_10$7 = { class: "nut-calendar__day-value" };
const _hoisted_11$6 = {
  key: 0,
  class: "nut-calendar__day-tips nut-calendar__day-tips--top"
};
const _hoisted_12$6 = {
  key: 1,
  class: "nut-calendar__day-tips nut-calendar__day-tips--bottom"
};
const _hoisted_13$4 = {
  key: 2,
  class: "nut-calendar__day-tips--curr"
};
const _hoisted_14$3 = {
  key: 4,
  class: "nut-calendar__day-tip"
};
const _hoisted_15$1 = {
  key: 0,
  class: "nut-calendar__footer"
};
function _sfc_render$1$5(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(["nut-calendar", {
      "nut-calendar--nopop": !_ctx.poppable,
      "nut-calendar--nofooter": _ctx.isAutoBackFill
    }])
  }, [
    createBaseVNode("view", _hoisted_1$R, [
      _ctx.showTitle ? (openBlock(), createElementBlock("view", _hoisted_2$H, toDisplayString(_ctx.title || _ctx.translate("title")), 1)) : createCommentVNode("", true),
      _ctx.showTopBtn ? (openBlock(), createElementBlock("view", _hoisted_3$A, [
        renderSlot(_ctx.$slots, "btn")
      ])) : createCommentVNode("", true),
      _ctx.showSubTitle ? (openBlock(), createElementBlock("view", _hoisted_4$v, toDisplayString(_ctx.yearMonthTitle), 1)) : createCommentVNode("", true),
      createBaseVNode("view", _hoisted_5$n, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.weeks, (item, index2) => {
          return openBlock(), createElementBlock("view", {
            key: index2,
            class: normalizeClass(["nut-calendar__weekday", { weekend: item.weekend }])
          }, toDisplayString(item.day), 3);
        }), 128))
      ], 512)
    ]),
    createBaseVNode("view", {
      ref: "months",
      class: "nut-calendar__content",
      onScroll: _cache[0] || (_cache[0] = (...args) => _ctx.mothsViewScroll && _ctx.mothsViewScroll(...args))
    }, [
      createBaseVNode("view", _hoisted_6$m, [
        createBaseVNode("view", {
          ref: "viewArea",
          class: "nut-calendar__body",
          style: normalizeStyle({ transform: `translateY(${_ctx.translateY}px)` })
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.compConthsData, (month, index2) => {
            return openBlock(), createElementBlock("view", {
              key: index2,
              class: "nut-calendar__month"
            }, [
              createBaseVNode("view", _hoisted_7$i, toDisplayString(month.title), 1),
              createBaseVNode("view", _hoisted_8$d, [
                createBaseVNode("view", {
                  class: normalizeClass(["nut-calendar__days-item", _ctx.type === "range" ? "nut-calendar__days-item--range" : ""])
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(month.monthData, (day, i2) => {
                    return openBlock(), createElementBlock("view", {
                      key: i2,
                      class: normalizeClass(["nut-calendar__day", _ctx.getClass(day, month, i2)]),
                      onClick: ($event) => _ctx.chooseDay(day, month)
                    }, [
                      createBaseVNode("view", _hoisted_10$7, [
                        renderSlot(_ctx.$slots, "day", {
                          date: day.type == "curr" ? day : ""
                        }, () => [
                          createTextVNode(toDisplayString(day.type == "curr" ? day.day : ""), 1)
                        ])
                      ]),
                      _ctx.topInfo ? (openBlock(), createElementBlock("view", _hoisted_11$6, [
                        renderSlot(_ctx.$slots, "top-info", {
                          date: day.type == "curr" ? day : ""
                        })
                      ])) : createCommentVNode("", true),
                      _ctx.bottomInfo ? (openBlock(), createElementBlock("view", _hoisted_12$6, [
                        renderSlot(_ctx.$slots, "bottom-info", {
                          date: day.type == "curr" ? day : ""
                        })
                      ])) : createCommentVNode("", true),
                      !_ctx.bottomInfo && _ctx.showToday && _ctx.isCurrDay(day) ? (openBlock(), createElementBlock("view", _hoisted_13$4, toDisplayString(_ctx.translate("today")), 1)) : createCommentVNode("", true),
                      _ctx.isStartTip(day, month) ? (openBlock(), createElementBlock("view", {
                        key: 3,
                        class: normalizeClass(["nut-calendar__day-tip", { "nut-calendar__day-tips--top": _ctx.rangeTip() }])
                      }, toDisplayString(_ctx.startText || _ctx.translate("start")), 3)) : createCommentVNode("", true),
                      _ctx.isEndTip(day, month) ? (openBlock(), createElementBlock("view", _hoisted_14$3, toDisplayString(_ctx.endText || _ctx.translate("end")), 1)) : createCommentVNode("", true)
                    ], 10, _hoisted_9$8);
                  }), 128))
                ], 2)
              ])
            ]);
          }), 128))
        ], 4)
      ], 512)
    ], 544),
    _ctx.poppable && !_ctx.isAutoBackFill ? (openBlock(), createElementBlock("view", _hoisted_15$1, [
      renderSlot(_ctx.$slots, "footer-info", { date: _ctx.chooseData }, () => [
        createBaseVNode("view", {
          class: "nut-calendar__confirm",
          onClick: _cache[1] || (_cache[1] = (...args) => _ctx.confirm && _ctx.confirm(...args))
        }, toDisplayString(_ctx.confirmText || _ctx.translate("confirm")), 1)
      ])
    ])) : createCommentVNode("", true)
  ], 2);
}
const NutCalendarItem = /* @__PURE__ */ _export_sfc(_sfc_main$1$6, [["render", _sfc_render$1$5]]);
const { create: create$K } = createComponent("calendar");
const _sfc_main$19 = create$K({
  components: {
    NutCalendarItem,
    NutPopup
  },
  props: {
    type: {
      type: String,
      default: "one"
    },
    isAutoBackFill: {
      type: Boolean,
      default: false
    },
    toDateAnimation: {
      type: Boolean,
      default: true
    },
    poppable: {
      type: Boolean,
      default: true
    },
    showTitle: {
      type: Boolean,
      default: true
    },
    showSubTitle: {
      type: Boolean,
      default: true
    },
    visible: {
      type: Boolean,
      default: false
    },
    showToday: {
      type: Boolean,
      default: true
    },
    title: {
      type: String,
      default: ""
    },
    confirmText: {
      type: String,
      default: ""
    },
    startText: {
      type: String,
      default: ""
    },
    endText: {
      type: String,
      default: ""
    },
    defaultValue: {
      type: [String, Array]
    },
    startDate: {
      type: String,
      default: Utils.getDay(0)
    },
    endDate: {
      type: String,
      default: Utils.getDay(365)
    },
    firstDayOfWeek: {
      type: Number,
      default: 0,
      validator: (val) => val >= 0 && val <= 6
    },
    lockScroll: {
      type: Boolean,
      default: true
    },
    disabledDate: Function
  },
  emits: ["choose", "close", "update:visible", "select"],
  setup(props, { emit: emit2, slots, expose }) {
    const visible = computed({
      get() {
        return props.visible;
      },
      set(val) {
        emit2("update:visible", val);
      }
    });
    const showTopBtn = computed(() => {
      return slots.btn;
    });
    const topInfo = computed(() => {
      return slots["top-info"];
    });
    const dayInfo = computed(() => {
      return slots.day;
    });
    const bottomInfo = computed(() => {
      return slots["bottom-info"];
    });
    const footerInfo = computed(() => {
      return slots["footer-info"];
    });
    const calendarRef = ref(null);
    const scrollToDate = (date) => {
      var _a;
      (_a = calendarRef.value) == null ? void 0 : _a.scrollToDate(date);
    };
    const initPosition = () => {
      var _a;
      (_a = calendarRef.value) == null ? void 0 : _a.initPosition();
    };
    expose({
      scrollToDate,
      initPosition
    });
    const update = () => {
      emit2("update:visible", false);
    };
    const close = () => {
      emit2("close");
      emit2("update:visible", false);
    };
    const choose = (param) => {
      close();
      emit2("choose", param);
    };
    const closePopup = () => {
      close();
    };
    const select = (param) => {
      emit2("select", param);
    };
    const opened = () => {
      var _a;
      (_a = calendarRef.value) == null ? void 0 : _a.initPosition();
    };
    return {
      visible,
      closePopup,
      opened,
      update,
      close,
      select,
      choose,
      calendarRef,
      showTopBtn,
      topInfo,
      dayInfo,
      bottomInfo,
      footerInfo
    };
  }
});
function _sfc_render$I(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_calendar_item = resolveComponent("nut-calendar-item");
  const _component_nut_popup = resolveComponent("nut-popup");
  return _ctx.poppable ? (openBlock(), createBlock(_component_nut_popup, mergeProps({
    key: 0,
    visible: _ctx.visible,
    "onUpdate:visible": _cache[0] || (_cache[0] = ($event) => _ctx.visible = $event),
    position: "bottom",
    round: "",
    closeable: ""
  }, _ctx.$attrs, {
    style: { height: "85vh" },
    "lock-scroll": _ctx.lockScroll,
    onOpened: _ctx.opened
  }), {
    default: withCtx(() => [
      createVNode(_component_nut_calendar_item, {
        ref: "calendarRef",
        type: _ctx.type,
        "is-auto-back-fill": _ctx.isAutoBackFill,
        poppable: _ctx.poppable,
        title: _ctx.title,
        "default-value": _ctx.defaultValue,
        "start-date": _ctx.startDate,
        "end-date": _ctx.endDate,
        "confirm-text": _ctx.confirmText,
        "start-text": _ctx.startText,
        "end-text": _ctx.endText,
        "show-today": _ctx.showToday,
        "show-title": _ctx.showTitle,
        "show-sub-title": _ctx.showSubTitle,
        "to-date-animation": _ctx.toDateAnimation,
        "first-day-of-week": _ctx.firstDayOfWeek,
        "disabled-date": _ctx.disabledDate,
        onUpdate: _ctx.update,
        onClose: _ctx.close,
        onChoose: _ctx.choose,
        onSelect: _ctx.select
      }, createSlots({ _: 2 }, [
        _ctx.showTopBtn ? {
          name: "btn",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "btn")
          ]),
          key: "0"
        } : void 0,
        _ctx.dayInfo ? {
          name: "day",
          fn: withCtx((date) => [
            renderSlot(_ctx.$slots, "day", {
              date: date.date
            })
          ]),
          key: "1"
        } : void 0,
        _ctx.topInfo ? {
          name: "top-info",
          fn: withCtx((date) => [
            renderSlot(_ctx.$slots, "top-info", {
              date: date.date
            })
          ]),
          key: "2"
        } : void 0,
        _ctx.bottomInfo ? {
          name: "bottom-info",
          fn: withCtx((date) => [
            renderSlot(_ctx.$slots, "bottom-info", {
              date: date.date
            })
          ]),
          key: "3"
        } : void 0,
        _ctx.footerInfo ? {
          name: "footer-info",
          fn: withCtx((date) => [
            renderSlot(_ctx.$slots, "footer-info", {
              date: date.date
            })
          ]),
          key: "4"
        } : void 0
      ]), 1032, ["type", "is-auto-back-fill", "poppable", "title", "default-value", "start-date", "end-date", "confirm-text", "start-text", "end-text", "show-today", "show-title", "show-sub-title", "to-date-animation", "first-day-of-week", "disabled-date", "onUpdate", "onClose", "onChoose", "onSelect"])
    ]),
    _: 3
  }, 16, ["visible", "lock-scroll", "onOpened"])) : (openBlock(), createBlock(_component_nut_calendar_item, {
    key: 1,
    ref: "calendarRef",
    type: _ctx.type,
    "is-auto-back-fill": _ctx.isAutoBackFill,
    poppable: _ctx.poppable,
    title: _ctx.title,
    "confirm-text": _ctx.confirmText,
    "start-text": _ctx.startText,
    "end-text": _ctx.endText,
    "default-value": _ctx.defaultValue,
    "start-date": _ctx.startDate,
    "end-date": _ctx.endDate,
    "show-title": _ctx.showTitle,
    "show-sub-title": _ctx.showSubTitle,
    "to-date-animation": _ctx.toDateAnimation,
    "show-today": _ctx.showToday,
    "first-day-of-week": _ctx.firstDayOfWeek,
    "disabled-date": _ctx.disabledDate,
    onUpdate: _ctx.update,
    onClose: _ctx.close,
    onChoose: _ctx.choose,
    onSelect: _ctx.select
  }, createSlots({ _: 2 }, [
    _ctx.showTopBtn ? {
      name: "btn",
      fn: withCtx(() => [
        renderSlot(_ctx.$slots, "btn")
      ]),
      key: "0"
    } : void 0,
    _ctx.dayInfo ? {
      name: "day",
      fn: withCtx((date) => [
        renderSlot(_ctx.$slots, "day", {
          date: date.date
        })
      ]),
      key: "1"
    } : void 0,
    _ctx.topInfo ? {
      name: "top-info",
      fn: withCtx((date) => [
        renderSlot(_ctx.$slots, "top-info", {
          date: date.date
        })
      ]),
      key: "2"
    } : void 0,
    _ctx.bottomInfo ? {
      name: "bottom-info",
      fn: withCtx((date) => [
        renderSlot(_ctx.$slots, "bottom-info", {
          date: date.date
        })
      ]),
      key: "3"
    } : void 0
  ]), 1032, ["type", "is-auto-back-fill", "poppable", "title", "confirm-text", "start-text", "end-text", "default-value", "start-date", "end-date", "show-title", "show-sub-title", "to-date-animation", "show-today", "first-day-of-week", "disabled-date", "onUpdate", "onClose", "onChoose", "onSelect"]));
}
const index$v = /* @__PURE__ */ _export_sfc(_sfc_main$19, [["render", _sfc_render$I]]);
var __defProp$N = Object.defineProperty;
var __defProps$M = Object.defineProperties;
var __getOwnPropDescs$M = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$M = Object.getOwnPropertySymbols;
var __hasOwnProp$M = Object.prototype.hasOwnProperty;
var __propIsEnum$M = Object.prototype.propertyIsEnumerable;
var __defNormalProp$N = (obj, key, value) => key in obj ? __defProp$N(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$M = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$M.call(b, prop))
      __defNormalProp$N(a2, prop, b[prop]);
  if (__getOwnPropSymbols$M)
    for (var prop of __getOwnPropSymbols$M(b)) {
      if (__propIsEnum$M.call(b, prop))
        __defNormalProp$N(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$M = (a2, b) => __defProps$M(a2, __getOwnPropDescs$M(b));
const Left = () => {
  return h$2(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      width: "18",
      height: "18",
      viewBox: "0 0 18 18"
    },
    [
      h$2("path", {
        d: "M6.605 9.49a.771.771 0 0 1 0-.98l3.6-4.372a.771.771 0 0 1 1.19.981L8.2 9l3.197 3.881a.771.771 0 1 1-1.191.98l-3.6-4.37Z"
      })
    ]
  );
};
const Right = () => {
  return h$2(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      width: "18",
      height: "18",
      viewBox: "0 0 18 18"
    },
    [
      h$2("path", {
        d: "M11.396 9.49a.771.771 0 0 0 0-.98l-3.6-4.372a.771.771 0 0 0-1.191.981L9.8 9l-3.196 3.881a.771.771 0 0 0 1.19.98l3.6-4.37Z"
      })
    ]
  );
};
const DoubleLeft = () => {
  return h$2(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      width: "18",
      height: "18",
      viewBox: "0 0 18 18"
    },
    [
      h$2("path", {
        d: "M13.853 4.026a.771.771 0 0 1 .12 1.085L10.864 9l3.11 3.889a.771.771 0 1 1-1.204.963L9.272 9.482a.771.771 0 0 1 0-.964l3.497-4.371a.771.771 0 0 1 1.084-.12Zm-5.245 0a.771.771 0 0 1 .12 1.085L5.617 9l3.111 3.889a.771.771 0 0 1-1.205.963L4.026 9.482a.771.771 0 0 1 0-.964l3.497-4.371a.771.771 0 0 1 1.085-.12Z"
      })
    ]
  );
};
const DoubleRight = () => {
  return h$2(
    "svg",
    {
      xmlns: "http://www.w3.org/2000/svg",
      width: "18",
      height: "18",
      viewBox: "0 0 18 18"
    },
    [
      h$2("path", {
        d: "M4.147 13.974a.771.771 0 0 1-.12-1.085L7.136 9 4.028 5.11a.771.771 0 1 1 1.204-.963l3.497 4.371a.771.771 0 0 1 0 .964l-3.497 4.371a.771.771 0 0 1-1.084.12Zm5.245 0a.771.771 0 0 1-.12-1.085L12.383 9 9.272 5.11a.771.771 0 1 1 1.205-.963l3.497 4.371a.771.771 0 0 1 0 .964l-3.497 4.371a.771.771 0 0 1-1.085.12Z"
      })
    ]
  );
};
const convertDateToDay = (date) => {
  return date ? {
    year: date.getFullYear(),
    month: date.getMonth() + 1,
    date: date.getDate()
  } : null;
};
const convertDayToDate = (day) => {
  return day ? new Date(day.year, day.month - 1, day.date) : null;
};
const valueToRange = (val) => {
  if (Array.isArray(val)) {
    return val.map((date) => {
      return convertDateToDay(date);
    });
  }
  return val ? [convertDateToDay(val)] : [];
};
const rangeTovalue = (range) => {
  if (Array.isArray(range)) {
    return range.map((day) => {
      return convertDayToDate(day);
    });
  }
  return range ? [convertDayToDate(range)] : [];
};
const getPrevMonthDays = (year, month, firstDayOfWeek) => {
  let prevMonth = month - 1;
  let prevYear = year;
  if (prevMonth <= 0) {
    prevMonth = 12;
    prevYear -= 1;
  }
  let days = Utils.getMonthPreDay(year, month);
  days -= firstDayOfWeek;
  if (days >= 7) {
    days -= 7;
  }
  const preDates = Utils.getMonthDays(`${prevYear}`, `${prevMonth}`);
  const months = Array.from(Array(preDates), (_, k2) => {
    return {
      type: "prev",
      year: prevYear,
      month: prevMonth,
      date: k2 + 1
    };
  });
  return months.slice(preDates - days);
};
const getCurrentMonthDays = (year, month) => {
  const days = Utils.getMonthDays(`${year}`, `${month}`);
  return Array.from(Array(days), (_, k2) => {
    return {
      type: "current",
      year,
      month,
      date: k2 + 1
    };
  });
};
const getCurrentWeekDays = (day, firstDayOfWeek) => {
  const current = new Date(day.year, day.month - 1, day.date);
  const count2 = (current.getDay() + 7 - firstDayOfWeek) % 7;
  return [
    convertDateToDay(new Date(current.getTime() - 24 * 60 * 60 * 1e3 * count2)),
    convertDateToDay(new Date(current.getTime() + 24 * 60 * 60 * 1e3 * (6 - count2)))
  ];
};
const getDays = (month, firstDayOfWeek) => {
  const y2 = month.year;
  const m2 = month.month;
  const days = [...getPrevMonthDays(y2, m2, firstDayOfWeek), ...getCurrentMonthDays(y2, m2)];
  const size = days.length;
  const yearOfNextMonth = month.month === 12 ? month.year + 1 : month.year;
  const monthOfNextMonth = month.month === 12 ? 1 : month.month + 1;
  for (let i2 = 1; i2 <= 42 - size; i2++) {
    days.push({
      type: "next",
      year: yearOfNextMonth,
      month: monthOfNextMonth,
      date: i2
    });
  }
  return days;
};
const compareDay = (day1, day2) => {
  if (day1 && day2) {
    if (day1.year === day2.year) {
      if (day1.month === day2.month) {
        return day1.date - day2.date;
      }
      return day1.month - day2.month;
    }
    return day1.year - day2.year;
  }
};
const isSameDay = (day1, day2) => {
  return compareDay(day1, day2) === 0;
};
const _hoisted_1$Q = { class: "nut-calendarcard" };
const _hoisted_2$G = { class: "nut-calendarcard-header" };
const _hoisted_3$z = { class: "nut-calendarcard-header-left" };
const _hoisted_4$u = { class: "nut-calendarcard-header-title" };
const _hoisted_5$m = { class: "nut-calendarcard-header-right" };
const _hoisted_6$l = { class: "nut-calendarcard-content" };
const _hoisted_7$h = { class: "nut-calendarcard-days" };
const _hoisted_8$c = { class: "nut-calendarcard-days" };
const _hoisted_9$7 = ["onClick"];
const _hoisted_10$6 = { class: "nut-calendarcard-day-top" };
const _hoisted_11$5 = { class: "nut-calendarcard-day-inner" };
const _hoisted_12$5 = { class: "nut-calendarcard-day-bottom" };
const cN$k = "NutCalendarCard";
const _sfc_main$18 = /* @__PURE__ */ defineComponent(__spreadProps$M(__spreadValues$M({}, {
  name: cN$k
}), {
  __name: "calendar-card",
  props: {
    type: { default: "single" },
    firstDayOfWeek: { default: 0 },
    modelValue: { default: null },
    startDate: { default: null },
    endDate: { default: null },
    disableDay: { type: Function, default: () => false }
  },
  emits: ["update:modelValue", "change", "dayClick", "pageChange"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const translate = useLocale(cN$k);
    const initMonth = () => {
      let date = new Date(Date.now());
      const val = props.modelValue;
      if (Array.isArray(val)) {
        if (val.length) {
          date = val[0];
        }
      } else if (val) {
        date = val;
      }
      return {
        year: date.getFullYear(),
        month: date.getMonth() + 1
      };
    };
    const month = ref(initMonth());
    const days = ref([]);
    const weekHeader = computed(() => {
      const weekdays = translate("weekdays").map((day, index2) => {
        return {
          name: day,
          key: index2
        };
      });
      return [...weekdays.slice(props.firstDayOfWeek, 7), ...weekdays.slice(0, props.firstDayOfWeek)];
    });
    const innerValue = ref(props.modelValue ? valueToRange(props.modelValue) : []);
    watchEffect(() => {
      const val = props.modelValue ? valueToRange(props.modelValue) : [];
      innerValue.value = val;
    });
    const change = (v2) => {
      innerValue.value = v2;
      if (props.type === "single") {
        const date = convertDayToDate(v2[0]);
        emit2("update:modelValue", date);
        emit2("change", date);
      } else if (props.type === "multiple" || props.type === "range" || props.type === "week") {
        const val = rangeTovalue(v2);
        emit2("update:modelValue", val);
        emit2("change", val);
      }
    };
    watchEffect(() => {
      const newDays = getDays(month.value, props.firstDayOfWeek);
      days.value = newDays;
      emit2("pageChange", month.value);
    });
    const isDisable = (day) => {
      if (props.disableDay && props.disableDay(day)) {
        return true;
      }
      if (props.startDate && Number(compareDay(day, convertDateToDay(props.startDate))) < 0) {
        return true;
      }
      if (props.endDate && Number(compareDay(day, convertDateToDay(props.endDate))) > 0) {
        return true;
      }
      return false;
    };
    const isActive = (day) => {
      if (props.type === "single" || props.type === "multiple") {
        for (const val in innerValue.value) {
          if (isSameDay(day, innerValue.value[val])) {
            return true;
          }
        }
      } else if (props.type === "range" && innerValue.value.length === 1 && isSameDay(innerValue.value[0], day)) {
        return true;
      }
      return false;
    };
    const isStart = (day) => {
      return (props.type === "range" || props.type === "week") && innerValue.value.length === 2 && isSameDay(day, innerValue.value[0]);
    };
    const isEnd = (day) => {
      return (props.type === "range" || props.type === "week") && innerValue.value.length === 2 && isSameDay(day, innerValue.value[1]);
    };
    const isMid = (day) => {
      if (props.type === "range" || props.type === "week") {
        if (innerValue.value.length === 2) {
          const c1 = compareDay(innerValue.value[0], day);
          const c2 = compareDay(day, innerValue.value[1]);
          if (c1 && c1 < 0 && c2 && c2 < 0) {
            return true;
          }
        }
      }
      return false;
    };
    const isWeekend = (day) => {
      const d2 = new Date(day.year, day.month - 1, day.date).getDay();
      return d2 === 0 || d2 === 6;
    };
    const getClasses = (day) => {
      if (isDisable(day)) {
        return ["disabled"];
      }
      const res = [];
      if (day.type === "current") {
        if (isActive(day)) {
          res.push("active");
        }
        if (isStart(day)) {
          res.push("start");
        }
        if (isEnd(day)) {
          res.push("end");
        }
        if (isMid(day)) {
          res.push("mid");
        }
        if (isWeekend(day)) {
          res.push("weekend");
        }
      }
      return res;
    };
    const jumpTo = (y2, m2) => {
      if (props.startDate) {
        const c2 = compareDay(
          {
            year: y2,
            month: m2,
            date: 31
          },
          convertDateToDay(props.startDate)
        );
        if (c2 && c2 < 0) {
          return;
        }
      }
      if (props.endDate) {
        const c2 = compareDay(
          {
            year: y2,
            month: m2,
            date: 1
          },
          convertDateToDay(props.endDate)
        );
        if (c2 && c2 > 0) {
          return;
        }
      }
      month.value = {
        year: y2,
        month: m2
      };
    };
    const jump = (step = 1) => {
      const current = month.value.year * 12 + month.value.month;
      let newMonth = (current + step) % 12;
      if (newMonth === 0) {
        newMonth = 12;
      }
      const newYear = Math.floor((current + step - newMonth) / 12);
      jumpTo(newYear, newMonth);
    };
    const handleDayClick = (day) => {
      if (day.type === "prev" || day.type === "next" || isDisable(day)) {
        return;
      }
      emit2("dayClick", day);
      switch (props.type) {
        case "single": {
          if (innerValue.value[0] && isSameDay(innerValue.value[0], day)) {
            change([]);
          } else {
            change([day]);
          }
          break;
        }
        case "multiple": {
          const t = innerValue.value.find((i2) => isSameDay(i2, day));
          if (t) {
            change(innerValue.value.filter((i2) => i2 !== t));
          } else {
            change([...innerValue.value, day]);
          }
          break;
        }
        case "range": {
          const len = innerValue.value.length;
          if (len === 0 || len === 2) {
            change([day]);
          } else if (len === 1) {
            const t = compareDay(innerValue.value[0], day);
            if (t === null || t === void 0) {
              change([]);
            } else if (t < 0) {
              change([innerValue.value[0], day]);
            } else {
              change([day, innerValue.value[0]]);
            }
          } else {
            console.warn("[NutUI] Calendar range error");
          }
          break;
        }
        case "week": {
          if (innerValue.value.length === 2 || innerValue.value.length === 0) {
            const [left, right] = getCurrentWeekDays(day, props.firstDayOfWeek);
            change([left, right]);
          } else {
            console.warn("[NutUI] Calendar week error");
          }
          break;
        }
        default: {
          console.warn("[NutUI] Calendar type error");
        }
      }
    };
    __expose({
      jump,
      jumpTo
    });
    return (_ctx, _cache) => {
      return withDirectives((openBlock(), createElementBlock("div", _hoisted_1$Q, [
        createBaseVNode("div", _hoisted_2$G, [
          createBaseVNode("div", _hoisted_3$z, [
            createBaseVNode("div", {
              class: "double-left",
              onClick: _cache[0] || (_cache[0] = ($event) => jump(-12))
            }, [
              createVNode(unref(DoubleLeft))
            ]),
            createBaseVNode("div", {
              class: "left",
              onClick: _cache[1] || (_cache[1] = ($event) => jump(-1))
            }, [
              createVNode(unref(Left))
            ])
          ]),
          createBaseVNode("div", _hoisted_4$u, toDisplayString(unref(translate)("monthTitle", month.value.year, month.value.month)), 1),
          createBaseVNode("div", _hoisted_5$m, [
            createBaseVNode("div", {
              class: "right",
              onClick: _cache[2] || (_cache[2] = ($event) => jump(1))
            }, [
              createVNode(unref(Right))
            ]),
            createBaseVNode("div", {
              class: "double-right",
              onClick: _cache[3] || (_cache[3] = ($event) => jump(12))
            }, [
              createVNode(unref(DoubleRight))
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_6$l, [
          createBaseVNode("div", _hoisted_7$h, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(weekHeader.value, (d2) => {
              return openBlock(), createElementBlock("div", {
                key: d2.name,
                class: normalizeClass(["nut-calendarcard-day header", d2.key === 0 || d2.key === 6 ? "weekend" : ""])
              }, toDisplayString(d2.name), 3);
            }), 128))
          ]),
          createBaseVNode("div", _hoisted_8$c, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(days.value, (day) => {
              return openBlock(), createElementBlock("div", {
                key: `${day.year}-${day.month}-${day.date}`,
                class: normalizeClass(["nut-calendarcard-day", [day.type, ...getClasses(day)]]),
                onClick: ($event) => handleDayClick(day)
              }, [
                createBaseVNode("div", _hoisted_10$6, [
                  renderSlot(_ctx.$slots, "top", { day })
                ]),
                createBaseVNode("div", _hoisted_11$5, [
                  renderSlot(_ctx.$slots, "default", { day }, () => [
                    createTextVNode(toDisplayString(day.date), 1)
                  ])
                ]),
                createBaseVNode("div", _hoisted_12$5, [
                  renderSlot(_ctx.$slots, "bottom", { day })
                ])
              ], 10, _hoisted_9$7);
            }), 128))
          ])
        ])
      ], 512)), [
        [vShow, days.value.length > 0]
      ]);
    };
  }
}));
withInstall(_sfc_main$18);
const CHECKBOX_KEY = Symbol("nut-checkbox");
const { create: create$J, componentName: componentName$3 } = createComponent("checkbox");
const _sfc_main$17 = create$J({
  props: {
    modelValue: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    textPosition: {
      type: String,
      default: "right"
    },
    iconSize: {
      type: [String, Number],
      default: ""
    },
    label: {
      type: String,
      default: ""
    },
    indeterminate: {
      type: Boolean,
      default: false
    },
    shape: {
      type: String,
      default: "round"
      // button
    }
  },
  emits: ["change", "update:modelValue"],
  setup(props, { emit: emit2, slots }) {
    const disabled = useFormDisabled(toRef(props, "disabled"));
    const parent = inject(CHECKBOX_KEY, null);
    const state = reactive({
      partialSelect: props.indeterminate
    });
    const hasParent = computed(() => !!parent);
    const pValue = computed(() => {
      if (hasParent.value) {
        return parent.value.value.includes(props.label);
      } else {
        return props.modelValue;
      }
    });
    const pDisabled = computed(() => {
      return hasParent.value ? parent.disabled.value ? parent.disabled.value : disabled.value : disabled.value;
    });
    const checked = computed(() => !!props.modelValue);
    const color = computed(() => {
      return !pDisabled.value ? state.partialSelect ? "nut-checkbox__icon--indeterminate" : !pValue.value ? "nut-checkbox__icon--unchecked" : "nut-checkbox__icon" : "nut-checkbox__icon--disable";
    });
    let updateType = "";
    const emitChange = (value, label) => {
      updateType = "click";
      emit2("update:modelValue", value);
      emit2("change", value, label);
    };
    watch(
      () => props.modelValue,
      (v2) => {
        if (updateType == "click") {
          updateType = "";
        } else {
          emit2("change", v2);
        }
      }
    );
    const renderIcon2 = () => {
      const { iconSize } = props;
      const iconNodeMap = {
        CheckNormal: slots.icon ? slots.icon : S$1,
        Checked: slots.checkedIcon ? slots.checkedIcon : g$5,
        CheckDisabled: slots.indeterminate ? slots.indeterminate : g$7
      };
      const iconNode = state.partialSelect ? iconNodeMap.CheckDisabled : !pValue.value ? iconNodeMap.CheckNormal : iconNodeMap.Checked;
      const size = pxCheck(iconSize);
      return h$2(iconNode, {
        width: size,
        height: size,
        size,
        class: color.value
      });
    };
    const renderLabel = () => {
      var _a;
      return h$2(
        "view",
        {
          class: `${componentName$3}__label ${pDisabled.value ? `${componentName$3}__label--disabled` : ""}`
        },
        (_a = slots.default) == null ? void 0 : _a.call(slots)
      );
    };
    const renderButton = () => {
      var _a;
      return h$2(
        "view",
        {
          class: `${componentName$3}__button ${pValue.value && `${componentName$3}__button--active`} ${pDisabled.value ? `${componentName$3}__button--disabled` : ""}`
        },
        (_a = slots.default) == null ? void 0 : _a.call(slots)
      );
    };
    const handleClick = () => {
      var _a, _b;
      if (pDisabled.value) return;
      if (checked.value && state.partialSelect) {
        state.partialSelect = false;
        emitChange(checked.value, (_a = slots.default) == null ? void 0 : _a.call(slots)[0].children);
        return;
      }
      emitChange(!checked.value, (_b = slots.default) == null ? void 0 : _b.call(slots)[0].children);
      if (hasParent.value) {
        const value = parent.value.value;
        const max = parent.max.value;
        const { label } = props;
        const index2 = value.indexOf(label);
        if (index2 > -1) {
          value.splice(index2, 1);
        } else if (index2 <= -1 && (value.length < max || !max)) {
          value.push(label);
        }
        parent.updateValue(value);
      }
    };
    onMounted(() => {
      hasParent.value && parent.link(getCurrentInstance());
    });
    onBeforeUnmount(() => {
      hasParent.value && parent.unlink(getCurrentInstance());
    });
    watch(
      () => props.indeterminate,
      (newVal) => {
        state.partialSelect = newVal;
      }
    );
    return () => {
      return h$2(
        "view",
        {
          class: `${componentName$3} ${componentName$3}--${props.shape} ${props.textPosition === "left" ? `${componentName$3}--reverse` : ""}`,
          onClick: handleClick
        },
        [props.shape == "button" ? renderButton() : [renderIcon2(), renderLabel()]]
      );
    };
  }
});
const { create: create$I, componentName: componentName$2 } = createComponent("checkbox-group");
const _sfc_main$16 = create$I({
  props: {
    modelValue: {
      type: Array,
      default: () => []
    },
    disabled: {
      type: Boolean,
      default: false
    },
    max: {
      type: Number,
      default: 0
    }
  },
  emits: ["change", "update:modelValue"],
  setup(props, { slots, emit: emit2, expose }) {
    const state = reactive({
      children: []
    });
    const link = (child) => {
      child.proxy && state.children.push(child.proxy);
    };
    const unlink = (child) => {
      child.proxy && (state.children = state.children.filter((p2) => p2 !== child.proxy));
    };
    const updateValue = (value) => {
      emit2("update:modelValue", value);
      emit2("change", value);
    };
    const toggleAll = (checked) => {
      const values = [];
      if (checked) {
        state.children.forEach((item) => {
          if (!(item == null ? void 0 : item.disabled)) {
            values.push(item == null ? void 0 : item.label);
          }
        });
      }
      emit2("update:modelValue", values);
    };
    const toggleReverse = () => {
      const value = state.children.filter((item) => {
        if (item == null ? void 0 : item.disabled) {
          return false;
        } else {
          return !props.modelValue.includes(item.label);
        }
      }).map((item) => item.label);
      emit2("update:modelValue", value);
    };
    provide(CHECKBOX_KEY, {
      value: computed(() => props.modelValue),
      disabled: computed(() => props.disabled),
      max: computed(() => props.max),
      updateValue,
      link,
      unlink
    });
    watch(
      () => props.modelValue,
      (value) => {
        emit2("change", value);
      }
    );
    expose({ toggleAll, toggleReverse });
    return () => {
      var _a;
      return h$2(
        "view",
        {
          class: componentName$2
        },
        (_a = slots.default) == null ? void 0 : _a.call(slots)
      );
    };
  }
});
var __defProp$M = Object.defineProperty;
var __defProps$L = Object.defineProperties;
var __getOwnPropDescs$L = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$L = Object.getOwnPropertySymbols;
var __hasOwnProp$L = Object.prototype.hasOwnProperty;
var __propIsEnum$L = Object.prototype.propertyIsEnumerable;
var __defNormalProp$M = (obj, key, value) => key in obj ? __defProp$M(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$L = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$L.call(b, prop))
      __defNormalProp$M(a2, prop, b[prop]);
  if (__getOwnPropSymbols$L)
    for (var prop of __getOwnPropSymbols$L(b)) {
      if (__propIsEnum$L.call(b, prop))
        __defNormalProp$M(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$L = (a2, b) => __defProps$L(a2, __getOwnPropDescs$L(b));
const DEFAULT_FILED_NAMES = {
  text: "text",
  value: "value",
  children: "children",
  className: "className"
};
const usePicker = (props, emit2) => {
  const state = reactive({
    formattedColumns: props.columns
  });
  const columnFieldNames = computed(() => {
    return __spreadValues$L(__spreadValues$L({}, DEFAULT_FILED_NAMES), props.fieldNames);
  });
  const defaultValues = ref([]);
  const defaultIndexes = computed(() => {
    const fields = columnFieldNames.value;
    return columnsList.value.map((column, index2) => {
      const targetIndex = column.findIndex((item) => item[fields.value] === defaultValues.value[index2]);
      return targetIndex === -1 ? 0 : targetIndex;
    });
  });
  const pickerColumn = ref([]);
  const swipeRef = (el) => {
    if (el && pickerColumn.value.length < columnsList.value.length) {
      pickerColumn.value.push(el);
    }
  };
  const selectedOptions = computed(() => {
    const fields = columnFieldNames.value;
    return columnsList.value.map((column, index2) => {
      return column.find((item) => item[fields.value] === defaultValues.value[index2]) || column[0];
    });
  });
  const columnsType = computed(() => {
    const firstColumn = state.formattedColumns[0];
    const fields = columnFieldNames.value;
    if (firstColumn) {
      if (Array.isArray(firstColumn)) {
        return "multiple";
      }
      if (fields.children in firstColumn) {
        return "cascade";
      }
    }
    return "single";
  });
  const columnsList = computed(() => {
    let result = [];
    switch (columnsType.value) {
      case "multiple":
        result = state.formattedColumns;
        break;
      case "cascade":
        result = formatCascade(state.formattedColumns, defaultValues.value ? defaultValues.value : []);
        break;
      default:
        result = [state.formattedColumns];
        break;
    }
    return result;
  });
  const formatCascade = (columns, defaultValues2) => {
    const formatted = [];
    const fields = columnFieldNames.value;
    let cursor = {
      text: "",
      value: "",
      [fields.children]: columns
    };
    let columnIndex = 0;
    while (cursor && cursor[fields.children]) {
      const options = cursor[fields.children];
      const value = defaultValues2[columnIndex];
      let index2 = options.findIndex((columnItem) => columnItem[fields.value] === value);
      if (index2 === -1) index2 = 0;
      cursor = cursor[fields.children][index2];
      columnIndex++;
      formatted.push(options);
    }
    return formatted;
  };
  const cancel = () => {
    emit2("cancel", {
      selectedValue: defaultValues.value,
      selectedOptions: selectedOptions.value
    });
  };
  const changeHandler = (columnIndex, option) => {
    var _a;
    const fields = columnFieldNames.value;
    if (option && Object.keys(option).length) {
      defaultValues.value = defaultValues.value ? defaultValues.value : [];
      if (columnsType.value === "cascade") {
        defaultValues.value[columnIndex] = (_a = option[fields.value]) != null ? _a : "";
        let index2 = columnIndex;
        let cursor = option;
        while (cursor && cursor[fields.children] && cursor[fields.children][0]) {
          defaultValues.value[index2 + 1] = cursor[fields.children][0][fields.value];
          index2++;
          cursor = cursor[fields.children][0];
        }
        if (cursor && cursor[fields.children] && cursor[fields.children].length === 0) {
          defaultValues.value = defaultValues.value.slice(0, index2 + 1);
        }
      } else {
        defaultValues.value[columnIndex] = Object.prototype.hasOwnProperty.call(option, fields.value) ? option[fields.value] : "";
      }
      emit2("change", {
        columnIndex,
        selectedValue: defaultValues.value,
        selectedOptions: selectedOptions.value
      });
    }
  };
  const confirm = () => {
    const fields = columnFieldNames.value;
    if (defaultValues.value && !defaultValues.value.length) {
      columnsList.value.forEach((columns) => {
        defaultValues.value.push(columns[0][fields.value]);
      });
    }
    emit2("confirm", {
      selectedValue: defaultValues.value,
      selectedOptions: selectedOptions.value
    });
  };
  const isSameValue = (valA, valB) => JSON.stringify(valA) === JSON.stringify(valB);
  watch(
    () => props.modelValue,
    (newValues) => {
      if (!isSameValue(newValues, defaultValues.value)) {
        defaultValues.value = newValues;
      }
    },
    { deep: true, immediate: true }
  );
  watch(
    defaultValues,
    (newValues) => {
      if (!isSameValue(newValues, props.modelValue)) {
        emit2("update:modelValue", newValues);
      }
    },
    { deep: true }
  );
  watch(
    () => props.columns,
    (val) => {
      state.formattedColumns = val;
    }
  );
  return __spreadProps$L(__spreadValues$L({}, toRefs(state)), {
    columnsType,
    columnsList,
    columnFieldNames,
    cancel,
    changeHandler,
    confirm,
    defaultValues,
    defaultIndexes,
    pickerColumn,
    swipeRef,
    selectedOptions,
    isSameValue
  });
};
const { create: create$1$4 } = createComponent("picker-column");
const _sfc_main$1$5 = create$1$4({
  props: {
    // 当前选中项
    value: [String, Number],
    columnsType: String,
    column: {
      type: Array,
      default: () => []
    },
    // 是否开启3D效果
    threeDimensional: {
      type: Boolean,
      default: true
    },
    swipeDuration: {
      type: [Number, String],
      default: 1e3
    },
    visibleOptionNum: {
      type: [Number, String],
      default: 7
    },
    optionHeight: {
      type: [Number, String],
      default: 36
    },
    fieldNames: {
      type: Object,
      default: () => ({})
    },
    // 特殊环境判断
    taro: {
      type: Boolean,
      default: false
    }
  },
  emits: ["click", "change"],
  setup(props, { emit: emit2 }) {
    const touch = useTouch();
    const state = reactive({
      touchParams: {
        startY: 0,
        endY: 0,
        startTime: 0,
        endTime: 0,
        lastY: 0,
        lastTime: 0
      },
      currIndex: 1,
      transformY: 0,
      scrollDistance: 0,
      rotation: 20
    });
    const roller = ref(null);
    const moving = ref(false);
    const touchDeg = ref(0);
    const touchTime = ref(0);
    const DEFAULT_DURATION = 200;
    const INERTIA_TIME = 300;
    const INERTIA_DISTANCE = 15;
    const touchRollerStyle = computed(() => {
      return {
        transition: `transform ${touchTime.value}ms cubic-bezier(0.17, 0.89, 0.45, 1)`,
        transform: `rotate3d(1, 0, 0, ${touchDeg.value})`,
        top: `calc(50% - ${+props.optionHeight / 2}px)`
      };
    });
    const touchTileStyle = computed(() => {
      const { optionHeight } = props;
      return {
        transition: `transform ${touchTime.value}ms cubic-bezier(0.17, 0.89, 0.45, 1)`,
        transform: `translate3d(0, ${state.scrollDistance}px, 0)`,
        top: `calc(50% - ${+optionHeight / 2}px)`,
        height: `${optionHeight}px`
      };
    });
    const setRollerStyle = (index2) => {
      return `transform: rotate3d(1, 0, 0, ${-state.rotation * index2}deg) translate3d(0px, 0px, 104px)`;
    };
    const maskStyles = computed(() => {
      return {
        backgroundSize: `100% ${(+props.visibleOptionNum - 1) * +props.optionHeight / 2}px`
      };
    });
    const onTouchStart = (event) => {
      touch.start(event);
      if (moving.value && !props.taro) {
        const dom = roller.value;
        const { transform } = window.getComputedStyle(dom);
        if (props.threeDimensional) {
          const circle = Math.floor(parseInt(touchDeg.value) / 360);
          const cos = +transform.split(", ")[5];
          const sin = +transform.split(", ")[6] < 0 ? 180 : 0;
          const endDeg = circle * 360 + Math.acos(cos) / Math.PI * 180 + sin;
          state.scrollDistance = -Math.abs((endDeg / state.rotation - 1) * +props.optionHeight);
        } else {
          state.scrollDistance = +transform.slice(7, transform.length - 1).split(", ")[5];
        }
      }
      preventDefault(event, true);
      state.touchParams.startY = touch.deltaY.value;
      state.touchParams.startTime = Date.now();
      state.transformY = state.scrollDistance;
    };
    const onTouchMove = (event) => {
      touch.move(event);
      if (touch.isVertical()) {
        moving.value = true;
        preventDefault(event, true);
      }
      state.touchParams.lastY = touch.deltaY.value;
      let move = state.touchParams.lastY - state.touchParams.startY;
      setMove(move);
    };
    const onTouchEnd = () => {
      state.touchParams.lastY = touch.deltaY.value;
      state.touchParams.lastTime = Date.now();
      let move = state.touchParams.lastY - state.touchParams.startY;
      let moveTime = state.touchParams.lastTime - state.touchParams.startTime;
      if (moveTime <= INERTIA_TIME && Math.abs(move) > INERTIA_DISTANCE) {
        const distance = momentum(move, moveTime);
        setMove(distance, "end", +props.swipeDuration);
        return;
      } else {
        setMove(move, "end");
      }
      setTimeout(() => {
        touch.reset();
        moving.value = false;
      }, 0);
    };
    const momentum = (distance, duration) => {
      const speed = Math.abs(distance / duration);
      distance = speed / 3e-3 * (distance < 0 ? -1 : 1);
      return distance;
    };
    const isHidden = (index2) => {
      if (index2 >= state.currIndex + 8 || index2 <= state.currIndex - 8) {
        return true;
      } else {
        return false;
      }
    };
    const isCurrPick = (index2) => {
      return index2 == state.currIndex;
    };
    const setTransform = (translateY = 0, type, time = DEFAULT_DURATION, deg) => {
      if (type === "end") {
        touchTime.value = time;
      } else {
        touchTime.value = 0;
      }
      touchDeg.value = deg;
      state.scrollDistance = translateY;
    };
    const setMove = (move, type, time) => {
      const { optionHeight } = props;
      let updateMove = move + state.transformY;
      if (type === "end") {
        if (updateMove > 0) {
          updateMove = 0;
        }
        if (updateMove < -(props.column.length - 1) * +optionHeight) {
          updateMove = -(props.column.length - 1) * +optionHeight;
        }
        let endMove = Math.round(updateMove / +optionHeight) * +optionHeight;
        let deg = `${(Math.abs(Math.round(endMove / +optionHeight)) + 1) * state.rotation}deg`;
        setTransform(endMove, type, time, deg);
        state.currIndex = Math.abs(Math.round(endMove / +optionHeight)) + 1;
      } else {
        let deg = 0;
        let currentDeg = (-updateMove / +optionHeight + 1) * state.rotation;
        const maxDeg = (props.column.length + 1) * state.rotation;
        const minDeg = 0;
        deg = clamp(currentDeg, minDeg, maxDeg);
        if (minDeg < deg && deg < maxDeg) {
          setTransform(updateMove, null, void 0, deg + "deg");
          state.currIndex = Math.abs(Math.round(updateMove / +optionHeight)) + 1;
        }
      }
    };
    const setChooseValue = () => {
      emit2("change", props.column[state.currIndex - 1]);
    };
    const modifyStatus = (type) => {
      const { column } = props;
      let index2 = column.findIndex((columnItem) => columnItem[props.fieldNames.value] === props.value);
      state.currIndex = index2 === -1 ? 1 : index2 + 1;
      let move = index2 === -1 ? 0 : index2 * +props.optionHeight;
      type && setChooseValue();
      setMove(-move);
    };
    const stopMomentum = () => {
      moving.value = false;
      touchTime.value = 0;
      setChooseValue();
    };
    watch(
      () => props.column,
      () => {
        if (props.column && props.column.length > 0) {
          state.transformY = 0;
          modifyStatus(false);
        }
      },
      {
        deep: true
      }
    );
    watch(
      () => props.value,
      () => {
        state.transformY = 0;
        modifyStatus(false);
      },
      {
        deep: true
      }
    );
    onMounted(() => {
      modifyStatus(true);
    });
    return __spreadProps$L(__spreadValues$L(__spreadValues$L({}, toRefs(state)), toRefs(props)), {
      setRollerStyle,
      isHidden,
      isCurrPick,
      roller,
      onTouchStart,
      onTouchMove,
      onTouchEnd,
      touchRollerStyle,
      touchTileStyle,
      setMove,
      stopMomentum,
      pxCheck,
      maskStyles
    });
  }
});
function _sfc_render$1$4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    class: "nut-picker__list",
    onTouchstart: _cache[1] || (_cache[1] = (...args) => _ctx.onTouchStart && _ctx.onTouchStart(...args)),
    onTouchmove: _cache[2] || (_cache[2] = (...args) => _ctx.onTouchMove && _ctx.onTouchMove(...args)),
    onTouchend: _cache[3] || (_cache[3] = (...args) => _ctx.onTouchEnd && _ctx.onTouchEnd(...args))
  }, [
    createBaseVNode("view", {
      ref: "roller",
      class: "nut-picker-roller",
      style: normalizeStyle(_ctx.threeDimensional ? _ctx.touchRollerStyle : _ctx.touchTileStyle),
      onTransitionend: _cache[0] || (_cache[0] = (...args) => _ctx.stopMomentum && _ctx.stopMomentum(...args))
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.column, (item, index2) => {
        var _a;
        return openBlock(), createElementBlock(Fragment, {
          key: (_a = item[_ctx.fieldNames.value]) != null ? _a : index2
        }, [
          item && item[_ctx.fieldNames.text] && _ctx.threeDimensional ? (openBlock(), createElementBlock("view", {
            key: 0,
            class: normalizeClass(["nut-picker-roller-item", {
              "nut-picker-roller-item-hidden": _ctx.isHidden(index2 + 1),
              [item[_ctx.fieldNames.className]]: item[_ctx.fieldNames.className]
            }]),
            style: normalizeStyle(_ctx.setRollerStyle(index2 + 1))
          }, toDisplayString(item[_ctx.fieldNames.text]), 7)) : createCommentVNode("", true),
          item && item[_ctx.fieldNames.text] && !_ctx.threeDimensional ? (openBlock(), createElementBlock("view", {
            key: 1,
            class: normalizeClass(["nut-picker-roller-item-tile", {
              [item[_ctx.fieldNames.className]]: item[_ctx.fieldNames.className],
              "nut-picker-roller-item-selected": _ctx.isCurrPick(index2 + 1)
            }]),
            style: normalizeStyle({ height: _ctx.pxCheck(_ctx.optionHeight), lineHeight: _ctx.pxCheck(_ctx.optionHeight) })
          }, toDisplayString(item[_ctx.fieldNames.text]), 7)) : createCommentVNode("", true)
        ], 64);
      }), 128))
    ], 36),
    createBaseVNode("view", {
      class: "nut-picker-roller-mask",
      style: normalizeStyle(_ctx.maskStyles)
    }, null, 4)
  ], 32);
}
const NutPickerColumn = /* @__PURE__ */ _export_sfc(_sfc_main$1$5, [["render", _sfc_render$1$4]]);
const baseProps$1 = {
  modelValue: {
    type: Array,
    default: () => []
  },
  title: {
    type: String,
    default: ""
  },
  cancelText: {
    type: String,
    default: ""
  },
  okText: {
    type: String,
    default: ""
  },
  columns: {
    type: Array,
    default: () => {
      return [];
    }
  },
  threeDimensional: {
    type: Boolean,
    default: false
  },
  swipeDuration: {
    type: [Number, String],
    default: 1e3
  },
  showToolbar: {
    type: Boolean,
    default: true
  },
  visibleOptionNum: {
    type: [Number, String],
    default: 7
  },
  optionHeight: {
    type: [Number, String],
    default: 36
  },
  fieldNames: {
    type: Object,
    default: () => ({})
  }
};
const { create: create$H } = createComponent("picker");
const cN$j = "NutPicker";
const _sfc_main$15 = create$H({
  components: {
    NutPickerColumn
  },
  props: baseProps$1,
  emits: ["cancel", "change", "confirm", "update:modelValue"],
  setup(props, { emit: emit2 }) {
    const translate = useLocale(cN$j);
    const { changeHandler, confirm, defaultValues, columnsList, columnsType, columnFieldNames, cancel } = usePicker(
      props,
      emit2
    );
    const pickerColumn = ref([]);
    const swipeRef = (el) => {
      if (el && pickerColumn.value.length < columnsList.value.length) {
        pickerColumn.value.push(el);
      }
    };
    const columnStyle = computed(() => {
      const styles = {};
      styles.height = `${+props.visibleOptionNum * +props.optionHeight}px`;
      styles["--lineHeight"] = `${+props.optionHeight}px`;
      return styles;
    });
    const confirmHandler = () => {
      pickerColumn.value.length > 0 && pickerColumn.value.forEach((column) => {
        column.stopMomentum();
      });
      confirm();
    };
    return {
      columnsType,
      columnsList,
      columnFieldNames,
      cancel,
      changeHandler,
      confirmHandler,
      defaultValues,
      translate,
      pickerColumn,
      swipeRef,
      columnStyle
    };
  }
});
const _hoisted_1$P = { class: "nut-picker" };
const _hoisted_2$F = {
  key: 0,
  class: "nut-picker__bar"
};
const _hoisted_3$y = { class: "nut-picker__title" };
function _sfc_render$H(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_picker_column = resolveComponent("nut-picker-column");
  return openBlock(), createElementBlock("div", _hoisted_1$P, [
    _ctx.showToolbar ? (openBlock(), createElementBlock("view", _hoisted_2$F, [
      createBaseVNode("view", {
        class: "nut-picker__left",
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.cancel && _ctx.cancel(...args))
      }, toDisplayString(_ctx.cancelText || _ctx.translate("cancel")), 1),
      createBaseVNode("view", _hoisted_3$y, toDisplayString(_ctx.title), 1),
      createBaseVNode("view", {
        class: "nut-picker__right",
        onClick: _cache[1] || (_cache[1] = (...args) => _ctx.confirmHandler && _ctx.confirmHandler(...args))
      }, toDisplayString(_ctx.okText || _ctx.translate("confirm")), 1)
    ])) : createCommentVNode("", true),
    renderSlot(_ctx.$slots, "top"),
    createBaseVNode("view", {
      class: "nut-picker__column",
      style: normalizeStyle(_ctx.columnStyle)
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.columnsList, (column, columnIndex) => {
        return openBlock(), createElementBlock("view", {
          key: columnIndex,
          class: "nut-picker__columnitem"
        }, [
          createVNode(_component_nut_picker_column, {
            ref_for: true,
            ref: _ctx.swipeRef,
            column,
            "columns-type": _ctx.columnsType,
            "field-names": _ctx.columnFieldNames,
            value: _ctx.defaultValues && _ctx.defaultValues[columnIndex],
            "three-dimensional": _ctx.threeDimensional,
            "swipe-duration": _ctx.swipeDuration,
            "visible-option-num": _ctx.visibleOptionNum,
            "option-height": _ctx.optionHeight,
            onChange: (option) => {
              _ctx.changeHandler(columnIndex, option);
            }
          }, null, 8, ["column", "columns-type", "field-names", "value", "three-dimensional", "swipe-duration", "visible-option-num", "option-height", "onChange"])
        ]);
      }), 128))
    ], 4),
    renderSlot(_ctx.$slots, "default")
  ]);
}
const NutPicker = /* @__PURE__ */ _export_sfc(_sfc_main$15, [["render", _sfc_render$H]]);
var __defProp$L = Object.defineProperty;
var __defProps$K = Object.defineProperties;
var __getOwnPropDescs$K = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$K = Object.getOwnPropertySymbols;
var __hasOwnProp$K = Object.prototype.hasOwnProperty;
var __propIsEnum$K = Object.prototype.propertyIsEnumerable;
var __defNormalProp$L = (obj, key, value) => key in obj ? __defProp$L(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$K = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$K.call(b, prop))
      __defNormalProp$L(a2, prop, b[prop]);
  if (__getOwnPropSymbols$K)
    for (var prop of __getOwnPropSymbols$K(b)) {
      if (__propIsEnum$K.call(b, prop))
        __defNormalProp$L(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$K = (a2, b) => __defProps$K(a2, __getOwnPropDescs$K(b));
const { create: create$G } = createComponent("date-picker");
const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
function isDate(val) {
  return isDate$1(val) && !isNaN(val.getTime());
}
const zhCNType = {
  day: "日",
  year: "年",
  month: "月",
  hour: "时",
  minute: "分",
  seconds: "秒"
};
const _sfc_main$14 = create$G({
  components: {
    NutPicker
  },
  props: {
    modelValue: null,
    title: {
      type: String,
      default: ""
    },
    okText: {
      type: String,
      default: ""
    },
    cancelText: {
      type: String,
      default: ""
    },
    type: {
      type: String,
      default: "date"
    },
    isShowChinese: {
      type: Boolean,
      default: false
    },
    minuteStep: {
      type: Number,
      default: 1
    },
    minDate: {
      type: Date,
      default: () => new Date(currentYear - 10, 0, 1),
      validator: isDate
    },
    maxDate: {
      type: Date,
      default: () => new Date(currentYear + 10, 11, 31),
      validator: isDate
    },
    formatter: {
      type: Function,
      default: null
    },
    // 是否开启3D效果
    threeDimensional: {
      type: Boolean,
      default: true
    },
    // 惯性滚动 时长
    swipeDuration: {
      type: [Number, String],
      default: 1e3
    },
    filter: Function,
    showToolbar: {
      type: Boolean,
      default: true
    },
    visibleOptionNum: {
      type: [Number, String],
      default: 7
    },
    optionHeight: {
      type: [Number, String],
      default: 36
    }
  },
  emits: ["click", "cancel", "change", "confirm", "update:modelValue"],
  setup(props, { emit: emit2 }) {
    const state = reactive({
      currentDate: /* @__PURE__ */ new Date(),
      title: props.title,
      selectedValue: []
    });
    const formatValue = (value) => {
      if (!isDate(value)) {
        value = props.minDate;
      }
      let timestmp = Math.max(value.getTime(), props.minDate.getTime());
      timestmp = Math.min(timestmp, props.maxDate.getTime());
      return new Date(timestmp);
    };
    function getMonthEndDay(year, month) {
      return 32 - new Date(year, month - 1, 32).getDate();
    }
    const getBoundary = (type, value) => {
      const boundary = type == "min" ? props.minDate : props.maxDate;
      const year = boundary.getFullYear();
      let month = 1;
      let date = 1;
      let hour = 0;
      let minute = 0;
      if (type === "max") {
        month = 12;
        date = getMonthEndDay(value.getFullYear(), value.getMonth() + 1);
        hour = 23;
        minute = 59;
      }
      let seconds = minute;
      if (value.getFullYear() === year) {
        month = boundary.getMonth() + 1;
        if (value.getMonth() + 1 === month) {
          date = boundary.getDate();
          if (value.getDate() === date) {
            hour = boundary.getHours();
            if (value.getHours() === hour) {
              minute = boundary.getMinutes();
              if (value.getMinutes() === minute) {
                seconds = boundary.getSeconds();
              }
            }
          }
        }
      }
      return {
        [`${type}Year`]: year,
        [`${type}Month`]: month,
        [`${type}Date`]: date,
        [`${type}Hour`]: hour,
        [`${type}Minute`]: minute,
        [`${type}Seconds`]: seconds
      };
    };
    const ranges = computed(() => {
      const { maxYear, maxDate, maxMonth, maxHour, maxMinute, maxSeconds } = getBoundary("max", state.currentDate);
      const { minYear, minDate, minMonth, minHour, minMinute, minSeconds } = getBoundary("min", state.currentDate);
      let result = [
        {
          type: "year",
          range: [minYear, maxYear]
        },
        {
          type: "month",
          range: [minMonth, maxMonth]
        },
        {
          type: "day",
          range: [minDate, maxDate]
        },
        {
          type: "hour",
          range: [minHour, maxHour]
        },
        {
          type: "minute",
          range: [minMinute, maxMinute]
        },
        {
          type: "seconds",
          range: [minSeconds, maxSeconds]
        }
      ];
      return generateList(result);
    });
    const columns = computed(() => {
      const val = ranges.value.map((res, columnIndex) => {
        return generateValue(res.range[0], res.range[1], getDateIndex(res.type), res.type, columnIndex);
      });
      return val;
    });
    const changeHandler = ({
      columnIndex,
      selectedValue,
      selectedOptions
    }) => {
      let formatDate = [];
      selectedValue.forEach((item) => {
        formatDate.push(item);
      });
      if (props.type == "month-day" && formatDate.length < 3) {
        formatDate.unshift(new Date(state.currentDate || props.minDate || props.maxDate).getFullYear());
      }
      if (props.type == "year-month" && formatDate.length < 3) {
        formatDate.push(new Date(state.currentDate || props.minDate || props.maxDate).getDate());
      }
      const year = Number(formatDate[0]);
      const month = Number(formatDate[1]) - 1;
      const day = Math.min(Number(formatDate[2]), getMonthEndDay(Number(formatDate[0]), Number(formatDate[1])));
      let date = null;
      if (props.type === "date" || props.type === "month-day" || props.type === "year-month") {
        date = new Date(year, month, day);
      } else if (props.type === "datetime") {
        date = new Date(year, month, day, Number(formatDate[3]), Number(formatDate[4]));
      } else if (props.type === "datehour") {
        date = new Date(year, month, day, Number(formatDate[3]));
      } else if (props.type === "hour-minute" || props.type === "time") {
        date = new Date(state.currentDate);
        const year2 = date.getFullYear();
        const month2 = date.getMonth();
        const day2 = date.getDate();
        date = new Date(year2, month2, day2, Number(formatDate[0]), Number(formatDate[1]), Number(formatDate[2] || 0));
      }
      state.currentDate = formatValue(date);
      emit2("change", { columnIndex, selectedValue, selectedOptions });
    };
    const formatterOption = (type, value) => {
      const { formatter, isShowChinese } = props;
      let fOption = null;
      if (formatter) {
        fOption = formatter(type, { text: padZero(value, 2), value: padZero(value, 2) });
      } else {
        const padMin = padZero(value, 2);
        const fatter = isShowChinese ? zhCNType[type] : "";
        fOption = { text: padMin + fatter, value: padMin };
      }
      return fOption;
    };
    const generateValue = (min, max, val, type, columnIndex) => {
      const arr = [];
      let index2 = 0;
      while (min <= max) {
        arr.push(formatterOption(type, min));
        if (type === "minute") {
          min += props.minuteStep;
        } else {
          min++;
        }
        if (min <= Number(val)) {
          index2++;
        }
      }
      state.selectedValue[columnIndex] = arr[index2].value;
      return props.filter ? props.filter(type, arr) : arr;
    };
    const getDateIndex = (type) => {
      if (type === "year") {
        return state.currentDate.getFullYear();
      } else if (type === "month") {
        return state.currentDate.getMonth() + 1;
      } else if (type === "day") {
        return state.currentDate.getDate();
      } else if (type === "hour") {
        return state.currentDate.getHours();
      } else if (type === "minute") {
        return state.currentDate.getMinutes();
      } else if (type === "seconds") {
        return state.currentDate.getSeconds();
      }
      return 0;
    };
    const closeHandler = (val) => {
      emit2("cancel", val);
    };
    const confirm = (val) => {
      emit2("confirm", val);
    };
    const generateList = (list) => {
      switch (props.type) {
        case "date":
          list = list.slice(0, 3);
          break;
        case "datetime":
          list = list.slice(0, 5);
          break;
        case "time":
          list = list.slice(3, 6);
          break;
        case "year-month":
          list = list.slice(0, 2);
          break;
        case "month-day":
          list = list.slice(1, 3);
          break;
        case "datehour":
          list = list.slice(0, 4);
          break;
        case "hour-minute":
          list = list.slice(3, 5);
          break;
      }
      return list;
    };
    const getSelectedValue = (time) => {
      const res = [
        time.getFullYear(),
        time.getMonth() + 1,
        time.getDate(),
        time.getHours(),
        time.getMinutes(),
        time.getSeconds()
      ];
      return generateList(res.map((i2) => String(i2)));
    };
    onBeforeMount(() => {
      state.currentDate = formatValue(props.modelValue);
    });
    watch(
      () => props.modelValue,
      (value) => {
        const newValues = formatValue(value);
        const isSameValue = JSON.stringify(newValues) === JSON.stringify(state.currentDate);
        if (!isSameValue) {
          state.currentDate = newValues;
          state.selectedValue = getSelectedValue(newValues);
        }
      }
    );
    watch(
      () => state.currentDate,
      (newValues) => {
        const isSameValue = JSON.stringify(newValues) === JSON.stringify(props.modelValue);
        if (!isSameValue) {
          emit2("update:modelValue", newValues);
        }
      }
    );
    watch(
      () => props.title,
      (val) => {
        state.title = val;
      }
    );
    return __spreadProps$K(__spreadValues$K({}, toRefs(state)), {
      changeHandler,
      closeHandler,
      confirm,
      columns
    });
  }
});
function _sfc_render$G(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_picker = resolveComponent("nut-picker");
  return openBlock(), createBlock(_component_nut_picker, {
    modelValue: _ctx.selectedValue,
    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.selectedValue = $event),
    "ok-text": _ctx.okText,
    "cancel-text": _ctx.cancelText,
    columns: _ctx.columns,
    title: _ctx.title,
    "three-dimensional": _ctx.threeDimensional,
    "swipe-duration": _ctx.swipeDuration,
    "show-toolbar": _ctx.showToolbar,
    "visible-option-num": _ctx.visibleOptionNum,
    "option-height": _ctx.optionHeight,
    onCancel: _ctx.closeHandler,
    onChange: _ctx.changeHandler,
    onConfirm: _ctx.confirm
  }, {
    top: withCtx(() => [
      renderSlot(_ctx.$slots, "top")
    ]),
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 8, ["modelValue", "ok-text", "cancel-text", "columns", "title", "three-dimensional", "swipe-duration", "show-toolbar", "visible-option-num", "option-height", "onCancel", "onChange", "onConfirm"]);
}
const index$u = /* @__PURE__ */ _export_sfc(_sfc_main$14, [["render", _sfc_render$G]]);
var __defProp$K = Object.defineProperty;
var __defProps$J = Object.defineProperties;
var __getOwnPropDescs$J = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$J = Object.getOwnPropertySymbols;
var __hasOwnProp$J = Object.prototype.hasOwnProperty;
var __propIsEnum$J = Object.prototype.propertyIsEnumerable;
var __defNormalProp$K = (obj, key, value) => key in obj ? __defProp$K(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$J = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$J.call(b, prop))
      __defNormalProp$K(a2, prop, b[prop]);
  if (__getOwnPropSymbols$J)
    for (var prop of __getOwnPropSymbols$J(b)) {
      if (__propIsEnum$J.call(b, prop))
        __defNormalProp$K(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$J = (a2, b) => __defProps$J(a2, __getOwnPropDescs$J(b));
const _hoisted_1$O = ["min", "max", "disabled", "readonly", "value"];
const _sfc_main$13 = /* @__PURE__ */ defineComponent(__spreadProps$J(__spreadValues$J({}, {
  name: "NutInputNumber",
  inheritAttrs: false
}), {
  __name: "input-number",
  props: {
    modelValue: { default: 0 },
    inputWidth: { default: "" },
    buttonSize: { default: "" },
    min: { default: 1 },
    max: { default: 9999 },
    step: { default: 1 },
    decimalPlaces: { default: 0 },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false }
  },
  emits: ["update:modelValue", "change", "blur", "focus", "reduce", "add", "overlimit"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const disabled = useFormDisabled(toRef(props, "disabled"));
    const classes = computed(() => {
      const prefixCls2 = "nut-input-number";
      return {
        [prefixCls2]: true,
        [`${prefixCls2}--disabled`]: disabled.value
      };
    });
    const fixedDecimalPlaces = (v2) => {
      return Number(v2).toFixed(Number(props.decimalPlaces));
    };
    const change = (event) => {
      const input = event.target;
      emit2("update:modelValue", input.value, event);
      emit2("change", input.value, event);
    };
    const emitChange = (value, event) => {
      let output_value = fixedDecimalPlaces(value);
      emit2("update:modelValue", output_value, event);
      if (Number(props.modelValue) !== Number(output_value)) emit2("change", output_value, event);
    };
    const addAllow = (value = Number(props.modelValue)) => {
      return value < Number(props.max) && !disabled.value;
    };
    const reduceAllow = (value = Number(props.modelValue)) => {
      return value > Number(props.min) && !disabled.value;
    };
    const reduce2 = (event) => {
      if (disabled.value) return;
      emit2("reduce", event);
      let output_value = Number(props.modelValue) - Number(props.step);
      if (reduceAllow() && output_value >= Number(props.min)) {
        emitChange(output_value, event);
      } else {
        emitChange(Number(props.min), event);
        emit2("overlimit", event, "reduce");
      }
    };
    const add = (event) => {
      if (disabled.value) return;
      emit2("add", event);
      let output_value = Number(props.modelValue) + Number(props.step);
      if (addAllow() && output_value <= Number(props.max)) {
        emitChange(output_value, event);
      } else {
        emitChange(Number(props.max), event);
        emit2("overlimit", event, "add");
      }
    };
    const focus = (event) => {
      if (disabled.value) return;
      if (props.readonly) return;
      emit2("focus", event);
    };
    const blur = (event) => {
      if (disabled.value) return;
      if (props.readonly) return;
      const input = event.target;
      let value = Number(input.value);
      if (value < Number(props.min)) {
        value = Number(props.min);
      } else if (value > Number(props.max)) {
        value = Number(props.max);
      }
      emitChange(value, event);
      emit2("blur", event);
    };
    const format2 = (val) => {
      let value = Number(val);
      if (value < Number(props.min)) {
        value = Number(props.min);
      } else if (value > Number(props.max)) {
        value = Number(props.max);
      }
      return value;
    };
    watch(
      () => [props.max, props.min],
      () => {
        if (Number(props.min) > Number(props.max)) {
          console.warn("[NutUI] <InputNumber>", "props.max < props.min");
        }
        const value = format2(props.modelValue);
        if (value !== Number(props.modelValue)) {
          emitChange(value, {});
        }
      }
    );
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("view", {
        class: normalizeClass(classes.value)
      }, [
        createBaseVNode("view", {
          class: normalizeClass(["nut-input-number__icon nut-input-number__left", { "nut-input-number__icon--disabled": !reduceAllow() }]),
          onClick: reduce2
        }, [
          renderSlot(_ctx.$slots, "left-icon", {}, () => [
            createVNode(unref(v$6), {
              width: unref(pxCheck)(_ctx.buttonSize),
              height: unref(pxCheck)(_ctx.buttonSize)
            }, null, 8, ["width", "height"])
          ])
        ], 2),
        createBaseVNode("input", mergeProps({ type: "number" }, _ctx.$attrs, {
          min: _ctx.min,
          max: _ctx.max,
          style: { width: unref(pxCheck)(_ctx.inputWidth), height: unref(pxCheck)(_ctx.buttonSize) },
          disabled: unref(disabled),
          readonly: _ctx.readonly,
          value: _ctx.modelValue,
          onInput: change,
          onBlur: blur,
          onFocus: focus
        }), null, 16, _hoisted_1$O),
        createBaseVNode("view", {
          class: normalizeClass(["nut-input-number__icon nut-input-number__right", { "nut-input-number__icon--disabled": !addAllow() }]),
          onClick: add
        }, [
          renderSlot(_ctx.$slots, "right-icon", {}, () => [
            createVNode(unref(w$5), {
              width: unref(pxCheck)(_ctx.buttonSize),
              height: unref(pxCheck)(_ctx.buttonSize)
            }, null, 8, ["width", "height"])
          ])
        ], 2)
      ], 2);
    };
  }
}));
withInstall(_sfc_main$13);
var __defProp$J = Object.defineProperty;
var __defProps$I = Object.defineProperties;
var __getOwnPropDescs$I = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$I = Object.getOwnPropertySymbols;
var __hasOwnProp$I = Object.prototype.hasOwnProperty;
var __propIsEnum$I = Object.prototype.propertyIsEnumerable;
var __defNormalProp$J = (obj, key, value) => key in obj ? __defProp$J(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$I = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$I.call(b, prop))
      __defNormalProp$J(a2, prop, b[prop]);
  if (__getOwnPropSymbols$I)
    for (var prop of __getOwnPropSymbols$I(b)) {
      if (__propIsEnum$I.call(b, prop))
        __defNormalProp$J(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$I = (a2, b) => __defProps$I(a2, __getOwnPropDescs$I(b));
function trimExtraChar(value, char, regExp) {
  const index2 = value.indexOf(char);
  if (index2 === -1) {
    return value;
  }
  if (char === "-" && index2 !== 0) {
    return value.slice(0, index2);
  }
  return value.slice(0, index2 + 1) + value.slice(index2).replace(regExp, "");
}
function formatNumber(value, allowDot = true, allowMinus = true) {
  if (allowDot) {
    value = trimExtraChar(value, ".", /\./g);
  } else {
    value = value.split(".")[0];
  }
  if (allowMinus) {
    value = trimExtraChar(value, "-", /-/g);
  } else {
    value = value.replace(/-/, "");
  }
  const regExp = allowDot ? /[^-0-9.]/g : /[^-0-9]/g;
  return value.replace(regExp, "");
}
function mapInputType(type) {
  if (type === "number") {
    return {
      type: "text",
      inputmode: "decimal"
    };
  }
  if (type === "digit") {
    return {
      type: "tel",
      inputmode: "numeric"
    };
  }
  return { type };
}
const _hoisted_1$N = { class: "nut-input-value" };
const _hoisted_2$E = { class: "nut-input-inner" };
const _hoisted_3$x = {
  key: 0,
  class: "nut-input-left-box"
};
const _hoisted_4$t = { class: "nut-input-box" };
const _hoisted_5$l = {
  key: 0,
  class: "nut-input-word-limit"
};
const _hoisted_6$k = { class: "nut-input-word-num" };
const _hoisted_7$g = { class: "nut-input-right-box" };
const _sfc_main$12 = /* @__PURE__ */ defineComponent(__spreadProps$I(__spreadValues$I({}, {
  name: "NutInput"
}), {
  __name: "input",
  props: {
    type: { default: "text" },
    modelValue: { default: "" },
    placeholder: { default: "" },
    inputAlign: { default: "left" },
    required: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    readonly: { type: Boolean, default: false },
    maxLength: { default: "" },
    clearable: { type: Boolean, default: false },
    clearSize: { default: "14" },
    border: { type: Boolean, default: true },
    formatTrigger: { default: "onChange" },
    formatter: {},
    showWordLimit: { type: Boolean, default: false },
    autofocus: { type: Boolean, default: false },
    confirmType: { default: "done" },
    error: { type: Boolean, default: false },
    showClearIcon: { type: Boolean, default: false }
  },
  emits: ["update:modelValue", "blur", "focus", "clear", "keypress", "click", "clickInput", "confirm"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const disabled = useFormDisabled(toRef(props, "disabled"));
    const active = ref(false);
    const inputRef = ref();
    const getModelValue = () => {
      var _a;
      return String((_a = props.modelValue) != null ? _a : "");
    };
    const renderInput = (type) => h$2("input", __spreadValues$I({}, mapInputType(type)));
    const state = reactive({
      focused: false,
      validateFailed: false,
      // 校验失败
      validateMessage: ""
      // 校验信息
    });
    const classes = computed(() => {
      const prefixCls2 = "nut-input";
      return {
        [prefixCls2]: true,
        [`${prefixCls2}--disabled`]: disabled.value,
        [`${prefixCls2}--required`]: props.required,
        [`${prefixCls2}--error`]: props.error,
        [`${prefixCls2}--border`]: props.border
      };
    });
    const styles = computed(() => {
      return {
        textAlign: props.inputAlign
      };
    });
    const onInput = (event) => {
      if (!event.target.composing) {
        const input = event.target;
        let value = input.value;
        if (props.maxLength && value.length > Number(props.maxLength)) {
          value = value.slice(0, Number(props.maxLength));
        }
        updateValue(value);
      }
    };
    const updateValue = (value, trigger2 = "onChange") => {
      var _a;
      if (["number", "digit"].includes(props.type)) {
        const isNumber = props.type === "number";
        value = formatNumber(value, isNumber, isNumber);
      }
      if (props.formatter && trigger2 === props.formatTrigger) {
        value = props.formatter(value);
      }
      if (((_a = inputRef == null ? void 0 : inputRef.value) == null ? void 0 : _a.value) !== value) {
        inputRef.value.value = value;
      }
      if (value !== props.modelValue) {
        emit2("update:modelValue", value);
      }
    };
    const onFocus = (event) => {
      if (disabled.value || props.readonly) {
        return;
      }
      active.value = true;
      emit2("focus", event);
    };
    const onBlur = (event) => {
      if (disabled.value || props.readonly) {
        return;
      }
      setTimeout(() => {
        active.value = false;
      }, 200);
      const input = event.target;
      let value = input.value;
      if (props.maxLength && value.length > Number(props.maxLength)) {
        value = value.slice(0, Number(props.maxLength));
      }
      updateValue(getModelValue(), "onBlur");
      emit2("blur", event);
    };
    const clear = (event) => {
      event.stopPropagation();
      if (disabled.value) return;
      emit2("update:modelValue", "", event);
      emit2("clear", "", event);
    };
    const resetValidation = () => {
      if (state.validateFailed) {
        state.validateFailed = false;
        state.validateMessage = "";
      }
    };
    const onClickInput = (event) => {
      if (disabled.value) {
        return;
      }
      emit2("clickInput", event);
    };
    const onClick = (event) => {
      emit2("click", event);
    };
    const startComposing = ({ target }) => {
      target.composing = true;
    };
    const endComposing = ({ target }) => {
      if (target.composing) {
        target.composing = false;
        target.dispatchEvent(new Event("input"));
      }
    };
    watch(
      () => props.modelValue,
      () => {
        updateValue(getModelValue());
        resetValidation();
      }
    );
    onMounted(() => {
      updateValue(getModelValue(), props.formatTrigger);
    });
    const focus = () => {
      var _a;
      (_a = inputRef.value) == null ? void 0 : _a.focus();
    };
    const blur = () => {
      var _a;
      (_a = inputRef.value) == null ? void 0 : _a.blur();
    };
    const select = () => {
      var _a;
      (_a = inputRef.value) == null ? void 0 : _a.select();
    };
    const onKeyup = (e) => {
      if (e.key === "Enter") {
        emit2("confirm", e);
      }
    };
    __expose({
      focus,
      blur,
      select
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("view", {
        class: normalizeClass(classes.value),
        onClick
      }, [
        createBaseVNode("view", _hoisted_1$N, [
          createBaseVNode("view", _hoisted_2$E, [
            _ctx.$slots.left ? (openBlock(), createElementBlock("view", _hoisted_3$x, [
              renderSlot(_ctx.$slots, "left")
            ])) : createCommentVNode("", true),
            createBaseVNode("view", _hoisted_4$t, [
              (openBlock(), createBlock(resolveDynamicComponent(renderInput(_ctx.type)), {
                ref_key: "inputRef",
                ref: inputRef,
                class: "input-text",
                style: normalizeStyle(styles.value),
                maxlength: _ctx.maxLength,
                placeholder: _ctx.placeholder,
                disabled: unref(disabled),
                readonly: _ctx.readonly,
                value: _ctx.modelValue,
                "format-trigger": _ctx.formatTrigger,
                autofocus: _ctx.autofocus,
                enterkeyhint: _ctx.confirmType,
                onInput,
                onFocus,
                onBlur,
                onClick: onClickInput,
                onChange: endComposing,
                onCompositionend: endComposing,
                onCompositionstart: startComposing,
                onKeyup
              }, null, 40, ["style", "maxlength", "placeholder", "disabled", "readonly", "value", "format-trigger", "autofocus", "enterkeyhint"])),
              _ctx.showWordLimit && _ctx.maxLength ? (openBlock(), createElementBlock("view", _hoisted_5$l, [
                createBaseVNode("span", _hoisted_6$k, toDisplayString(getModelValue() ? getModelValue().length : 0), 1),
                createTextVNode("/" + toDisplayString(_ctx.maxLength), 1)
              ])) : createCommentVNode("", true)
            ]),
            _ctx.clearable && !_ctx.readonly ? withDirectives((openBlock(), createElementBlock("view", {
              key: 1,
              class: "nut-input-clear-box",
              onClick: clear
            }, [
              renderSlot(_ctx.$slots, "clear", {}, () => [
                createVNode(unref(g), mergeProps({ class: "nut-input-clear" }, _ctx.$attrs, {
                  size: _ctx.clearSize,
                  width: _ctx.clearSize,
                  height: _ctx.clearSize
                }), null, 16, ["size", "width", "height"])
              ])
            ], 512)), [
              [vShow, (active.value || _ctx.showClearIcon) && getModelValue().length > 0]
            ]) : createCommentVNode("", true),
            createBaseVNode("view", _hoisted_7$g, [
              renderSlot(_ctx.$slots, "right")
            ])
          ])
        ])
      ], 2);
    };
  }
}));
withInstall(_sfc_main$12);
const RADIO_KEY = Symbol("nut-radio");
var __defProp$I = Object.defineProperty;
var __defProps$H = Object.defineProperties;
var __getOwnPropDescs$H = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$H = Object.getOwnPropertySymbols;
var __hasOwnProp$H = Object.prototype.hasOwnProperty;
var __propIsEnum$H = Object.prototype.propertyIsEnumerable;
var __defNormalProp$I = (obj, key, value) => key in obj ? __defProp$I(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$H = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$H.call(b, prop))
      __defNormalProp$I(a2, prop, b[prop]);
  if (__getOwnPropSymbols$H)
    for (var prop of __getOwnPropSymbols$H(b)) {
      if (__propIsEnum$H.call(b, prop))
        __defNormalProp$I(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$H = (a2, b) => __defProps$H(a2, __getOwnPropDescs$H(b));
const _sfc_main$11 = /* @__PURE__ */ defineComponent(__spreadProps$H(__spreadValues$H({}, {
  name: "NutRadio"
}), {
  __name: "radio",
  props: {
    disabled: { type: Boolean, default: false },
    shape: { default: "round" },
    label: { type: [String, Number, Boolean], default: "" },
    iconSize: { default: "" },
    size: { default: "normal" }
  },
  setup(__props) {
    const props = __props;
    const disabled = useFormDisabled(toRef(props, "disabled"));
    const parent = inject(RADIO_KEY, null);
    const checked = computed(() => {
      return parent.label.value === props.label;
    });
    const iconClasses = computed(() => {
      return !disabled.value ? checked.value ? "nut-radio__icon" : "nut-radio__icon--unchecked" : "nut-radio__icon--disable";
    });
    const realIconSize = computed(() => {
      return pxCheck(props.iconSize);
    });
    const labelClasses = computed(() => {
      return {
        "nut-radio__label": true,
        "nut-radio__label--disabled": disabled.value
      };
    });
    const buttonClasses = computed(() => {
      return {
        "nut-radio__button": true,
        "nut-radio__button--active": checked.value,
        [`nut-radio__button--${props.size}`]: true,
        "nut-radio__button--disabled": props.disabled
      };
    });
    const handleClick = () => {
      if (checked.value || disabled.value) return;
      parent.updateValue(props.label);
    };
    const reverseState = computed(() => parent.position.value === "left");
    const radioClasses = computed(() => {
      return {
        "nut-radio": true,
        [`nut-radio--${props.shape}`]: true,
        "nut-radio--reverse": reverseState.value
      };
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(radioClasses.value),
        onClick: handleClick
      }, [
        _ctx.shape === "button" ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(buttonClasses.value)
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 2)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          checked.value ? renderSlot(_ctx.$slots, "checkedIcon", { key: 0 }, () => [
            createVNode(unref(y$2), {
              width: realIconSize.value,
              height: realIconSize.value,
              class: normalizeClass(iconClasses.value)
            }, null, 8, ["width", "height", "class"])
          ]) : renderSlot(_ctx.$slots, "icon", { key: 1 }, () => [
            createVNode(unref(S$1), {
              width: realIconSize.value,
              height: realIconSize.value,
              class: normalizeClass(iconClasses.value)
            }, null, 8, ["width", "height", "class"])
          ]),
          createBaseVNode("div", {
            class: normalizeClass(labelClasses.value)
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 2)
        ], 64))
      ], 2);
    };
  }
}));
withInstall(_sfc_main$11);
var __defProp$H = Object.defineProperty;
var __defProps$G = Object.defineProperties;
var __getOwnPropDescs$G = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$G = Object.getOwnPropertySymbols;
var __hasOwnProp$G = Object.prototype.hasOwnProperty;
var __propIsEnum$G = Object.prototype.propertyIsEnumerable;
var __defNormalProp$H = (obj, key, value) => key in obj ? __defProp$H(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$G = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$G.call(b, prop))
      __defNormalProp$H(a2, prop, b[prop]);
  if (__getOwnPropSymbols$G)
    for (var prop of __getOwnPropSymbols$G(b)) {
      if (__propIsEnum$G.call(b, prop))
        __defNormalProp$H(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$G = (a2, b) => __defProps$G(a2, __getOwnPropDescs$G(b));
const _sfc_main$10 = /* @__PURE__ */ defineComponent(__spreadProps$G(__spreadValues$G({}, {
  name: "NutRadioGroup"
}), {
  __name: "radio-group",
  props: {
    modelValue: { type: [String, Number, Boolean], default: "" },
    direction: { default: "vertical" },
    textPosition: { default: "right" }
  },
  emits: ["change", "update:modelValue"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const updateValue = (value) => {
      emit2("update:modelValue", value);
    };
    provide(RADIO_KEY, {
      label: readonly(computed(() => props.modelValue)),
      position: readonly(computed(() => props.textPosition)),
      updateValue
    });
    watch(
      () => props.modelValue,
      (value) => {
        emit2("change", value);
      }
    );
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["nut-radio-group", `nut-radio-group--${_ctx.direction}`])
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 2);
    };
  }
}));
withInstall(_sfc_main$10);
var __defProp$G = Object.defineProperty;
var __defProps$F = Object.defineProperties;
var __getOwnPropDescs$F = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$F = Object.getOwnPropertySymbols;
var __hasOwnProp$F = Object.prototype.hasOwnProperty;
var __propIsEnum$F = Object.prototype.propertyIsEnumerable;
var __defNormalProp$G = (obj, key, value) => key in obj ? __defProp$G(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$F = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$F.call(b, prop))
      __defNormalProp$G(a2, prop, b[prop]);
  if (__getOwnPropSymbols$F)
    for (var prop of __getOwnPropSymbols$F(b)) {
      if (__propIsEnum$F.call(b, prop))
        __defNormalProp$G(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$F = (a2, b) => __defProps$F(a2, __getOwnPropDescs$F(b));
const _hoisted_1$M = ["id"];
const _hoisted_2$D = { class: "nut-rate-item__icon--full" };
const _hoisted_3$w = {
  key: 0,
  class: "nut-rate-item__icon--half"
};
const _hoisted_4$s = {
  key: 1,
  class: "nut-rate-item__icon--half"
};
const _sfc_main$$ = /* @__PURE__ */ defineComponent(__spreadProps$F(__spreadValues$F({}, {
  name: "NutRate"
}), {
  __name: "rate",
  props: {
    count: { default: 5 },
    modelValue: { default: 0 },
    customIcon: { default: () => v$2 },
    size: {},
    activeColor: { default: "" },
    voidColor: { default: "" },
    readonly: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    allowHalf: { type: Boolean, default: false },
    touchable: { type: Boolean, default: true },
    spacing: {}
  },
  emits: ["update:modelValue", "change"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const refRandomId = Math.random().toString(36).slice(-8);
    const disabled = useFormDisabled(toRef(props, "disabled"));
    const rateRefs = ref([]);
    const updateVal = (value) => {
      emit2("update:modelValue", value);
      emit2("change", value);
    };
    const onClick = (e, index2) => {
      if (disabled.value || props.readonly) return;
      let value = 0;
      if (index2 === 1 && props.modelValue === index2) {
        value = 0;
      } else {
        value = index2;
        if (props.allowHalf && e == 2) {
          value -= 0.5;
        }
      }
      updateVal(value);
    };
    const getScoreByPosition = (x, rateRefs2, allowHalf) => {
      let v2 = 0;
      for (let index2 = rateRefs2.value.length - 1; index2 >= 0; index2--) {
        const item = rateRefs2.value[index2];
        if (x > item.offsetLeft) {
          if (allowHalf) {
            v2 = index2 + (x > item.offsetLeft + item.clientWidth / 2 ? 1 : 0.5);
          } else {
            v2 = index2 + 1;
          }
          break;
        }
      }
      return v2;
    };
    const touch = useTouch();
    const onTouchStart = (event) => {
      if (!props.touchable || props.readonly) return;
      touch.start(event);
    };
    const onTouchMove = (event) => {
      if (!props.touchable) return;
      touch.move(event);
      if (touch.isHorizontal()) {
        if (rateRefs.value) {
          event.preventDefault();
          updateVal(getScoreByPosition(touch.moveX.value, rateRefs, props.allowHalf));
        }
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("view", {
        class: "nut-rate",
        onTouchstart: onTouchStart,
        onTouchmove: onTouchMove
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(Number(_ctx.count), (n) => {
          return openBlock(), createElementBlock("view", {
            id: "rateRefs-" + unref(refRandomId) + n,
            key: n,
            ref_for: true,
            ref_key: "rateRefs",
            ref: rateRefs,
            class: "nut-rate-item",
            style: normalizeStyle(n < Number(_ctx.count) ? { marginRight: unref(pxCheck)(_ctx.spacing) } : {})
          }, [
            createBaseVNode("view", _hoisted_2$D, [
              (openBlock(), createBlock(resolveDynamicComponent(
                unref(renderIcon)(_ctx.customIcon, {
                  width: _ctx.size,
                  height: _ctx.size,
                  size: _ctx.size,
                  color: n <= Number(_ctx.modelValue) ? _ctx.activeColor : _ctx.voidColor
                })
              ), {
                class: normalizeClass(["nut-rate-item__icon", { "nut-rate-item__icon--disabled": unref(disabled) || n > Number(_ctx.modelValue) }]),
                onClick: ($event) => onClick(1, n)
              }, null, 8, ["class", "onClick"]))
            ]),
            _ctx.allowHalf && Number(_ctx.modelValue) + 1 > n ? (openBlock(), createElementBlock("view", _hoisted_3$w, [
              (openBlock(), createBlock(resolveDynamicComponent(
                unref(renderIcon)(_ctx.customIcon, {
                  width: _ctx.size,
                  height: _ctx.size,
                  size: _ctx.size,
                  color: n <= Number(_ctx.modelValue) + 1 ? _ctx.activeColor : _ctx.voidColor
                })
              ), {
                class: "nut-rate-item__icon",
                onClick: ($event) => onClick(2, n)
              }, null, 8, ["onClick"]))
            ])) : _ctx.allowHalf && Number(_ctx.modelValue) + 1 < n ? (openBlock(), createElementBlock("view", _hoisted_4$s, [
              (openBlock(), createBlock(resolveDynamicComponent(unref(renderIcon)(_ctx.customIcon, { width: _ctx.size, height: _ctx.size, size: _ctx.size, color: _ctx.voidColor })), {
                class: "nut-rate-item__icon nut-rate-item__icon--disabled",
                onClick: ($event) => onClick(2, n)
              }, null, 8, ["onClick"]))
            ])) : createCommentVNode("", true)
          ], 12, _hoisted_1$M);
        }), 128))
      ], 32);
    };
  }
}));
withInstall(_sfc_main$$);
const { create: create$F } = createComponent("short-password");
const cN$i = "NutShortPassword";
const _sfc_main$_ = create$F({
  components: {
    NutPopup,
    Tips: w$1
  },
  props: {
    title: {
      type: String,
      default: ""
    },
    desc: {
      type: String,
      default: ""
    },
    tips: {
      type: String,
      default: ""
    },
    visible: {
      type: Boolean,
      default: false
    },
    modelValue: {
      type: String,
      default: ""
    },
    errorMsg: {
      type: String,
      default: ""
    },
    closeOnClickOverlay: {
      type: Boolean,
      default: true
    },
    length: {
      type: [String, Number],
      // 4～6
      default: 6
    },
    lockScroll: {
      type: Boolean,
      default: true
    }
  },
  emits: ["update:modelValue", "update:visible", "complete", "tips", "close", "focus"],
  setup(props, { emit: emit2 }) {
    const translate = useLocale(cN$i);
    const realInput = ref(props.modelValue);
    const comLen = computed(() => range(Number(props.length)));
    const show = ref(props.visible);
    const onTouchStart = (event) => {
      event.stopPropagation();
      emit2("focus");
    };
    watch(
      () => props.visible,
      (value) => {
        show.value = value;
      }
    );
    watch(
      () => props.modelValue,
      (value) => {
        realInput.value = value;
        if (String(value).length === comLen.value) {
          emit2("complete", value);
        }
      }
    );
    const close = () => {
      emit2("update:visible", false);
      emit2("close");
    };
    const range = (val) => {
      return Math.min(Math.max(4, val), 6);
    };
    const onTips = () => {
      emit2("tips");
    };
    return {
      comLen,
      realInput,
      onTouchStart,
      range,
      close,
      onTips,
      show,
      translate
    };
  }
});
const _hoisted_1$L = { class: "nut-short-password-title" };
const _hoisted_2$C = { class: "nut-short-password-subtitle" };
const _hoisted_3$v = { class: "nut-short-password-wrapper" };
const _hoisted_4$r = {
  key: 0,
  class: "nut-short-password__item-icon"
};
const _hoisted_5$k = { class: "nut-short-password__message" };
const _hoisted_6$j = { class: "nut-short-password--error" };
const _hoisted_7$f = {
  key: 0,
  class: "nut-short-password--forget"
};
function _sfc_render$F(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_tips = resolveComponent("tips");
  const _component_nut_popup = resolveComponent("nut-popup");
  return openBlock(), createElementBlock("view", null, [
    createVNode(_component_nut_popup, {
      visible: _ctx.show,
      "onUpdate:visible": _cache[2] || (_cache[2] = ($event) => _ctx.show = $event),
      style: {
        padding: "30px 24px 20px 24px",
        borderRadius: "12px",
        textAlign: "center",
        top: "45%"
      },
      closeable: true,
      "close-on-click-overlay": _ctx.closeOnClickOverlay,
      "teleport-disable": false,
      "lock-scroll": _ctx.lockScroll,
      onClickCloseIcon: _ctx.close,
      onClickOverlay: _ctx.close
    }, {
      default: withCtx(() => [
        createBaseVNode("view", _hoisted_1$L, toDisplayString(_ctx.title || _ctx.translate("title")), 1),
        createBaseVNode("view", _hoisted_2$C, toDisplayString(_ctx.desc || _ctx.translate("desc")), 1),
        createBaseVNode("div", _hoisted_3$v, [
          createBaseVNode("view", {
            class: "nut-short-password__list",
            onTouchstart: _cache[0] || (_cache[0] = (...args) => _ctx.onTouchStart && _ctx.onTouchStart(...args))
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(new Array(_ctx.comLen), (sublen, index2) => {
              return openBlock(), createElementBlock("view", {
                key: index2,
                class: "nut-short-password__item"
              }, [
                String(_ctx.realInput).length > index2 ? (openBlock(), createElementBlock("view", _hoisted_4$r)) : createCommentVNode("", true)
              ]);
            }), 128))
          ], 32)
        ]),
        createBaseVNode("view", _hoisted_5$k, [
          createBaseVNode("view", _hoisted_6$j, toDisplayString(_ctx.errorMsg), 1),
          _ctx.tips || _ctx.translate("tips") ? (openBlock(), createElementBlock("view", _hoisted_7$f, [
            createVNode(_component_tips, {
              class: "icon",
              width: "11px",
              height: "11px"
            }),
            createBaseVNode("view", {
              onClick: _cache[1] || (_cache[1] = (...args) => _ctx.onTips && _ctx.onTips(...args))
            }, toDisplayString(_ctx.tips || _ctx.translate("tips")), 1)
          ])) : createCommentVNode("", true)
        ])
      ]),
      _: 1
    }, 8, ["visible", "close-on-click-overlay", "lock-scroll", "onClickCloseIcon", "onClickOverlay"])
  ]);
}
const index$t = /* @__PURE__ */ _export_sfc(_sfc_main$_, [["render", _sfc_render$F]]);
var __defProp$F = Object.defineProperty;
var __defProps$E = Object.defineProperties;
var __getOwnPropDescs$E = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$E = Object.getOwnPropertySymbols;
var __hasOwnProp$E = Object.prototype.hasOwnProperty;
var __propIsEnum$E = Object.prototype.propertyIsEnumerable;
var __defNormalProp$F = (obj, key, value) => key in obj ? __defProp$F(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$E = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$E.call(b, prop))
      __defNormalProp$F(a2, prop, b[prop]);
  if (__getOwnPropSymbols$E)
    for (var prop of __getOwnPropSymbols$E(b)) {
      if (__propIsEnum$E.call(b, prop))
        __defNormalProp$F(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$E = (a2, b) => __defProps$E(a2, __getOwnPropDescs$E(b));
const _hoisted_1$K = ["rows", "disabled", "readonly", "value", "maxlength", "placeholder", "autofocus"];
const _hoisted_2$B = {
  key: 0,
  class: "nut-textarea__limit"
};
const cN$h = "NutTextarea";
const _sfc_main$Z = /* @__PURE__ */ defineComponent(__spreadProps$E(__spreadValues$E({}, {
  name: cN$h
}), {
  __name: "textarea",
  props: {
    modelValue: { default: "" },
    textAlign: {},
    limitShow: { type: Boolean, default: false },
    maxLength: { default: "" },
    rows: { default: "2" },
    placeholder: { default: "" },
    readonly: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    autosize: { type: [Boolean, Object], default: false },
    autofocus: { type: Boolean, default: false }
  },
  emits: ["update:modelValue", "change", "blur", "focus"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const disabled = useFormDisabled(toRef(props, "disabled"));
    const translate = useLocale(cN$h);
    const textareaRef = ref(null);
    const classes = computed(() => {
      const prefixCls2 = "nut-textarea";
      return {
        [prefixCls2]: true,
        [`${prefixCls2}--disabled`]: disabled.value
      };
    });
    const styles = computed(() => {
      return {
        textAlign: props.textAlign
      };
    });
    const setHeight = (height) => {
      const textarea = textareaRef.value;
      if (textarea && textarea.style) {
        textarea.style.height = typeof height === "number" ? `${height}px` : height;
      }
    };
    const getContentHeight = () => {
      setHeight("auto");
      if (textareaRef.value) {
        let height = textareaRef.value.scrollHeight;
        if (typeof props.autosize === "object") {
          const { maxHeight, minHeight } = props.autosize;
          if (maxHeight !== void 0) {
            height = Math.min(height, maxHeight);
          }
          if (minHeight !== void 0) {
            height = Math.max(height, minHeight);
          }
        }
        if (height) {
          setHeight(height);
        }
      }
    };
    onMounted(() => {
      if (props.modelValue) {
        emitChange(String(props.modelValue));
      }
      if (props.autosize) {
        nextTick(getContentHeight);
      }
    });
    watch(
      () => props.modelValue,
      () => {
        if (props.autosize) {
          nextTick(getContentHeight);
        }
      }
    );
    const emitChange = (value, event) => {
      if (props.maxLength && value.length > Number(props.maxLength)) {
        value = value.substring(0, Number(props.maxLength));
      }
      emit2("update:modelValue", value, event);
      emit2("change", value, event);
    };
    const change = (event) => {
      const input = event.target;
      if (!input.composing) {
        let value = input.value;
        if (props.maxLength && value.length > Number(props.maxLength)) {
          value = value.slice(0, Number(props.maxLength));
        }
        emitChange(input.value, event);
      }
    };
    const focus = (event) => {
      if (disabled.value || props.readonly) return;
      emit2("focus", event);
    };
    const blur = (event) => {
      if (disabled.value || props.readonly) return;
      const input = event.target;
      const value = input.value;
      emitChange(value, event);
      emit2("blur", { value, event });
    };
    const startComposing = ({ target }) => {
      const input = target;
      input.composing = true;
    };
    const endComposing = ({ target }) => {
      const input = target;
      if (input.composing) {
        input.composing = false;
        input.dispatchEvent(new Event("input"));
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("view", {
        class: normalizeClass(classes.value)
      }, [
        createBaseVNode("textarea", {
          ref_key: "textareaRef",
          ref: textareaRef,
          class: "nut-textarea__textarea",
          style: normalizeStyle(styles.value),
          rows: _ctx.rows,
          disabled: unref(disabled),
          readonly: _ctx.readonly,
          value: _ctx.modelValue,
          maxlength: _ctx.maxLength,
          placeholder: _ctx.placeholder || unref(translate)("placeholder"),
          autofocus: _ctx.autofocus,
          onInput: change,
          onBlur: blur,
          onFocus: focus,
          onChange: endComposing,
          onCompositionend: endComposing,
          onCompositionstart: startComposing
        }, null, 44, _hoisted_1$K),
        _ctx.limitShow ? (openBlock(), createElementBlock("view", _hoisted_2$B, toDisplayString(_ctx.modelValue ? _ctx.modelValue.length : 0) + "/" + toDisplayString(_ctx.maxLength), 1)) : createCommentVNode("", true)
      ], 2);
    };
  }
}));
withInstall(_sfc_main$Z);
const funInterceptor = (interceptor, {
  args = [],
  done,
  canceled
}) => {
  if (interceptor) {
    const returnVal = interceptor(...args);
    if (isPromise(returnVal)) {
      returnVal.then((value) => {
        if (value) {
          done(value);
        } else if (canceled) {
          canceled();
        }
      }).catch(() => {
      });
    } else if (returnVal) {
      done();
    } else if (canceled) {
      canceled();
    }
  } else {
    done();
  }
};
var __defProp$E = Object.defineProperty;
var __defProps$D = Object.defineProperties;
var __getOwnPropDescs$D = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$D = Object.getOwnPropertySymbols;
var __hasOwnProp$D = Object.prototype.hasOwnProperty;
var __propIsEnum$D = Object.prototype.propertyIsEnumerable;
var __defNormalProp$E = (obj, key, value) => key in obj ? __defProp$E(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$D = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$D.call(b, prop))
      __defNormalProp$E(a2, prop, b[prop]);
  if (__getOwnPropSymbols$D)
    for (var prop of __getOwnPropSymbols$D(b)) {
      if (__propIsEnum$D.call(b, prop))
        __defNormalProp$E(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$D = (a2, b) => __defProps$D(a2, __getOwnPropDescs$D(b));
const _hoisted_1$J = { class: "nut-progress" };
const _sfc_main$Y = /* @__PURE__ */ defineComponent(__spreadProps$D(__spreadValues$D({}, {
  name: "NutProgress"
}), {
  __name: "progress",
  props: {
    percentage: { default: 0 },
    size: { default: "base" },
    status: { default: "text" },
    strokeWidth: {},
    textInside: { type: Boolean, default: false },
    showText: { type: Boolean, default: true },
    strokeColor: {},
    textColor: {},
    textBackground: {},
    isShowPercentage: { type: Boolean, default: true }
  },
  setup(__props) {
    const props = __props;
    const height = computed(() => {
      if (props.strokeWidth) {
        return props.strokeWidth + "px";
      }
      return void 0;
    });
    const percentage = computed(() => {
      return Number(props.percentage) >= 100 ? 100 : Number(props.percentage);
    });
    const bgStyle = computed(() => {
      return {
        width: percentage.value + "%",
        background: props.strokeColor || ""
      };
    });
    const textStyle = computed(() => {
      return {
        color: props.textColor || ""
      };
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$J, [
        createBaseVNode("div", {
          class: normalizeClass(["nut-progress-outer", [_ctx.showText && !_ctx.textInside ? "nut-progress-outer-part" : "", _ctx.size ? "nut-progress-" + _ctx.size : ""]]),
          style: normalizeStyle({ height: height.value })
        }, [
          createBaseVNode("div", {
            class: normalizeClass(["nut-progress-inner", _ctx.status === "active" ? "nut-active" : ""]),
            style: normalizeStyle(bgStyle.value)
          }, null, 6),
          _ctx.showText && _ctx.textInside && !_ctx.$slots.default ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "nut-progress-text nut-progress-insidetext",
            style: normalizeStyle({
              lineHeight: height.value,
              left: `${percentage.value}%`,
              transform: `translate(-${+percentage.value}%,-50%)`,
              background: _ctx.textBackground || _ctx.strokeColor
            })
          }, [
            createBaseVNode("span", {
              style: normalizeStyle(textStyle.value)
            }, toDisplayString(percentage.value) + toDisplayString(_ctx.isShowPercentage ? "%" : ""), 5)
          ], 4)) : createCommentVNode("", true),
          _ctx.showText && _ctx.textInside && _ctx.$slots.default ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: "nut-progress-slot",
            style: normalizeStyle({
              position: `absolute`,
              top: `50%`,
              left: `${percentage.value}%`,
              transform: `translate(-${+percentage.value}%,-50%)`
            })
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 4)) : createCommentVNode("", true)
        ], 6),
        _ctx.showText && !_ctx.textInside ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: "nut-progress-text",
          style: normalizeStyle({ lineHeight: height.value })
        }, [
          _ctx.status === "text" || _ctx.status === "active" ? (openBlock(), createElementBlock("span", {
            key: 0,
            style: normalizeStyle(textStyle.value)
          }, toDisplayString(percentage.value) + toDisplayString(_ctx.isShowPercentage ? "%" : ""), 5)) : _ctx.status === "icon" ? renderSlot(_ctx.$slots, "icon-name", { key: 1 }, () => [
            createVNode(unref(g$5), {
              width: "15px",
              height: "15px",
              color: "#439422"
            })
          ]) : createCommentVNode("", true)
        ], 4)) : createCommentVNode("", true)
      ]);
    };
  }
}));
withInstall(_sfc_main$Y);
var __defProp$D = Object.defineProperty;
var __defNormalProp$D = (obj, key, value) => key in obj ? __defProp$D(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp$D(obj, typeof key !== "symbol" ? key + "" : key, value);
class UploadOptions {
  constructor() {
    __publicField(this, "url", "");
    __publicField(this, "name", "file");
    __publicField(this, "fileType", "image");
    __publicField(this, "formData");
    __publicField(this, "sourceFile");
    __publicField(this, "method", "post");
    __publicField(this, "xhrState", 200);
    __publicField(this, "timeout", 30 * 1e3);
    __publicField(this, "headers", {});
    __publicField(this, "withCredentials", false);
    __publicField(this, "onStart");
    __publicField(this, "taroFilePath");
    __publicField(this, "onProgress");
    __publicField(this, "onSuccess");
    __publicField(this, "onFailure");
    __publicField(this, "beforeXhrUpload");
  }
}
class Uploader {
  constructor(options) {
    __publicField(this, "options");
    this.options = options;
  }
  upload() {
    var _a;
    const options = this.options;
    const xhr = new XMLHttpRequest();
    xhr.timeout = options.timeout;
    if (xhr.upload) {
      xhr.upload.addEventListener(
        "progress",
        (e) => {
          var _a2;
          (_a2 = options.onProgress) == null ? void 0 : _a2.call(options, e, options);
        },
        false
      );
      xhr.onreadystatechange = () => {
        var _a2, _b;
        if (xhr.readyState === 4) {
          if (xhr.status == options.xhrState) {
            (_a2 = options.onSuccess) == null ? void 0 : _a2.call(options, xhr.responseText, options);
          } else {
            (_b = options.onFailure) == null ? void 0 : _b.call(options, xhr.responseText, options);
          }
        }
      };
      xhr.withCredentials = options.withCredentials;
      xhr.open(options.method, options.url, true);
      for (const [key, value] of Object.entries(options.headers)) {
        xhr.setRequestHeader(key, value);
      }
      (_a = options.onStart) == null ? void 0 : _a.call(options, options);
      if (options.beforeXhrUpload) {
        options.beforeXhrUpload(xhr, options);
      } else {
        xhr.send(options.formData);
      }
    } else {
      console.warn("浏览器不支持 XMLHttpRequest");
    }
  }
}
class FileItem {
  constructor() {
    __publicField(this, "status", "ready");
    __publicField(this, "message", "");
    __publicField(this, "uid", (/* @__PURE__ */ new Date()).getTime().toString());
    __publicField(this, "name");
    __publicField(this, "url");
    __publicField(this, "type");
    __publicField(this, "path");
    __publicField(this, "percentage", 0);
    __publicField(this, "formData", {});
  }
}
const { create: create$E } = createComponent("uploader");
const cN$g = "NutUploader";
const _sfc_main$X = create$E({
  components: {
    NutProgress: _sfc_main$Y,
    Photograph: z,
    Failure: C$2,
    Loading: u,
    Del: w$9,
    Link: C$1
  },
  props: {
    name: { type: String, default: "file" },
    url: { type: String, default: "" },
    // defaultFileList: { type: Array, default: () => new Array<FileItem>() },
    timeout: { type: [Number, String], default: 1e3 * 30 },
    fileList: { type: Array, default: () => [] },
    isPreview: { type: Boolean, default: true },
    // picture、list
    listType: { type: String, default: "picture" },
    isDeletable: { type: Boolean, default: true },
    method: { type: String, default: "post" },
    capture: { type: Boolean, default: false },
    maximize: { type: [Number, String], default: Number.MAX_VALUE },
    maximum: { type: [Number, String], default: 1 },
    clearInput: { type: Boolean, default: true },
    accept: { type: String, default: "*" },
    headers: { type: Object, default: {} },
    data: { type: Object, default: {} },
    xhrState: { type: [Number, String], default: 200 },
    withCredentials: { type: Boolean, default: false },
    multiple: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false },
    autoUpload: { type: Boolean, default: true },
    beforeUpload: {
      type: Function,
      default: null
    },
    beforeXhrUpload: {
      type: Function,
      default: null
    },
    beforeDelete: {
      type: Function,
      default: () => {
        return true;
      }
    },
    onChange: { type: Function }
  },
  emits: [
    "start",
    "progress",
    "oversize",
    "success",
    "failure",
    "change",
    "delete",
    "update:fileList",
    "fileItemClick"
  ],
  setup(props, { emit: emit2 }) {
    const disabled = useFormDisabled(toRef(props, "disabled"));
    const translate = useLocale(cN$g);
    const fileList = ref(props.fileList);
    const uploadQueue = ref([]);
    watch(
      () => props.fileList,
      () => {
        fileList.value = props.fileList;
      }
    );
    const renderInput = () => {
      let params = {
        class: `nut-uploader__input`,
        type: "file",
        accept: props.accept,
        multiple: props.multiple,
        name: props.name,
        disabled: disabled.value
      };
      if (props.capture) {
        params.capture = "camera";
        if (!params.accept) {
          params.accept = "image/*";
        }
      }
      return h$2("input", params);
    };
    const clearInput = (el) => {
      el.value = "";
    };
    const fileItemClick = (fileItem) => {
      emit2("fileItemClick", { fileItem });
    };
    const executeUpload = (fileItem, index2) => {
      const uploadOption = new UploadOptions();
      uploadOption.url = props.url;
      uploadOption.formData = fileItem.formData;
      uploadOption.timeout = props.timeout * 1;
      uploadOption.method = props.method;
      uploadOption.xhrState = props.xhrState;
      uploadOption.headers = props.headers;
      uploadOption.withCredentials = props.withCredentials;
      uploadOption.beforeXhrUpload = props.beforeXhrUpload;
      try {
        uploadOption.sourceFile = fileItem.formData.get(props.name);
      } catch (error) {
        console.warn("[NutUI] <Uploader> formData.get(name)", error);
      }
      uploadOption.onStart = (option) => {
        fileItem.status = "ready";
        fileItem.message = translate("readyUpload");
        clearUploadQueue(index2);
        emit2("start", option);
      };
      uploadOption.onProgress = (event, option) => {
        fileItem.status = "uploading";
        fileItem.message = translate("uploading");
        fileItem.percentage = (event.loaded / event.total * 100).toFixed(0);
        emit2("progress", { event, option, percentage: fileItem.percentage });
      };
      uploadOption.onSuccess = (responseText, option) => {
        fileItem.status = "success";
        fileItem.message = translate("success");
        emit2("success", {
          responseText,
          option,
          fileItem
        });
        emit2("update:fileList", fileList.value);
      };
      uploadOption.onFailure = (responseText, option) => {
        fileItem.status = "error";
        fileItem.message = translate("error");
        emit2("failure", {
          responseText,
          option,
          fileItem
        });
      };
      let task = new Uploader(uploadOption);
      if (props.autoUpload) {
        task.upload();
      } else {
        uploadQueue.value.push(
          new Promise((resolve2) => {
            resolve2(task);
          })
        );
      }
    };
    const clearUploadQueue = (index2 = -1) => {
      if (index2 > -1) {
        uploadQueue.value.splice(index2, 1);
      } else {
        uploadQueue.value = [];
        fileList.value = [];
        emit2("update:fileList", fileList.value);
      }
    };
    const submit = () => {
      Promise.all(uploadQueue.value).then((res) => {
        res.forEach((i2) => i2.upload());
      });
    };
    const readFile = (files) => {
      files.forEach((file, index2) => {
        const formData = new FormData();
        for (const [key, value] of Object.entries(props.data)) {
          formData.append(key, value);
        }
        formData.append(props.name, file);
        const fileItem = reactive(new FileItem());
        fileItem.name = file.name;
        fileItem.status = "ready";
        fileItem.type = file.type;
        fileItem.formData = formData;
        fileItem.message = translate("waitingUpload");
        executeUpload(fileItem, index2);
        if (props.isPreview && file.type.includes("image")) {
          const reader = new FileReader();
          reader.onload = (event) => {
            fileItem.url = event.target.result;
            fileList.value.push(fileItem);
          };
          reader.readAsDataURL(file);
        } else {
          fileList.value.push(fileItem);
        }
      });
    };
    const filterFiles = (files) => {
      const maximum = props.maximum * 1;
      const maximize = props.maximize * 1;
      const oversizes = new Array();
      files = files.filter((file) => {
        if (file.size > maximize) {
          oversizes.push(file);
          return false;
        } else {
          return true;
        }
      });
      if (oversizes.length) {
        emit2("oversize", oversizes);
      }
      let currentFileLength = files.length + fileList.value.length;
      if (currentFileLength > maximum) {
        files.splice(files.length - (currentFileLength - maximum));
      }
      return files;
    };
    const deleted = (file, index2) => {
      fileList.value.splice(index2, 1);
      emit2("delete", {
        file,
        fileList: fileList.value,
        index: index2
      });
    };
    const onDelete = (file, index2) => {
      if (disabled.value) return;
      clearUploadQueue(index2);
      funInterceptor(props.beforeDelete, {
        args: [file, fileList.value],
        done: () => deleted(file, index2)
      });
    };
    const onChange = (event) => {
      if (props.disabled || disabled.value) {
        return;
      }
      const $el = event.target;
      let { files } = $el;
      if (props.beforeUpload) {
        props.beforeUpload(files).then((f2) => changeReadFile(f2));
      } else {
        changeReadFile(files);
      }
      emit2("change", {
        fileList: fileList.value,
        event
      });
      if (props.clearInput) {
        clearInput($el);
      }
    };
    const changeReadFile = (f2) => {
      const _files = filterFiles(new Array().slice.call(f2));
      readFile(_files);
    };
    return {
      onChange,
      onDelete,
      fileList,
      fileItemClick,
      clearUploadQueue,
      submit,
      renderInput
    };
  }
});
const _hoisted_1$I = { class: "nut-uploader" };
const _hoisted_2$A = {
  key: 0,
  class: "nut-uploader__slot"
};
const _hoisted_3$u = {
  key: 0,
  class: "nut-uploader__preview-img"
};
const _hoisted_4$q = {
  key: 0,
  class: "nut-uploader__preview__progress"
};
const _hoisted_5$j = { class: "nut-uploader__preview__progress__msg" };
const _hoisted_6$i = ["onClick"];
const _hoisted_7$e = ["src", "onClick"];
const _hoisted_8$b = {
  key: 3,
  class: "nut-uploader__preview-img__file"
};
const _hoisted_9$6 = ["onClick"];
const _hoisted_10$5 = { class: "file__name_tips" };
const _hoisted_11$4 = { class: "tips" };
const _hoisted_12$4 = {
  key: 1,
  class: "nut-uploader__preview-list"
};
const _hoisted_13$3 = ["onClick"];
const _hoisted_14$2 = { class: "file__name_tips" };
function _sfc_render$E(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Failure = resolveComponent("Failure");
  const _component_Loading = resolveComponent("Loading");
  const _component_Link = resolveComponent("Link");
  const _component_Del = resolveComponent("Del");
  const _component_nut_progress = resolveComponent("nut-progress");
  const _component_Photograph = resolveComponent("Photograph");
  return openBlock(), createElementBlock("view", _hoisted_1$I, [
    _ctx.$slots.default ? (openBlock(), createElementBlock("view", _hoisted_2$A, [
      renderSlot(_ctx.$slots, "default"),
      Number(_ctx.maximum) - _ctx.fileList.length ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.renderInput), {
        key: 0,
        onChange: _ctx.onChange
      }, null, 40, ["onChange"])) : createCommentVNode("", true)
    ])) : createCommentVNode("", true),
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.fileList, (item, index2) => {
      var _a;
      return openBlock(), createElementBlock("view", {
        key: item.uid,
        class: normalizeClass(["nut-uploader__preview", [_ctx.listType]])
      }, [
        _ctx.listType == "picture" && !_ctx.$slots.default ? (openBlock(), createElementBlock("view", _hoisted_3$u, [
          item.status != "success" ? (openBlock(), createElementBlock("view", _hoisted_4$q, [
            item.status != "ready" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              item.status == "error" ? (openBlock(), createBlock(_component_Failure, {
                key: 0,
                color: "#fff"
              })) : (openBlock(), createBlock(_component_Loading, {
                key: 1,
                name: "loading",
                color: "#fff"
              }))
            ], 64)) : createCommentVNode("", true),
            createBaseVNode("view", _hoisted_5$j, toDisplayString(item.message), 1)
          ])) : createCommentVNode("", true),
          _ctx.isDeletable ? (openBlock(), createElementBlock("view", {
            key: 1,
            class: "close",
            onClick: ($event) => _ctx.onDelete(item, index2)
          }, [
            renderSlot(_ctx.$slots, "delete-icon", {}, () => [
              createVNode(_component_Failure)
            ])
          ], 8, _hoisted_6$i)) : createCommentVNode("", true),
          ((_a = item == null ? void 0 : item.type) == null ? void 0 : _a.includes("image")) && item.url ? (openBlock(), createElementBlock("img", {
            key: 2,
            class: "nut-uploader__preview-img__c",
            src: item.url,
            onClick: ($event) => _ctx.fileItemClick(item)
          }, null, 8, _hoisted_7$e)) : (openBlock(), createElementBlock("view", _hoisted_8$b, [
            createBaseVNode("view", {
              class: "nut-uploader__preview-img__file__name",
              onClick: ($event) => _ctx.fileItemClick(item)
            }, [
              createBaseVNode("view", _hoisted_10$5, toDisplayString(item.name), 1)
            ], 8, _hoisted_9$6)
          ])),
          createBaseVNode("view", _hoisted_11$4, toDisplayString(item.name), 1)
        ])) : _ctx.listType == "list" ? (openBlock(), createElementBlock("view", _hoisted_12$4, [
          createBaseVNode("view", {
            class: normalizeClass(["nut-uploader__preview-img__file__name", [item.status]]),
            onClick: ($event) => _ctx.fileItemClick(item)
          }, [
            createVNode(_component_Link, { class: "nut-uploader__preview-img__file__link" }),
            createBaseVNode("view", _hoisted_14$2, toDisplayString(item.name), 1),
            _ctx.isDeletable ? (openBlock(), createBlock(_component_Del, {
              key: 0,
              color: "#808080",
              class: "nut-uploader__preview-img__file__del",
              onClick: withModifiers(($event) => _ctx.onDelete(item, index2), ["stop"])
            }, null, 8, ["onClick"])) : createCommentVNode("", true)
          ], 10, _hoisted_13$3),
          item.status == "uploading" ? (openBlock(), createBlock(_component_nut_progress, {
            key: 0,
            size: "small",
            percentage: item.percentage,
            "stroke-color": "linear-gradient(270deg, rgba(18,126,255,1) 0%,rgba(32,147,255,1) 32.815625%,rgba(13,242,204,1) 100%)",
            "show-text": false
          }, null, 8, ["percentage"])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ], 2);
    }), 128)),
    _ctx.listType == "picture" && !_ctx.$slots.default && Number(_ctx.maximum) - _ctx.fileList.length ? (openBlock(), createElementBlock("view", {
      key: 1,
      class: normalizeClass(["nut-uploader__upload", [_ctx.listType]])
    }, [
      renderSlot(_ctx.$slots, "upload-icon", {}, () => [
        createVNode(_component_Photograph, { color: "#808080" })
      ]),
      (openBlock(), createBlock(resolveDynamicComponent(_ctx.renderInput), { onChange: _ctx.onChange }, null, 40, ["onChange"]))
    ], 2)) : createCommentVNode("", true)
  ]);
}
const index$s = /* @__PURE__ */ _export_sfc(_sfc_main$X, [["render", _sfc_render$E]]);
const { create: create$D } = createComponent("number-keyboard");
const cN$f = "NutNumberKeyboard";
const _sfc_main$W = create$D({
  components: {
    NutPopup
  },
  props: {
    confirmText: {
      type: String,
      default: ""
    },
    title: {
      type: String,
      default: ""
    },
    visible: {
      type: Boolean,
      default: false
    },
    type: {
      type: String,
      default: "default"
    },
    customKey: {
      type: Array,
      default: () => []
    },
    modelValue: {
      type: String,
      default: ""
    },
    maxlength: {
      type: [Number, String],
      default: 6
    },
    randomKeys: {
      type: Boolean,
      default: false
    },
    popClass: {
      type: String,
      default: ""
    },
    lockScroll: {
      type: Boolean,
      default: true
    }
  },
  emits: ["input", "delete", "close", "blur", "confirm", "update:modelValue", "update:visible"],
  setup(props, { emit: emit2 }) {
    const translate = useLocale(cN$f);
    const clickKeyIndex = ref(void 0);
    const show = ref(props.visible);
    const root = ref();
    function defaultKey() {
      const { customKey } = props;
      let object = {
        id: "lock",
        type: "lock"
      };
      let customKeys = Array.isArray(customKey) ? customKey : [customKey];
      if (customKeys.length === 1) {
        object = {
          id: customKeys[0],
          type: "custom"
        };
      }
      return [...getBasicKeys(), object, { id: 0, type: "number" }, { id: "delete", type: "delete" }];
    }
    function getBasicKeys() {
      const keys = [];
      for (let i2 = 1; i2 <= 9; i2++) {
        keys.push({ id: i2, type: "number" });
      }
      if (props.randomKeys) {
        return keys.sort(() => Math.random() > 0.5 ? 1 : -1);
      }
      return keys;
    }
    function genCustomKeys() {
      const keys = getBasicKeys();
      const { customKey } = props;
      let customKeys = Array.isArray(customKey) ? customKey : [customKey];
      if (customKeys.length > 2) {
        customKeys = [customKeys[0], customKeys[1]];
      }
      if (customKeys.length == 2 && props.title && props.type != "rightColumn") {
        customKeys = [customKeys[0]];
      }
      if (customKeys.length === 1) {
        if (props.title && props.type != "rightColumn") {
          keys.push({ id: customKeys[0], type: "custom" }, { id: 0, type: "number" }, { id: "delete", type: "delete" });
        } else {
          keys.push({ id: 0, type: "number" }, { id: customKeys[0], type: "custom" });
        }
      } else if (customKeys.length === 2) {
        keys.push(
          { id: customKeys[0], type: "custom" },
          { id: 0, type: "number" },
          { id: customKeys[1], type: "custom" }
        );
      }
      return keys;
    }
    const keysList = computed(() => {
      if (props.type == "rightColumn" || props.title != "") {
        return genCustomKeys();
      }
      return defaultKey();
    });
    const onBlur = () => {
      if (props.visible) {
        emit2("blur");
      }
    };
    const clickAway = (event) => {
      const element = root.value;
      let el = element && !element.contains(event.target);
      if (el) {
        onBlur();
      }
    };
    watch(
      () => props.visible,
      (value) => {
        show.value = value;
        if (value) {
          window.addEventListener("touchstart", clickAway, false);
        } else {
          window.removeEventListener("touchstart", clickAway, false);
        }
      }
    );
    function onTouchstart(item, event) {
      event.stopPropagation();
      clickKeyIndex.value = item.id;
      if (item.type == "number" || item.type == "custom") {
        emit2("input", item.id);
        if (props.modelValue.length < +props.maxlength) {
          emit2("update:modelValue", props.modelValue + item.id);
        }
      }
      if (item.type == "lock") {
        closeBoard();
      }
      if (item.type == "delete") {
        emit2("delete");
        emit2("update:modelValue", props.modelValue.slice(0, props.modelValue.length - 1));
      }
    }
    function onTouchMove(event) {
      event.stopPropagation();
    }
    function onTouchEnd(event) {
      event.preventDefault();
      clickKeyIndex.value = void 0;
    }
    function closeBoard() {
      emit2("update:visible", false);
      emit2("close");
    }
    const confirm = () => {
      emit2("confirm");
    };
    return {
      clickKeyIndex,
      defaultKey,
      closeBoard,
      confirm,
      onTouchEnd,
      onTouchMove,
      onTouchstart,
      keysList,
      genCustomKeys,
      getBasicKeys,
      root,
      show,
      translate
    };
  }
});
const _hoisted_1$H = { ref: "root" };
const _hoisted_2$z = { class: "nut-number-keyboard" };
const _hoisted_3$t = {
  key: 0,
  class: "nut-number-keyboard__header"
};
const _hoisted_4$p = { class: "nut-number-keyboard__title" };
const _hoisted_5$i = { class: "nut-number-keyboard__body" };
const _hoisted_6$h = { class: "nut-number-keyboard__keys" };
const _hoisted_7$d = ["onTouchstart"];
const _hoisted_8$a = {
  key: 1,
  src: "https://img11.360buyimg.com/imagetools/jfs/t1/146371/38/8485/738/5f606425Eca239740/14f4b4f5f20d8a68.png"
};
const _hoisted_9$5 = {
  key: 2,
  src: "https://img11.360buyimg.com/imagetools/jfs/t1/129395/8/12735/2030/5f61ac37E70cab338/fb477dc11f46056c.png"
};
const _hoisted_10$4 = {
  key: 0,
  class: "nut-number-keyboard__sidebar"
};
const _hoisted_11$3 = { class: "nut-key__wrapper" };
const _hoisted_12$3 = /* @__PURE__ */ createBaseVNode("img", { src: "https://img11.360buyimg.com/imagetools/jfs/t1/129395/8/12735/2030/5f61ac37E70cab338/fb477dc11f46056c.png" }, null, -1);
const _hoisted_13$2 = [
  _hoisted_12$3
];
function _sfc_render$D(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_popup = resolveComponent("nut-popup");
  return openBlock(), createElementBlock("div", _hoisted_1$H, [
    createVNode(_component_nut_popup, {
      visible: _ctx.show,
      "onUpdate:visible": _cache[7] || (_cache[7] = ($event) => _ctx.show = $event),
      position: "bottom",
      "pop-class": _ctx.popClass,
      overlay: false,
      "lock-scroll": _ctx.lockScroll,
      "teleport-disable": false
    }, {
      default: withCtx(() => [
        createBaseVNode("div", _hoisted_2$z, [
          _ctx.title ? (openBlock(), createElementBlock("div", _hoisted_3$t, [
            createBaseVNode("h3", _hoisted_4$p, toDisplayString(_ctx.title), 1),
            _ctx.type == "default" ? (openBlock(), createElementBlock("span", {
              key: 0,
              class: "nut-number-keyboard__close",
              onClick: _cache[0] || (_cache[0] = ($event) => _ctx.closeBoard())
            }, toDisplayString(_ctx.translate("done")), 1)) : createCommentVNode("", true)
          ])) : createCommentVNode("", true),
          createBaseVNode("div", _hoisted_5$i, [
            createBaseVNode("div", _hoisted_6$h, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.keysList, (item) => {
                return openBlock(), createElementBlock("div", {
                  key: "key" + item.id,
                  class: normalizeClass([
                    "nut-key__wrapper",
                    {
                      "nut-key__wrapper--wider": item.id == 0 && _ctx.type == "rightColumn" && Array.isArray(_ctx.customKey) && _ctx.customKey.length == 1
                    }
                  ])
                }, [
                  createBaseVNode("div", {
                    class: normalizeClass([
                      "nut-key",
                      { "nut-key--active": item.id == _ctx.clickKeyIndex },
                      { "nut-key--lock": item.type == "lock" },
                      { "nut-key--delete": item.type == "delete" }
                    ]),
                    onTouchstart: (event) => _ctx.onTouchstart(item, event),
                    onTouchmove: _cache[1] || (_cache[1] = (event) => _ctx.onTouchMove(event)),
                    onTouchend: _cache[2] || (_cache[2] = (event) => _ctx.onTouchEnd(event))
                  }, [
                    item.type == "number" || item.type == "custom" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                      createTextVNode(toDisplayString(item.id), 1)
                    ], 64)) : createCommentVNode("", true),
                    item.type == "lock" ? (openBlock(), createElementBlock("img", _hoisted_8$a)) : createCommentVNode("", true),
                    item.type == "delete" ? (openBlock(), createElementBlock("img", _hoisted_9$5)) : createCommentVNode("", true)
                  ], 42, _hoisted_7$d)
                ], 2);
              }), 128))
            ]),
            _ctx.type == "rightColumn" ? (openBlock(), createElementBlock("div", _hoisted_10$4, [
              createBaseVNode("div", _hoisted_11$3, [
                createBaseVNode("div", {
                  class: normalizeClass(["nut-key", { active: _ctx.clickKeyIndex == "delete" }]),
                  onTouchstart: _cache[3] || (_cache[3] = (event) => _ctx.onTouchstart({ id: "delete", type: "delete" }, event)),
                  onTouchmove: _cache[4] || (_cache[4] = (event) => _ctx.onTouchMove(event)),
                  onTouchend: _cache[5] || (_cache[5] = (...args) => _ctx.onTouchEnd && _ctx.onTouchEnd(...args))
                }, _hoisted_13$2, 34)
              ]),
              createBaseVNode("div", {
                class: "nut-key__wrapper nut-key__wrapper--finish",
                onClick: _cache[6] || (_cache[6] = (...args) => _ctx.confirm && _ctx.confirm(...args))
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(["nut-key", "nut-key--finish ", { activeFinsh: _ctx.clickKeyIndex == "finish" }])
                }, toDisplayString(_ctx.confirmText || _ctx.translate("done")), 3)
              ])
            ])) : createCommentVNode("", true)
          ])
        ])
      ]),
      _: 1
    }, 8, ["visible", "pop-class", "lock-scroll"])
  ], 512);
}
const index$r = /* @__PURE__ */ _export_sfc(_sfc_main$W, [["render", _sfc_render$D]]);
var __defProp$C = Object.defineProperty;
var __defProps$C = Object.defineProperties;
var __getOwnPropDescs$C = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$C = Object.getOwnPropertySymbols;
var __hasOwnProp$C = Object.prototype.hasOwnProperty;
var __propIsEnum$C = Object.prototype.propertyIsEnumerable;
var __defNormalProp$C = (obj, key, value) => key in obj ? __defProp$C(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$C = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$C.call(b, prop))
      __defNormalProp$C(a2, prop, b[prop]);
  if (__getOwnPropSymbols$C)
    for (var prop of __getOwnPropSymbols$C(b)) {
      if (__propIsEnum$C.call(b, prop))
        __defNormalProp$C(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$C = (a2, b) => __defProps$C(a2, __getOwnPropDescs$C(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$C.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$C)
    for (var prop of __getOwnPropSymbols$C(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$C.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __async$1 = (__this, __arguments, generator) => {
  return new Promise((resolve2, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve2(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const _sfc_main$V = /* @__PURE__ */ defineComponent(__spreadProps$C(__spreadValues$C({}, {
  name: "NutForm"
}), {
  __name: "form",
  props: {
    modelValue: { default: () => ({}) },
    rules: { default: () => ({}) },
    disabled: { type: Boolean, default: false },
    labelPosition: { default: "left" },
    starPosition: { default: "left" }
  },
  emits: ["validate"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const { children, linkChildren } = useChildren(FORM_KEY);
    linkChildren({ props });
    const { linkChildren: linkChildren2 } = useChildren(FORM_DISABLED_KEY);
    linkChildren2({ props });
    const formErrorTip = computed(() => reactive({}));
    provide(FORM_TIP_KEY, formErrorTip);
    const clearErrorTips = () => {
      Object.keys(formErrorTip.value).forEach((item) => {
        formErrorTip.value[item] = "";
      });
    };
    const reset = () => {
      clearErrorTips();
    };
    watch(
      () => props.modelValue,
      () => {
        clearErrorTips();
      },
      { immediate: true }
    );
    const getTaskFromChildren = () => {
      const task = [];
      children.forEach((item) => {
        task.push({
          prop: item == null ? void 0 : item["prop"],
          rules: (item == null ? void 0 : item["rules"]) || []
        });
      });
      return task;
    };
    const tipMessage = (errorMsg) => {
      if (errorMsg.message) {
        emit2("validate", errorMsg);
      }
      formErrorTip.value[errorMsg.prop] = errorMsg.message;
    };
    const checkRule = (item) => __async$1(this, null, function* () {
      const { rules = [], prop } = item;
      const _Promise = (errorMsg) => {
        return new Promise((resolve2, reject) => {
          try {
            tipMessage(errorMsg);
            resolve2(errorMsg);
          } catch (error) {
            reject(error);
          }
        });
      };
      if (!prop) {
        console.warn("[NutUI] <FormItem> 使用 rules 校验规则时 , 必须设置 prop 参数");
      }
      const value = getPropByPath(props.modelValue, prop || "");
      tipMessage({ prop, message: "" });
      const formRules = props.rules || {};
      const _rules = [...(formRules == null ? void 0 : formRules[prop]) || [], ...rules];
      while (_rules.length) {
        const rule = _rules.shift();
        const _a = rule, { validator } = _a, ruleWithoutValidator = __objRest(_a, ["validator"]);
        const { required, regex, message } = ruleWithoutValidator;
        const errorMsg = { prop, message: message || "" };
        if (required) {
          if (!value && value !== 0) {
            return _Promise(errorMsg);
          }
        }
        if (regex && !regex.test(String(value))) {
          return _Promise(errorMsg);
        }
        if (validator) {
          const result = validator(value, ruleWithoutValidator);
          if (isPromise(result)) {
            try {
              const value2 = yield result;
              if (value2 === false) {
                return _Promise(errorMsg);
              }
            } catch (error) {
              const validateErrorMsg = { prop, message: error };
              return _Promise(validateErrorMsg);
            }
          } else {
            if (!result) {
              return _Promise(errorMsg);
            }
          }
        }
      }
      return Promise.resolve(true);
    });
    const validate = (customProp = "") => {
      return new Promise((resolve2, reject) => {
        try {
          const task = getTaskFromChildren();
          const errors = task.map((item) => {
            if (customProp && customProp !== item.prop) {
              return Promise.resolve(true);
            }
            return checkRule(item);
          });
          Promise.all(errors).then((errorRes) => {
            errorRes = errorRes.filter((item) => item !== true);
            const res = { valid: true, errors: [] };
            if (errorRes.length) {
              res.valid = false;
              res.errors = errorRes;
            }
            resolve2(res);
          });
        } catch (error) {
          reject(error);
        }
      });
    };
    const submit = () => {
      validate();
      return false;
    };
    __expose({
      submit,
      reset,
      validate
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("form", {
        class: "nut-form",
        action: "#",
        onSubmit: withModifiers(() => false, ["prevent"])
      }, [
        createVNode(unref(_sfc_main$1E), null, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        })
      ], 32);
    };
  }
}));
withInstall(_sfc_main$V);
var __defProp$B = Object.defineProperty;
var __defProps$B = Object.defineProperties;
var __getOwnPropDescs$B = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$B = Object.getOwnPropertySymbols;
var __hasOwnProp$B = Object.prototype.hasOwnProperty;
var __propIsEnum$B = Object.prototype.propertyIsEnumerable;
var __defNormalProp$B = (obj, key, value) => key in obj ? __defProp$B(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$B = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$B.call(b, prop))
      __defNormalProp$B(a2, prop, b[prop]);
  if (__getOwnPropSymbols$B)
    for (var prop of __getOwnPropSymbols$B(b)) {
      if (__propIsEnum$B.call(b, prop))
        __defNormalProp$B(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$B = (a2, b) => __defProps$B(a2, __getOwnPropDescs$B(b));
const _hoisted_1$G = { class: "nut-cell__value nut-form-item__body" };
const _sfc_main$U = /* @__PURE__ */ defineComponent(__spreadProps$B(__spreadValues$B({}, {
  name: "NutFormItem",
  inheritAttrs: false
}), {
  __name: "form-item",
  props: {
    prop: { default: "" },
    label: { default: "" },
    rules: { default: () => [] },
    required: { type: Boolean, default: false },
    showErrorMessage: { type: Boolean, default: true },
    showErrorLine: { type: Boolean, default: true },
    labelWidth: {},
    labelAlign: {},
    errorMessageAlign: {},
    bodyAlign: {},
    labelPosition: {},
    starPosition: {}
  },
  setup(__props) {
    const props = __props;
    const { parent: parentObj } = useParent(FORM_KEY);
    const isRequired = computed(() => {
      var _a;
      const rules = (_a = parentObj.props) == null ? void 0 : _a.rules;
      let formRequired = false;
      for (const key in rules) {
        if (Object.prototype.hasOwnProperty.call(rules, key) && key === props.prop && Array.isArray(rules[key])) {
          formRequired = rules[key].some((rule) => rule.required);
        }
      }
      return props.required || props.rules.some((rule) => rule.required) || formRequired;
    });
    const labelPositionClass = computed(() => {
      const labelPosition = parentObj.props.labelPosition;
      const position = props.labelPosition ? props.labelPosition : labelPosition;
      return position !== "left" ? `nut-form-item__${position}` : "";
    });
    const starPositionClass = computed(() => {
      const starPosition = parentObj.props.starPosition;
      const position = props.starPosition ? props.starPosition : starPosition;
      return position !== "left" ? `nut-form-item__star-${position}` : "";
    });
    const parent = inject(FORM_TIP_KEY);
    const labelStyle = computed(() => {
      return {
        width: pxCheck(props.labelWidth),
        textAlign: props.labelAlign
      };
    });
    const bodyStyle = computed(() => {
      return {
        textAlign: props.bodyAlign
      };
    });
    const errorMessageStyle = computed(() => {
      return {
        textAlign: props.errorMessageAlign
      };
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(_sfc_main$1F), {
        class: normalizeClass(["nut-form-item", [{ error: unref(parent)[_ctx.prop], line: _ctx.showErrorLine }, _ctx.$attrs.class, labelPositionClass.value]]),
        style: normalizeStyle(_ctx.$attrs.style)
      }, {
        default: withCtx(() => [
          _ctx.label || _ctx.$slots.label ? (openBlock(), createElementBlock("view", {
            key: 0,
            class: normalizeClass(["nut-cell__title nut-form-item__label", { required: isRequired.value, [starPositionClass.value]: starPositionClass.value }]),
            style: normalizeStyle(labelStyle.value)
          }, [
            renderSlot(_ctx.$slots, "label", {}, () => [
              createTextVNode(toDisplayString(_ctx.label), 1)
            ])
          ], 6)) : createCommentVNode("", true),
          createBaseVNode("view", _hoisted_1$G, [
            createBaseVNode("view", {
              class: "nut-form-item__body__slots",
              style: normalizeStyle(bodyStyle.value)
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 4),
            unref(parent)[_ctx.prop] && _ctx.showErrorMessage ? (openBlock(), createElementBlock("view", {
              key: 0,
              class: "nut-form-item__body__tips",
              style: normalizeStyle(errorMessageStyle.value)
            }, toDisplayString(unref(parent)[_ctx.prop]), 5)) : createCommentVNode("", true)
          ])
        ]),
        _: 3
      }, 8, ["class", "style"]);
    };
  }
}));
withInstall(_sfc_main$U);
const SWIPE_KEY = Symbol("nut-swipe");
var __defProp$A = Object.defineProperty;
var __defProps$A = Object.defineProperties;
var __getOwnPropDescs$A = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$A = Object.getOwnPropertySymbols;
var __hasOwnProp$A = Object.prototype.hasOwnProperty;
var __propIsEnum$A = Object.prototype.propertyIsEnumerable;
var __defNormalProp$A = (obj, key, value) => key in obj ? __defProp$A(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$A = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$A.call(b, prop))
      __defNormalProp$A(a2, prop, b[prop]);
  if (__getOwnPropSymbols$A)
    for (var prop of __getOwnPropSymbols$A(b)) {
      if (__propIsEnum$A.call(b, prop))
        __defNormalProp$A(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$A = (a2, b) => __defProps$A(a2, __getOwnPropDescs$A(b));
const _sfc_main$T = /* @__PURE__ */ defineComponent(__spreadProps$A(__spreadValues$A({}, {
  name: "NutSwipe"
}), {
  __name: "swipe",
  props: {
    name: { default: "" },
    touchMoveStopPropagation: { type: Boolean, default: false },
    touchMovePreventDefault: { type: Boolean, default: false },
    disabled: { type: Boolean, default: false }
  },
  emits: ["open", "close", "click"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const getRefWidth = (ref2) => {
      var _a;
      return ((_a = ref2.value) == null ? void 0 : _a.getBoundingClientRect().width) || 0;
    };
    const lockClick = ref(false);
    const leftRef = ref(), leftRefWidth = computed(() => {
      return getRefWidth(leftRef);
    });
    const rightRef = ref(), rightRefWidth = computed(() => {
      return getRefWidth(rightRef);
    });
    const parent = inject(SWIPE_KEY, null);
    watch(
      () => {
        var _a;
        return (_a = parent == null ? void 0 : parent.name) == null ? void 0 : _a.value;
      },
      (name) => {
        if (props.name !== name && parent && parent.lock) {
          close();
        }
      }
    );
    const opened = ref(false);
    let position = "";
    let oldPosition = "";
    const state = reactive({
      offset: 0,
      moving: false
    });
    const open = (p2 = "") => {
      parent && parent.update(props.name);
      opened.value = true;
      if (p2) {
        state.offset = p2 === "left" ? -rightRefWidth.value : leftRefWidth.value;
      }
      emit2("open", {
        name: props.name,
        position: position || p2
      });
    };
    const close = () => {
      state.offset = 0;
      if (opened.value) {
        opened.value = false;
        emit2("close", {
          name: props.name,
          position
        });
      }
    };
    const onClick = (e, position2, lock) => {
      if (lock) {
        e.stopPropagation();
      } else {
        close();
      }
      emit2("click", position2);
    };
    const touchStyle = computed(() => {
      return {
        transform: `translate3d(${state.offset}px, 0, 0)`
      };
    });
    const setoffset = (deltaX) => {
      position = deltaX > 0 ? "right" : "left";
      let offset = deltaX;
      switch (position) {
        case "left":
          if (opened.value && oldPosition === position) {
            offset = -rightRefWidth.value;
          } else {
            offset = Math.abs(deltaX) > rightRefWidth.value ? -rightRefWidth.value : deltaX;
          }
          break;
        case "right":
          if (opened.value && oldPosition === position) {
            offset = leftRefWidth.value;
          } else {
            offset = Math.abs(deltaX) > leftRefWidth.value ? leftRefWidth.value : deltaX;
          }
          break;
      }
      state.offset = offset;
    };
    const touch = useTouch();
    const onTouchStart = (event) => {
      if (props.disabled) return;
      touch.start(event);
    };
    const onTouchMove = (event) => {
      if (props.disabled) return;
      touch.move(event);
      if (touch.isHorizontal()) {
        lockClick.value = true;
        state.moving = true;
        setoffset(touch.deltaX.value);
        if (props.touchMovePreventDefault) {
          event.preventDefault();
        }
        if (props.touchMoveStopPropagation) {
          event.stopPropagation();
        }
      }
    };
    const onTouchEnd = () => {
      if (state.moving) {
        state.moving = false;
        oldPosition = position;
        switch (position) {
          case "left":
            if (Math.abs(state.offset) <= rightRefWidth.value / 2) {
              close();
            } else {
              state.offset = -rightRefWidth.value;
              open();
            }
            break;
          case "right":
            if (Math.abs(state.offset) <= leftRefWidth.value / 2) {
              close();
            } else {
              state.offset = leftRefWidth.value;
              open();
            }
            break;
        }
        setTimeout(() => {
          lockClick.value = false;
        }, 0);
      }
    };
    __expose({
      open,
      close
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("view", {
        class: "nut-swipe",
        style: normalizeStyle(touchStyle.value),
        onTouchstart: onTouchStart,
        onTouchmove: onTouchMove,
        onTouchend: onTouchEnd,
        onTouchcancel: onTouchEnd
      }, [
        createBaseVNode("view", {
          ref_key: "leftRef",
          ref: leftRef,
          class: "nut-swipe__left",
          onClick: _cache[0] || (_cache[0] = ($event) => onClick($event, "left", true))
        }, [
          renderSlot(_ctx.$slots, "left")
        ], 512),
        createBaseVNode("view", {
          class: "nut-swipe__content",
          onClick: _cache[1] || (_cache[1] = ($event) => onClick($event, "content", lockClick.value))
        }, [
          renderSlot(_ctx.$slots, "default")
        ]),
        createBaseVNode("view", {
          ref_key: "rightRef",
          ref: rightRef,
          class: "nut-swipe__right",
          onClick: _cache[2] || (_cache[2] = ($event) => onClick($event, "right", true))
        }, [
          renderSlot(_ctx.$slots, "right")
        ], 512)
      ], 36);
    };
  }
}));
withInstall(_sfc_main$T);
var __defProp$z = Object.defineProperty;
var __defProps$z = Object.defineProperties;
var __getOwnPropDescs$z = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$z = Object.getOwnPropertySymbols;
var __hasOwnProp$z = Object.prototype.hasOwnProperty;
var __propIsEnum$z = Object.prototype.propertyIsEnumerable;
var __defNormalProp$z = (obj, key, value) => key in obj ? __defProp$z(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$z = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$z.call(b, prop))
      __defNormalProp$z(a2, prop, b[prop]);
  if (__getOwnPropSymbols$z)
    for (var prop of __getOwnPropSymbols$z(b)) {
      if (__propIsEnum$z.call(b, prop))
        __defNormalProp$z(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$z = (a2, b) => __defProps$z(a2, __getOwnPropDescs$z(b));
const _sfc_main$S = /* @__PURE__ */ defineComponent(__spreadProps$z(__spreadValues$z({}, {
  name: "NutSwipeGroup"
}), {
  __name: "swipe-group",
  props: {
    lock: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    const swipeGroupRef = ref(null);
    const name = ref("");
    const update = (n) => {
      name.value = n;
    };
    provide(SWIPE_KEY, {
      update,
      lock: props.lock,
      name
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "swipeGroupRef",
        ref: swipeGroupRef,
        class: "nut-swipe-group"
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 512);
    };
  }
}));
withInstall(_sfc_main$S);
var __defProp$y = Object.defineProperty;
var __defProps$y = Object.defineProperties;
var __getOwnPropDescs$y = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$y = Object.getOwnPropertySymbols;
var __hasOwnProp$y = Object.prototype.hasOwnProperty;
var __propIsEnum$y = Object.prototype.propertyIsEnumerable;
var __defNormalProp$y = (obj, key, value) => key in obj ? __defProp$y(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$y = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$y.call(b, prop))
      __defNormalProp$y(a2, prop, b[prop]);
  if (__getOwnPropSymbols$y)
    for (var prop of __getOwnPropSymbols$y(b)) {
      if (__propIsEnum$y.call(b, prop))
        __defNormalProp$y(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$y = (a2, b) => __defProps$y(a2, __getOwnPropDescs$y(b));
const { create: create$C } = createComponent("action-sheet");
const _sfc_main$R = create$C({
  components: {
    NutPopup,
    Loading: u
  },
  props: __spreadProps$y(__spreadValues$y({}, popupProps), {
    cancelTxt: {
      type: String,
      default: ""
    },
    optionTag: {
      type: String,
      default: "name"
    },
    optionSubTag: {
      type: String,
      default: "subname"
    },
    chooseTagValue: {
      type: String,
      default: ""
    },
    title: {
      type: String,
      default: ""
    },
    color: {
      type: String,
      default: "#ee0a24"
    },
    description: {
      type: String,
      default: ""
    },
    menuItems: {
      type: Array,
      default: () => []
    },
    closeAbled: {
      type: Boolean,
      default: true
    }
  }),
  emits: ["cancel", "close", "choose", "update:visible"],
  setup(props, { emit: emit2 }) {
    const slotDefault = !!useSlots().default;
    const isHighlight = (item) => {
      return props.chooseTagValue && props.chooseTagValue === item[props.optionTag] ? props.color : "";
    };
    const cancelActionSheet = () => {
      emit2("cancel");
      emit2("update:visible", false);
    };
    const chooseItem = (item, index2) => {
      if (!item.disable && !item.loading) {
        emit2("choose", item, index2);
        emit2("update:visible", false);
      }
    };
    const close = (e) => {
      if (props.closeAbled) {
        emit2("close", e);
        emit2("update:visible", false);
      }
    };
    return {
      slotDefault,
      isHighlight,
      cancelActionSheet,
      chooseItem,
      close
    };
  }
});
const _hoisted_1$F = { class: "nut-action-sheet" };
const _hoisted_2$y = {
  key: 0,
  class: "nut-action-sheet__title"
};
const _hoisted_3$s = { key: 1 };
const _hoisted_4$o = {
  key: 0,
  class: "nut-action-sheet__item nut-action-sheet__desc"
};
const _hoisted_5$h = {
  key: 1,
  class: "nut-action-sheet__menu"
};
const _hoisted_6$g = ["onClick"];
const _hoisted_7$c = { key: 1 };
const _hoisted_8$9 = { class: "nut-action-sheet__subdesc" };
function _sfc_render$C(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Loading = resolveComponent("Loading");
  const _component_nut_popup = resolveComponent("nut-popup");
  return openBlock(), createBlock(_component_nut_popup, {
    visible: _ctx.visible,
    position: "bottom",
    round: "",
    "close-on-click-overlay": _ctx.closeAbled,
    "lock-scroll": _ctx.lockScroll,
    "z-index": _ctx.zIndex,
    onClickOverlay: _ctx.close
  }, {
    default: withCtx(() => [
      createBaseVNode("view", _hoisted_1$F, [
        _ctx.title ? (openBlock(), createElementBlock("view", _hoisted_2$y, toDisplayString(_ctx.title), 1)) : createCommentVNode("", true),
        renderSlot(_ctx.$slots, "default"),
        !_ctx.slotDefault ? (openBlock(), createElementBlock("view", _hoisted_3$s, [
          _ctx.description ? (openBlock(), createElementBlock("view", _hoisted_4$o, toDisplayString(_ctx.description), 1)) : createCommentVNode("", true),
          _ctx.menuItems.length ? (openBlock(), createElementBlock("view", _hoisted_5$h, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.menuItems, (item, index2) => {
              return openBlock(), createElementBlock("view", {
                key: index2,
                class: normalizeClass(["nut-action-sheet__item", {
                  "nut-action-sheet__item--disabled": item.disable,
                  "nut-action-sheet__item--loading": item.loading
                }]),
                style: normalizeStyle({ color: _ctx.isHighlight(item) || item.color }),
                onClick: ($event) => _ctx.chooseItem(item, index2)
              }, [
                item.loading ? (openBlock(), createBlock(_component_Loading, { key: 0 })) : (openBlock(), createElementBlock("view", _hoisted_7$c, toDisplayString(item[_ctx.optionTag]), 1)),
                createBaseVNode("view", _hoisted_8$9, toDisplayString(item[_ctx.optionSubTag]), 1)
              ], 14, _hoisted_6$g);
            }), 128))
          ])) : createCommentVNode("", true),
          _ctx.cancelTxt ? (openBlock(), createElementBlock("view", {
            key: 2,
            class: "nut-action-sheet__cancel",
            onClick: _cache[0] || (_cache[0] = (...args) => _ctx.cancelActionSheet && _ctx.cancelActionSheet(...args))
          }, toDisplayString(_ctx.cancelTxt), 1)) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ])
    ]),
    _: 3
  }, 8, ["visible", "close-on-click-overlay", "lock-scroll", "z-index", "onClickOverlay"]);
}
const index$q = /* @__PURE__ */ _export_sfc(_sfc_main$R, [["render", _sfc_render$C]]);
var __defProp$x = Object.defineProperty;
var __defProps$x = Object.defineProperties;
var __getOwnPropDescs$x = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$x = Object.getOwnPropertySymbols;
var __hasOwnProp$x = Object.prototype.hasOwnProperty;
var __propIsEnum$x = Object.prototype.propertyIsEnumerable;
var __defNormalProp$x = (obj, key, value) => key in obj ? __defProp$x(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$x = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$x.call(b, prop))
      __defNormalProp$x(a2, prop, b[prop]);
  if (__getOwnPropSymbols$x)
    for (var prop of __getOwnPropSymbols$x(b)) {
      if (__propIsEnum$x.call(b, prop))
        __defNormalProp$x(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$x = (a2, b) => __defProps$x(a2, __getOwnPropDescs$x(b));
const _sfc_main$Q = /* @__PURE__ */ defineComponent(__spreadProps$x(__spreadValues$x({}, {
  name: "NutBacktop"
}), {
  __name: "backtop",
  props: {
    bottom: { default: 20 },
    right: { default: 10 },
    elId: { default: "body" },
    distance: { default: 200 },
    zIndex: { default: 10 },
    isAnimation: { type: Boolean, default: true },
    duration: { default: 1e3 }
  },
  emits: ["click"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const backTop = ref(false);
    const scrollTop = ref(0);
    const scrollEl = ref(window);
    const startTime = ref(0);
    const keepAlive = ref(false);
    const classes = computed(() => {
      const prefixCls2 = "nut-backtop";
      return {
        [prefixCls2]: true,
        show: backTop.value
      };
    });
    const style = computed(() => {
      return {
        right: `${props.right}px`,
        bottom: `${props.bottom}px`,
        zIndex: props.zIndex
      };
    });
    function scrollListener() {
      if (scrollEl.value instanceof Window) {
        scrollTop.value = scrollEl.value.scrollY;
      } else {
        scrollTop.value = scrollEl.value.scrollTop;
      }
      backTop.value = scrollTop.value >= props.distance;
    }
    function scroll(y2 = 0) {
      if (scrollEl.value instanceof Window) {
        window.scrollTo(0, y2);
      } else {
        scrollEl.value.scrollTop = y2;
      }
    }
    function scrollAnimation() {
      let cid = requestAniFrame$1(function fn() {
        var t = props.duration - Math.max(0, startTime.value - +/* @__PURE__ */ new Date() + props.duration);
        var y2 = t * -scrollTop.value / props.duration + scrollTop.value;
        scroll(y2);
        cid = requestAniFrame$1(fn);
        if (t == props.duration || y2 == 0) {
          cancelRaf(cid);
        }
      });
    }
    function addEventListener2() {
      scrollEl.value.addEventListener("scroll", scrollListener, false);
      scrollEl.value.addEventListener("resize", scrollListener, false);
    }
    function removeEventListener2() {
      scrollEl.value.removeEventListener("scroll", scrollListener, false);
      scrollEl.value.removeEventListener("resize", scrollListener, false);
    }
    function handleClick(e) {
      startTime.value = +/* @__PURE__ */ new Date();
      props.isAnimation && props.duration > 0 ? scrollAnimation() : scroll();
      emit2("click", e);
    }
    function init() {
      if (props.elId && document.getElementById(props.elId)) {
        scrollEl.value = document.getElementById(props.elId);
      }
      addEventListener2();
    }
    onMounted(() => {
      if (props.distance == 0) {
        backTop.value = true;
      }
      init();
    });
    onUnmounted(() => {
      removeEventListener2();
    });
    onActivated(() => {
      if (keepAlive.value) {
        keepAlive.value = false;
        init();
      }
    });
    onDeactivated(() => {
      keepAlive.value = true;
      removeEventListener2();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(classes.value),
        style: normalizeStyle(style.value),
        onClick: withModifiers(handleClick, ["stop"])
      }, [
        renderSlot(_ctx.$slots, "default", {}, () => [
          createVNode(unref(w), {
            width: "19px",
            height: "19px",
            class: "nut-backtop-main"
          })
        ])
      ], 6);
    };
  }
}));
withInstall(_sfc_main$Q);
const { create: create$B } = createComponent("drag");
const _sfc_main$P = create$B({
  props: {
    attract: {
      type: Boolean,
      default: false
    },
    direction: {
      type: String,
      default: "all"
    },
    boundary: {
      type: Object,
      default: () => {
        return {
          top: 0,
          left: 0,
          right: 0,
          bottom: 0
        };
      }
    }
  },
  setup(props) {
    const myDrag = ref();
    const state = reactive({
      keepAlive: false,
      elWidth: 0,
      elHeight: 0,
      screenWidth: 0,
      screenHeight: 0,
      startTop: 0,
      startLeft: 0,
      nx: 0,
      ny: 0,
      xPum: 0,
      yPum: 0,
      position: { x: 0, y: 0 },
      boundary: {
        top: 0,
        left: 0,
        right: 0,
        bottom: 0
      }
    });
    function getInfo() {
      const domElem = document.documentElement;
      state.elWidth = myDrag.value.offsetWidth;
      state.elHeight = myDrag.value.offsetHeight;
      state.screenWidth = domElem.clientWidth || 375;
      state.screenHeight = domElem.clientHeight || 667;
    }
    function goLeft(target) {
      if (state.boundary.left) {
        if (+target.style.left.split("px")[0] > state.boundary.left) {
          target.style.left = +target.style.left.split("px")[0] - 10 + "px";
          requestAniFrame$1(() => {
            goLeft(target);
          });
        } else {
          target.style.left = `${state.boundary.left}px`;
        }
      } else {
        if (+target.style.left.split("px")[0] > 10) {
          target.style.left = +target.style.left.split("px")[0] - 10 + "px";
          requestAniFrame$1(() => {
            goLeft(target);
          });
        } else {
          target.style.left = "0px";
        }
      }
    }
    function goRight(target, rightLocation) {
      if (rightLocation - parseInt(target.style.left.split("px")[0]) > 10) {
        target.style.left = parseInt(target.style.left.split("px")[0]) + 10 + "px";
        requestAniFrame$1(() => {
          goRight(target, rightLocation);
        });
      } else {
        target.style.left = rightLocation + "px";
      }
    }
    function touchMove(e) {
      e.preventDefault();
      const target = e.currentTarget;
      if (e.targetTouches.length === 1) {
        const touch = e.targetTouches[0];
        state.nx = touch.clientX - state.position.x;
        state.ny = touch.clientY - state.position.y;
        state.xPum = state.startLeft + state.nx;
        state.yPum = state.startTop + state.ny;
        const rightLocation = state.screenWidth - state.elWidth - state.boundary.right;
        if (Math.abs(state.xPum) > rightLocation) {
          state.xPum = rightLocation;
        } else if (state.xPum <= state.boundary.left) {
          state.xPum = state.boundary.left;
        }
        if (state.yPum < state.boundary.top) {
          state.yPum = state.boundary.top;
        } else if (state.yPum > state.screenHeight - state.elHeight - state.boundary.bottom) {
          state.yPum = state.screenHeight - state.elHeight - state.boundary.bottom;
        }
        if (props.direction != "y") {
          target.style.left = state.xPum + "px";
        }
        if (props.direction != "x") {
          target.style.top = state.yPum + "px";
        }
      }
    }
    function touchEnd(e) {
      const target = e.currentTarget;
      const touch = e.changedTouches[0];
      let currX = touch.clientX;
      const rightLocation = state.screenWidth - state.elWidth - state.boundary.right;
      if (currX > rightLocation) {
        currX = rightLocation;
      } else if (currX < state.boundary.left) {
        currX = state.boundary.left;
      } else {
        currX = currX < state.screenWidth / 2 ? state.boundary.left : rightLocation;
      }
      if (props.direction != "y" && props.attract) {
        if (currX < state.screenWidth / 2) {
          requestAniFrame$1(() => {
            goLeft(target);
          });
        } else {
          requestAniFrame$1(() => {
            goRight(target, rightLocation);
          });
        }
      }
      if (props.direction != "x") {
        target.style.top = state.yPum + "px";
      }
    }
    function touchStart(e) {
      const target = e.currentTarget;
      const touches = e.touches[0];
      const touch = e.targetTouches[0];
      state.startTop = target.offsetTop;
      state.startLeft = target.offsetLeft;
      state.position.x = touches.clientX;
      state.position.y = touches.clientY;
      state.nx = touch.clientX - state.position.x;
      state.ny = touch.clientY - state.position.y;
      state.xPum = state.startLeft + state.nx;
      state.yPum = state.startTop + state.ny;
    }
    onMounted(() => {
      getInfo();
      state.boundary = props.boundary;
    });
    onActivated(() => {
      if (state.keepAlive) {
        state.keepAlive = false;
      }
    });
    onDeactivated(() => {
      state.keepAlive = true;
      myDrag.value.removeEventListener("touchstart", touchStart);
      myDrag.value.removeEventListener("touchmove", touchMove);
      myDrag.value.removeEventListener("touchend", touchEnd);
    });
    return {
      myDrag,
      touchStart,
      touchMove,
      touchEnd
    };
  }
});
function _sfc_render$B(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    ref: "myDrag",
    class: "nut-drag",
    onTouchstart: _cache[0] || (_cache[0] = ($event) => _ctx.touchStart($event)),
    onTouchmove: _cache[1] || (_cache[1] = ($event) => _ctx.touchMove($event)),
    onTouchend: _cache[2] || (_cache[2] = ($event) => _ctx.touchEnd($event))
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 544);
}
const index$p = /* @__PURE__ */ _export_sfc(_sfc_main$P, [["render", _sfc_render$B]]);
var __defProp$w = Object.defineProperty;
var __defProps$w = Object.defineProperties;
var __getOwnPropDescs$w = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$w = Object.getOwnPropertySymbols;
var __hasOwnProp$w = Object.prototype.hasOwnProperty;
var __propIsEnum$w = Object.prototype.propertyIsEnumerable;
var __defNormalProp$w = (obj, key, value) => key in obj ? __defProp$w(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$w = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$w.call(b, prop))
      __defNormalProp$w(a2, prop, b[prop]);
  if (__getOwnPropSymbols$w)
    for (var prop of __getOwnPropSymbols$w(b)) {
      if (__propIsEnum$w.call(b, prop))
        __defNormalProp$w(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$w = (a2, b) => __defProps$w(a2, __getOwnPropDescs$w(b));
const { create: create$A } = createComponent("dialog");
const cN$e = "NutDialog";
const _sfc_main$O = create$A({
  inheritAttrs: false,
  components: {
    NutPopup,
    NutButton: _sfc_main$1G
  },
  props: __spreadProps$w(__spreadValues$w({}, popupProps), {
    closeOnClickOverlay: {
      type: Boolean,
      default: true
    },
    title: {
      type: String,
      default: ""
    },
    content: {
      type: [String, Object],
      default: ""
    },
    noFooter: {
      type: Boolean,
      default: false
    },
    noOkBtn: {
      type: Boolean,
      default: false
    },
    noCancelBtn: {
      type: Boolean,
      default: false
    },
    cancelText: {
      type: String,
      default: ""
    },
    okText: {
      type: String,
      default: ""
    },
    cancelAutoClose: {
      type: Boolean,
      default: true
    },
    okAutoClose: {
      type: Boolean,
      default: true
    },
    textAlign: {
      type: String,
      default: "center"
    },
    closeOnPopstate: {
      type: Boolean,
      default: false
    },
    footerDirection: {
      type: String,
      default: "horizontal"
      // vertical
    },
    customClass: {
      type: String,
      default: ""
    },
    popStyle: {
      type: Object
    },
    beforeClose: Function
  }),
  emits: ["update", "update:visible", "ok", "cancel", "opened", "closed"],
  setup(props, { emit: emit2 }) {
    const translate = useLocale(cN$e);
    const showPopup = ref(props.visible);
    onMounted(() => {
      if (props.closeOnPopstate) {
        window.addEventListener("popstate", function() {
          closed("page");
        });
      }
    });
    watch(
      () => props.visible,
      (value) => {
        showPopup.value = value;
        if (value) {
          emit2("opened");
        }
      }
    );
    const update = (val) => {
      emit2("update", val);
      emit2("update:visible", val);
    };
    const closed = (action) => {
      funInterceptor(props.beforeClose, {
        args: [action],
        done: () => {
          showPopup.value = false;
          update(false);
          emit2("closed");
        }
      });
    };
    const onCancel = () => {
      emit2("cancel");
      if (props.cancelAutoClose) {
        showPopup.value = false;
        closed("cancel");
      }
    };
    const onOk = () => {
      emit2("ok");
      if (props.okAutoClose) {
        closed("ok");
      }
    };
    const onClickOverlay = () => {
      if (props.closeOnClickOverlay) {
        closed("");
      }
    };
    const contentStyle = computed(() => {
      return {
        textAlign: props.textAlign
      };
    });
    return {
      closed,
      onCancel,
      onOk,
      showPopup,
      onClickOverlay,
      contentStyle,
      translate
    };
  }
});
const _hoisted_1$E = {
  key: 0,
  class: "nut-dialog__header"
};
const _hoisted_2$x = ["innerHTML"];
function _sfc_render$A(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_button = resolveComponent("nut-button");
  const _component_nut_popup = resolveComponent("nut-popup");
  return openBlock(), createBlock(_component_nut_popup, {
    visible: _ctx.showPopup,
    "onUpdate:visible": _cache[0] || (_cache[0] = ($event) => _ctx.showPopup = $event),
    teleport: _ctx.teleport,
    "close-on-click-overlay": false,
    "lock-scroll": _ctx.lockScroll,
    "pop-class": _ctx.popClass,
    "overlay-class": _ctx.overlayClass,
    "overlay-style": _ctx.overlayStyle,
    style: normalizeStyle(_ctx.popStyle),
    round: "",
    "z-index": _ctx.zIndex,
    onClickOverlay: _ctx.onClickOverlay,
    onClickCloseIcon: _ctx.closed
  }, {
    default: withCtx(() => [
      createBaseVNode("view", {
        class: normalizeClass(["nut-dialog", _ctx.customClass])
      }, [
        _ctx.$slots.header || _ctx.title ? (openBlock(), createElementBlock("view", _hoisted_1$E, [
          _ctx.$slots.header ? renderSlot(_ctx.$slots, "header", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createTextVNode(toDisplayString(_ctx.title), 1)
          ], 64))
        ])) : createCommentVNode("", true),
        createBaseVNode("view", {
          class: "nut-dialog__content",
          style: normalizeStyle(_ctx.contentStyle)
        }, [
          _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 0 }) : typeof _ctx.content === "string" ? (openBlock(), createElementBlock("view", {
            key: 1,
            innerHTML: _ctx.content
          }, null, 8, _hoisted_2$x)) : (openBlock(), createBlock(resolveDynamicComponent(_ctx.content), { key: 2 }))
        ], 4),
        !_ctx.noFooter ? (openBlock(), createElementBlock("view", {
          key: 1,
          class: normalizeClass(["nut-dialog__footer", { [_ctx.footerDirection]: _ctx.footerDirection }])
        }, [
          _ctx.$slots.footer ? renderSlot(_ctx.$slots, "footer", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            !_ctx.noCancelBtn ? (openBlock(), createBlock(_component_nut_button, {
              key: 0,
              size: "small",
              plain: "",
              type: "primary",
              class: "nut-dialog__footer-cancel",
              onClick: _ctx.onCancel
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.cancelText || _ctx.translate("cancel")), 1)
              ]),
              _: 1
            }, 8, ["onClick"])) : createCommentVNode("", true),
            !_ctx.noOkBtn ? (openBlock(), createBlock(_component_nut_button, {
              key: 1,
              size: "small",
              type: "primary",
              class: "nut-dialog__footer-ok",
              onClick: _ctx.onOk
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.okText || _ctx.translate("confirm")), 1)
              ]),
              _: 1
            }, 8, ["onClick"])) : createCommentVNode("", true)
          ], 64))
        ], 2)) : createCommentVNode("", true)
      ], 2)
    ]),
    _: 3
  }, 8, ["visible", "teleport", "lock-scroll", "pop-class", "overlay-class", "overlay-style", "style", "z-index", "onClickOverlay", "onClickCloseIcon"]);
}
const Dialog = /* @__PURE__ */ _export_sfc(_sfc_main$O, [["render", _sfc_render$A]]);
var __defProp$v = Object.defineProperty;
var __defProps$v = Object.defineProperties;
var __getOwnPropDescs$v = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$v = Object.getOwnPropertySymbols;
var __hasOwnProp$v = Object.prototype.hasOwnProperty;
var __propIsEnum$v = Object.prototype.propertyIsEnumerable;
var __defNormalProp$v = (obj, key, value) => key in obj ? __defProp$v(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$v = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$v.call(b, prop))
      __defNormalProp$v(a2, prop, b[prop]);
  if (__getOwnPropSymbols$v)
    for (var prop of __getOwnPropSymbols$v(b)) {
      if (__propIsEnum$v.call(b, prop))
        __defNormalProp$v(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$v = (a2, b) => __defProps$v(a2, __getOwnPropDescs$v(b));
const { create: create$z } = createComponent("infinite-loading");
const cN$d = "NutInfiniteLoading";
const _sfc_main$N = create$z({
  props: {
    modelValue: {
      type: Boolean,
      default: false
    },
    hasMore: {
      type: Boolean,
      default: true
    },
    threshold: {
      type: Number,
      default: 200
    },
    loadTxt: {
      type: String,
      default: ""
    },
    loadMoreTxt: {
      type: String,
      default: ""
    },
    useCapture: {
      type: Boolean,
      default: false
    }
  },
  emits: ["scrollChange", "loadMore", "update:modelValue"],
  components: {
    Loading: u
  },
  setup(props, { emit: emit2, slots }) {
    const translate = useLocale(cN$d);
    const scroller = ref();
    const scrollParent = useScrollParent(scroller);
    const state = reactive({
      beforeScrollTop: 0,
      isInfiniting: false,
      y: 0,
      x: 0,
      distance: 0
    });
    const calculateTopPosition = (el) => {
      return !el ? 0 : el.offsetTop + calculateTopPosition(el.offsetParent);
    };
    const isScrollAtBottom = () => {
      let offsetDistance = 0;
      let resScrollTop = 0;
      let direction = "down";
      if (scrollParent.value == window) {
        const windowScrollTop = getScrollTopRoot();
        if (scroller.value) {
          offsetDistance = calculateTopPosition(scroller.value) + scroller.value.offsetHeight - windowScrollTop - window.innerHeight;
        }
        resScrollTop = windowScrollTop;
      } else {
        const { scrollHeight, clientHeight, scrollTop } = scrollParent.value;
        offsetDistance = scrollHeight - clientHeight - scrollTop;
        resScrollTop = scrollTop;
      }
      if (state.beforeScrollTop > resScrollTop) {
        direction = "up";
      } else {
        direction = "down";
      }
      state.beforeScrollTop = resScrollTop;
      emit2("scrollChange", resScrollTop);
      return offsetDistance <= props.threshold && direction == "down";
    };
    const handleScroll = () => {
      requestAniFrame$1(() => {
        if (!isScrollAtBottom() || !props.hasMore || state.isInfiniting) {
          return false;
        } else {
          state.isInfiniting = true;
          emit2("update:modelValue", true);
          nextTick(() => emit2("loadMore"));
        }
      });
    };
    const scrollListener = () => {
      scrollParent.value && scrollParent.value.addEventListener("scroll", handleScroll, props.useCapture);
    };
    const removeScrollListener = () => {
      scrollParent.value && scrollParent.value.removeEventListener("scroll", handleScroll, props.useCapture);
    };
    onMounted(() => {
      scrollListener();
    });
    onUnmounted(() => {
      removeScrollListener();
    });
    const isKeepAlive2 = ref(false);
    onActivated(() => {
      if (isKeepAlive2.value) {
        isKeepAlive2.value = false;
        scrollListener();
      }
    });
    onDeactivated(() => {
      isKeepAlive2.value = true;
      removeScrollListener();
    });
    watch(
      () => props.modelValue,
      (val) => {
        if (!val) {
          state.isInfiniting = false;
        }
      }
    );
    return __spreadProps$v(__spreadValues$v({
      scroller
    }, toRefs(state)), {
      translate,
      slots
    });
  }
});
const _hoisted_1$D = {
  ref: "scroller",
  class: "nut-infinite-loading"
};
const _hoisted_2$w = { class: "nut-infinite__container" };
const _hoisted_3$r = { class: "nut-infinite__bottom" };
const _hoisted_4$n = {
  key: 0,
  class: "nut-infinite__bottom-box"
};
const _hoisted_5$g = { class: "nut-infinite__bottom-box__text" };
const _hoisted_6$f = { class: "nut-infinite__bottom-tips" };
function _sfc_render$z(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Loading = resolveComponent("Loading");
  return openBlock(), createElementBlock("view", _hoisted_1$D, [
    createBaseVNode("view", _hoisted_2$w, [
      renderSlot(_ctx.$slots, "default")
    ]),
    createBaseVNode("view", _hoisted_3$r, [
      _ctx.isInfiniting ? (openBlock(), createElementBlock("view", _hoisted_4$n, [
        renderSlot(_ctx.$slots, "loading", {}, () => [
          renderSlot(_ctx.$slots, "loading-icon", {}, () => [
            createVNode(_component_Loading, { class: "nut-icon-loading nut-infinite__bottom-box__img" })
          ]),
          createBaseVNode("view", _hoisted_5$g, toDisplayString(_ctx.loadTxt || _ctx.translate("loading")), 1)
        ])
      ])) : !_ctx.hasMore ? renderSlot(_ctx.$slots, "finished", { key: 1 }, () => [
        createBaseVNode("view", _hoisted_6$f, toDisplayString(_ctx.loadMoreTxt || _ctx.translate("loadMoreTxt")), 1)
      ]) : createCommentVNode("", true)
    ])
  ], 512);
}
const index$o = /* @__PURE__ */ _export_sfc(_sfc_main$N, [["render", _sfc_render$z]]);
var __defProp$u = Object.defineProperty;
var __defProps$u = Object.defineProperties;
var __getOwnPropDescs$u = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$u = Object.getOwnPropertySymbols;
var __hasOwnProp$u = Object.prototype.hasOwnProperty;
var __propIsEnum$u = Object.prototype.propertyIsEnumerable;
var __defNormalProp$u = (obj, key, value) => key in obj ? __defProp$u(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$u = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$u.call(b, prop))
      __defNormalProp$u(a2, prop, b[prop]);
  if (__getOwnPropSymbols$u)
    for (var prop of __getOwnPropSymbols$u(b)) {
      if (__propIsEnum$u.call(b, prop))
        __defNormalProp$u(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$u = (a2, b) => __defProps$u(a2, __getOwnPropDescs$u(b));
const { create: create$y } = createComponent("pull-refresh");
const cN$c = "NutPullRefresh";
const _sfc_main$M = create$y({
  props: {
    modelValue: {
      type: Boolean,
      default: false
    },
    pullingTxt: {
      type: String,
      default: ""
    },
    loosingTxt: {
      type: String,
      default: ""
    },
    loadingTxt: {
      type: String,
      default: ""
    },
    completeTxt: {
      type: String,
      default: ""
    },
    headHeight: {
      type: [String, Number],
      default: 50
    },
    pullDistance: {
      type: [String, Number],
      default: 50
    },
    duration: {
      type: [String, Number],
      default: 0.3
    },
    completeDuration: {
      type: Number,
      default: 0
    }
  },
  emits: ["change", "refresh", "update:modelValue"],
  components: { Loading: u },
  setup(props, { emit: emit2, slots }) {
    const translate = useLocale(cN$c);
    const touch = useTouch();
    const scroller = ref();
    const scrollParent = useScrollParent(scroller);
    const state = reactive({
      isPullRefresh: false,
      distance: 0,
      status: "normal"
    });
    const getPullStatus = computed(() => {
      switch (state.status) {
        case "pulling":
          return !slots.pulling ? props.pullingTxt || translate("pulling") : "";
        case "loosing":
          return !slots.loosing ? props.loosingTxt || translate("loosing") : "";
        case "loading":
          return !slots.loading ? props.loadingTxt || translate("loading") : "";
        case "complete":
          return !slots.complete ? props.completeTxt || translate("complete") : "";
      }
      return "";
    });
    const getStyle = computed(() => {
      return {
        transitionDuration: `${props.duration}s`,
        transform: state.distance ? `translate3d(0,${state.distance}px, 0)` : ""
      };
    });
    const getHeightStyle = computed(() => {
      const styles = {};
      if (props.headHeight != 50) styles.height = pxCheck(props.headHeight);
      return styles;
    });
    const timing = (distance) => {
      const pullDistance = +(props.pullDistance || props.headHeight);
      let moveDistance = distance;
      if (distance > pullDistance) {
        if (distance < pullDistance * 2) {
          moveDistance = (distance + pullDistance) / 2;
        } else {
          moveDistance = pullDistance + distance / 4;
        }
      }
      return Math.round(moveDistance);
    };
    const setPullStatus = (distance, isLoading, isComplete) => {
      const pullDistance = +(props.pullDistance || props.headHeight);
      state.distance = distance;
      if (isLoading) {
        state.status = "loading";
      } else if (isComplete) {
        state.status = "complete";
      } else if (distance === 0) {
        state.status = "normal";
      } else if (distance < pullDistance) {
        state.status = "pulling";
      } else {
        state.status = "loosing";
      }
      emit2("change", { status: state.status, distance });
    };
    const isCanTouch = () => state.status !== "loading" && state.status !== "complete";
    const isScrollTop = () => {
      if (scrollParent.value == window) {
        return getScrollTopRoot() == 0;
      } else {
        return scrollParent.value && scrollParent.value.scrollTop == 0;
      }
    };
    const touchStart = (event) => {
      if (isCanTouch()) {
        if (isScrollTop()) {
          touch.start(event);
          state.isPullRefresh = true;
        } else {
          state.distance = 0;
          state.isPullRefresh = false;
        }
      }
    };
    const touchMove = (event) => {
      if (isCanTouch()) {
        touch.move(event);
        const { deltaY } = touch;
        if (touch.isVertical() && deltaY.value > 0 && state.isPullRefresh) {
          event.preventDefault();
          setPullStatus(timing(deltaY.value));
        }
      }
    };
    const touchEnd = () => {
      if (state.isPullRefresh && isCanTouch() && touch.deltaY.value) {
        if (state.status === "loosing") {
          setPullStatus(+props.headHeight, true);
          emit2("update:modelValue", true);
          nextTick(() => emit2("refresh"));
        } else {
          setPullStatus(0);
        }
      }
      setTimeout(() => {
        touch.reset();
      }, 0);
    };
    watch(
      () => props.modelValue,
      (val) => {
        if (val) {
          setPullStatus(+props.headHeight, true);
        } else {
          if (props.completeDuration === 0) setPullStatus(0);
          setPullStatus(+props.headHeight, false, true);
          setTimeout(() => {
            setPullStatus(0);
          }, props.completeDuration);
        }
      }
    );
    return __spreadProps$u(__spreadValues$u({
      scroller
    }, toRefs(state)), {
      touchStart,
      touchMove,
      touchEnd,
      getStyle,
      translate,
      slots,
      getHeightStyle,
      getPullStatus
    });
  }
});
const _hoisted_1$C = { class: "nut-pull-refresh-container-topbox-text" };
function _sfc_render$y(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Loading = resolveComponent("Loading");
  return openBlock(), createElementBlock("div", {
    ref: "scroller",
    class: "nut-pull-refresh",
    onTouchstart: _cache[0] || (_cache[0] = (...args) => _ctx.touchStart && _ctx.touchStart(...args)),
    onTouchmove: _cache[1] || (_cache[1] = (...args) => _ctx.touchMove && _ctx.touchMove(...args)),
    onTouchend: _cache[2] || (_cache[2] = (...args) => _ctx.touchEnd && _ctx.touchEnd(...args))
  }, [
    createBaseVNode("div", {
      class: "nut-pull-refresh-container",
      style: normalizeStyle(_ctx.getStyle)
    }, [
      createBaseVNode("div", {
        class: "nut-pull-refresh-container-topbox",
        style: normalizeStyle(_ctx.getHeightStyle)
      }, [
        _ctx.status == "loading" && !_ctx.slots.loading ? (openBlock(), createBlock(_component_Loading, {
          key: 0,
          class: "nut-icon-loading nut-pull-refresh-container-topbox-icon"
        })) : createCommentVNode("", true),
        createBaseVNode("div", _hoisted_1$C, toDisplayString(_ctx.getPullStatus), 1),
        _ctx.status == "pulling" ? renderSlot(_ctx.$slots, "pulling", { key: 1 }) : createCommentVNode("", true),
        _ctx.status == "loosing" ? renderSlot(_ctx.$slots, "loosing", { key: 2 }) : createCommentVNode("", true),
        _ctx.status == "loading" ? renderSlot(_ctx.$slots, "loading", { key: 3 }) : createCommentVNode("", true),
        _ctx.status == "complete" ? renderSlot(_ctx.$slots, "complete", { key: 4 }) : createCommentVNode("", true)
      ], 4),
      renderSlot(_ctx.$slots, "default")
    ], 4)
  ], 544);
}
const index$n = /* @__PURE__ */ _export_sfc(_sfc_main$M, [["render", _sfc_render$y]]);
const { create: create$x } = createComponent("notify");
const _sfc_main$L = create$x({
  components: {
    NutPopup
  },
  props: {
    id: String,
    color: {
      type: String,
      default: ""
    },
    msg: {
      type: String,
      default: ""
    },
    duration: {
      type: Number,
      default: 3e3
    },
    className: {
      type: String,
      default: ""
    },
    background: {
      type: String,
      default: ""
    },
    type: {
      type: String,
      default: "danger"
    },
    visible: {
      type: Boolean,
      default: false
    },
    position: {
      type: String,
      default: "top"
    },
    teleportDisable: {
      type: Boolean,
      default: true
    },
    onClose: Function,
    onClick: Function,
    unmount: Function
  },
  emits: ["update:visible"],
  setup(props, { emit: emit2 }) {
    const clickCover = () => {
      props.onClick && props.onClick();
    };
    let timer = null;
    const clearTimer = () => {
      timer && clearTimeout(timer);
      timer = null;
    };
    const hide = () => {
      emit2("update:visible", false);
    };
    const isShowPopup = ref(false);
    const unWatch = watch(
      () => props.visible,
      (newVal) => {
        isShowPopup.value = props.visible;
        const DURATION = props.duration;
        if (newVal && DURATION) {
          timer = setTimeout(() => {
            hide();
          }, DURATION);
        }
      },
      { immediate: true }
    );
    const onAfterLeave = () => {
      clearTimer();
      unWatch && unWatch();
      props.unmount && props.unmount(props.id);
      props.onClose && props.onClose();
    };
    return { onAfterLeave, clickCover, isShowPopup };
  }
});
function _sfc_render$x(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_popup = resolveComponent("nut-popup");
  return openBlock(), createBlock(_component_nut_popup, {
    visible: _ctx.isShowPopup,
    "onUpdate:visible": _cache[1] || (_cache[1] = ($event) => _ctx.isShowPopup = $event),
    position: _ctx.position,
    overlay: false,
    "teleport-disable": _ctx.teleportDisable
  }, {
    default: withCtx(() => [
      createBaseVNode("div", {
        class: normalizeClass(["nut-notify", `nut-notify--${_ctx.type}`, _ctx.className]),
        style: normalizeStyle({ color: _ctx.color, background: _ctx.background }),
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.clickCover && _ctx.clickCover(...args))
      }, [
        _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createTextVNode(toDisplayString(_ctx.msg), 1)
        ], 64))
      ], 6)
    ]),
    _: 3
  }, 8, ["visible", "position", "teleport-disable"]);
}
const Notify = /* @__PURE__ */ _export_sfc(_sfc_main$L, [["render", _sfc_render$x]]);
({
  type: "base",
  visible: true,
  msg: "",
  color: void 0,
  background: void 0,
  duration: 3e3,
  className: "",
  onClose: Function,
  // onClick: null,
  // onOpened: null,
  // textTimer: null,
  teleport: "",
  unmount: new Function()
});
var __defProp$t = Object.defineProperty;
var __defProps$t = Object.defineProperties;
var __getOwnPropDescs$t = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$t = Object.getOwnPropertySymbols;
var __hasOwnProp$t = Object.prototype.hasOwnProperty;
var __propIsEnum$t = Object.prototype.propertyIsEnumerable;
var __defNormalProp$t = (obj, key, value) => key in obj ? __defProp$t(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$t = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$t.call(b, prop))
      __defNormalProp$t(a2, prop, b[prop]);
  if (__getOwnPropSymbols$t)
    for (var prop of __getOwnPropSymbols$t(b)) {
      if (__propIsEnum$t.call(b, prop))
        __defNormalProp$t(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$t = (a2, b) => __defProps$t(a2, __getOwnPropDescs$t(b));
const _hoisted_1$B = { class: "nut-switch-button" };
const _sfc_main$K = /* @__PURE__ */ defineComponent(__spreadProps$t(__spreadValues$t({}, {
  name: "NutSwitch"
}), {
  __name: "switch",
  props: {
    modelValue: { type: [String, Number, Boolean], default: false },
    disabled: { type: Boolean, default: false },
    activeColor: { default: "" },
    inactiveColor: { default: "" },
    activeText: { default: "" },
    inactiveText: { default: "" },
    activeValue: { type: [String, Number, Boolean], default: true },
    inactiveValue: { type: [String, Number, Boolean], default: false },
    loading: { type: Boolean, default: false },
    disable: { type: Boolean, default: false }
  },
  emits: ["change", "update:modelValue", "update:loading"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const legacyDisabled = computed(() => props.disabled || props.disable);
    const disabled = useFormDisabled(legacyDisabled);
    const isActive = computed(() => props.modelValue === props.activeValue);
    const classes = computed(() => {
      const prefixCls2 = "nut-switch";
      return {
        [prefixCls2]: true,
        [isActive.value ? "nut-switch-open" : "nut-switch-close"]: true,
        [`${prefixCls2}-disabled`]: disabled.value,
        [`${prefixCls2}-base`]: true
      };
    });
    const style = computed(() => {
      return {
        backgroundColor: isActive.value ? props.activeColor : props.inactiveColor
      };
    });
    let updateType = "";
    const onClick = (event) => {
      if (props.loading || disabled.value) return;
      const value = isActive.value ? props.inactiveValue : props.activeValue;
      updateType = "click";
      emit2("update:modelValue", value);
      emit2("change", value, event);
    };
    watch(
      () => props.modelValue,
      (v2) => {
        if (updateType == "click") {
          updateType = "";
        } else {
          emit2("change", v2);
        }
      }
    );
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("view", {
        class: normalizeClass(classes.value),
        style: normalizeStyle(style.value),
        onClick
      }, [
        createBaseVNode("view", _hoisted_1$B, [
          _ctx.loading ? renderSlot(_ctx.$slots, "icon", { key: 0 }, () => [
            createVNode(unref(w$7), {
              name: "loading",
              color: _ctx.activeColor
            }, null, 8, ["color"])
          ]) : createCommentVNode("", true),
          _ctx.activeText ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            withDirectives(createBaseVNode("view", { class: "nut-switch-label open" }, toDisplayString(_ctx.activeText), 513), [
              [vShow, isActive.value]
            ]),
            withDirectives(createBaseVNode("view", { class: "nut-switch-label close" }, toDisplayString(_ctx.inactiveText), 513), [
              [vShow, !isActive.value]
            ])
          ], 64)) : createCommentVNode("", true)
        ])
      ], 6);
    };
  }
}));
withInstall(_sfc_main$K);
const { create: create$w } = createComponent("toast");
const _sfc_main$J = create$w({
  components: {},
  props: {
    id: String,
    msg: String,
    duration: {
      type: Number,
      default: 2e3
    },
    center: {
      type: Boolean,
      default: true
    },
    type: {
      type: String,
      default: "text"
    },
    customClass: String,
    bottom: {
      type: String,
      default: "30px"
    },
    size: {
      type: [String, Number],
      default: "base"
    },
    icon: {
      type: Object,
      default: null
    },
    textAlignCenter: {
      type: Boolean,
      default: true
    },
    loadingRotate: {
      type: Boolean,
      default: true
    },
    bgColor: {
      type: String,
      default: ""
    },
    onClose: Function,
    unmount: Function,
    cover: {
      type: Boolean,
      default: false
    },
    coverColor: {
      type: String,
      default: ""
    },
    title: {
      type: String,
      default: ""
    },
    closeOnClickOverlay: {
      type: Boolean,
      default: false
    }
  },
  emits: ["close"],
  setup(props, { emit: emit2 }) {
    let timer;
    const state = reactive({
      mounted: false
    });
    onMounted(() => {
      state.mounted = true;
    });
    const clearTimer = () => {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
    };
    const hide = () => {
      state.mounted = false;
    };
    const show = () => {
      clearTimer();
      if (props.duration) {
        timer = window.setTimeout(() => {
          hide();
        }, props.duration);
      }
    };
    const clickCover = () => {
      if (props.closeOnClickOverlay) {
        hide();
        emit2("close");
      }
    };
    if (props.duration) {
      show();
    }
    watch(
      () => props.duration,
      (val) => {
        if (val) {
          show();
        }
      }
    );
    const hasIcon = computed(() => {
      if (props.type !== "text") {
        return true;
      } else {
        return props.icon !== null;
      }
    });
    const toastBodyClass = computed(() => {
      return [
        "nut-toast",
        { "nut-toast-center": props.center },
        { "nut-toast-has-icon": hasIcon.value },
        { "nut-toast-cover": props.cover },
        { "nut-toast-loading": props.type === "loading" },
        props.customClass,
        "nut-toast-" + props.size
      ];
    });
    const toastIconWrapperClass = computed(() => {
      return ["nut-toast-icon-wrapper", { "nut-toast-icon-no-animation": !props.loadingRotate }];
    });
    const onAfterLeave = () => {
      var _a;
      clearTimer();
      (_a = props.unmount) == null ? void 0 : _a.call(props, props.id);
      props.onClose && props.onClose();
    };
    return {
      state,
      hide,
      clickCover,
      hasIcon,
      toastBodyClass,
      toastIconWrapperClass,
      onAfterLeave,
      renderIcon
    };
  }
});
const _hoisted_1$A = {
  key: 1,
  class: "nut-toast-title"
};
const _hoisted_2$v = ["innerHTML"];
function _sfc_render$w(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, {
    name: "toast-fade",
    onAfterLeave: _ctx.onAfterLeave
  }, {
    default: withCtx(() => [
      withDirectives(createBaseVNode("view", {
        class: normalizeClass(_ctx.toastBodyClass),
        style: normalizeStyle({
          bottom: _ctx.center ? "auto" : _ctx.bottom,
          "background-color": _ctx.coverColor
        }),
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.clickCover && _ctx.clickCover(...args))
      }, [
        createBaseVNode("view", {
          class: "nut-toast-inner",
          style: normalizeStyle({
            "text-align": _ctx.textAlignCenter ? "center" : "left",
            "background-color": _ctx.bgColor
          })
        }, [
          _ctx.hasIcon ? (openBlock(), createElementBlock("view", {
            key: 0,
            class: normalizeClass(_ctx.toastIconWrapperClass)
          }, [
            (openBlock(), createBlock(resolveDynamicComponent(_ctx.renderIcon(_ctx.icon)), { color: "#ffffff" }))
          ], 2)) : createCommentVNode("", true),
          _ctx.title ? (openBlock(), createElementBlock("div", _hoisted_1$A, toDisplayString(_ctx.title), 1)) : createCommentVNode("", true),
          createBaseVNode("view", {
            class: "nut-toast-text",
            innerHTML: _ctx.msg
          }, null, 8, _hoisted_2$v)
        ], 4)
      ], 6), [
        [vShow, _ctx.state.mounted]
      ])
    ]),
    _: 1
  }, 8, ["onAfterLeave"]);
}
const Toast = /* @__PURE__ */ _export_sfc(_sfc_main$J, [["render", _sfc_render$w]]);
const AUDIO_KEY = Symbol("nut-audio");
var __defProp$s = Object.defineProperty;
var __defProps$s = Object.defineProperties;
var __getOwnPropDescs$s = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$s = Object.getOwnPropertySymbols;
var __hasOwnProp$s = Object.prototype.hasOwnProperty;
var __propIsEnum$s = Object.prototype.propertyIsEnumerable;
var __defNormalProp$s = (obj, key, value) => key in obj ? __defProp$s(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$s = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$s.call(b, prop))
      __defNormalProp$s(a2, prop, b[prop]);
  if (__getOwnPropSymbols$s)
    for (var prop of __getOwnPropSymbols$s(b)) {
      if (__propIsEnum$s.call(b, prop))
        __defNormalProp$s(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$s = (a2, b) => __defProps$s(a2, __getOwnPropDescs$s(b));
const { create: create$v } = createComponent("audio");
const _sfc_main$I = create$v({
  props: {
    url: {
      type: String,
      default: ""
    },
    // 静音
    muted: {
      type: Boolean,
      default: false
    },
    // 自动播放
    autoplay: {
      type: Boolean,
      default: false
    },
    // 循环播放
    loop: {
      type: Boolean,
      default: false
    },
    // 是否预加载音频
    preload: {
      type: String,
      default: "auto"
    },
    /* 总时长秒数 */
    second: {
      type: Number,
      default: 0
    },
    // 展示的形式   controls 控制面板   progress 进度条  icon 图标 none 自定义
    type: {
      type: String,
      default: "progress"
    }
  },
  components: {
    Service: w$2,
    NutRange
  },
  emits: ["fastBack", "play", "forward", "ended", "changeProgress", "mute", "canPlay"],
  setup(props, { emit: emit2, slots }) {
    const audioRef = ref(null);
    const audioData = reactive({
      currentTime: 0,
      currentDuration: "00:00:00",
      percent: 0,
      duration: "00:00:00",
      second: 0,
      hanMuted: props.muted,
      playing: props.autoplay,
      handPlaying: false
    });
    onMounted(() => {
      var arr = ["webkitVisibilityState", "visibilitychange"];
      try {
        for (let i2 = 0; i2 < arr.length; i2++) {
          document.addEventListener(arr[i2], () => {
            if (document.hidden) {
              audioRef.value.pause();
            } else {
              if (audioData.playing) {
                setTimeout(() => {
                  audioRef.value.play();
                }, 200);
              }
            }
          });
        }
      } catch (e) {
        console.log(e.message);
      }
    });
    const onCanplay = (e) => {
      const audioR = audioRef.value;
      if (props.autoplay) {
        if (audioR && audioR.paused) {
          audioR.play();
        }
      }
      audioData.second = audioR.duration;
      audioData.duration = formatSeconds(audioR.duration);
      emit2("canPlay", e);
    };
    const onTimeupdate = (e) => {
      audioData.currentTime = parseInt(e.target.currentTime);
    };
    const fastBack = () => {
      if (audioData.currentTime > 0) {
        audioData.currentTime--;
      }
      audioRef.value.currentTime = audioData.currentTime;
      emit2("fastBack", audioData.currentTime);
    };
    const changeStatus = () => {
      const audioR = audioRef.value;
      if (audioData.playing) {
        audioR.pause();
        audioData.handPlaying = false;
      } else {
        audioR.play();
        audioData.handPlaying = true;
      }
      audioData.playing = !audioData.playing;
      emit2("play", audioData.playing);
    };
    const forward = () => {
      audioData.currentTime++;
      audioRef.value.currentTime = audioData.currentTime;
      emit2("forward", audioData.currentTime);
    };
    const handle = (val) => {
      audioData.currentDuration = formatSeconds(val);
      audioData.percent = val / audioData.second * 100;
    };
    const audioEnd = () => {
      audioData.playing = false;
      emit2("ended");
    };
    const progressChange = (val) => {
      const ar = audioRef.value;
      ar.currentTime = audioData.second * val / 100;
      emit2("changeProgress", ar.currentTime);
    };
    const handleMute = () => {
      audioData.hanMuted = !audioData.hanMuted;
      emit2("mute", audioData.hanMuted);
    };
    const formatSeconds = (value) => {
      if (!value) {
        return "00:00:00";
      }
      let time = parseInt(value);
      let hours = Math.floor(time / 3600);
      let minutes = Math.floor((time - hours * 3600) / 60);
      let seconds = time - hours * 3600 - minutes * 60;
      let result = "";
      result += ("0" + hours.toString()).slice(-2) + ":";
      result += ("0" + minutes.toString()).slice(-2) + ":";
      result += ("0" + seconds.toString()).slice(-2);
      return result;
    };
    watch(
      () => audioData.currentTime,
      (value) => {
        handle(value);
      }
    );
    provide(AUDIO_KEY, {
      children: [],
      props,
      audioData,
      handleMute,
      forward,
      fastBack,
      changeStatus
    });
    return __spreadProps$s(__spreadValues$s(__spreadValues$s({}, toRefs(props)), toRefs(audioData)), {
      audioRef,
      fastBack,
      forward,
      changeStatus,
      progressChange,
      audioEnd,
      onTimeupdate,
      handleMute,
      onCanplay,
      slots
    });
  }
});
const _hoisted_1$z = { class: "nut-audio" };
const _hoisted_2$u = {
  key: 0,
  class: "nut-audio__progress"
};
const _hoisted_3$q = { class: "nut-audio__time" };
const _hoisted_4$m = { class: "nut-audio__bar" };
const _hoisted_5$f = /* @__PURE__ */ createBaseVNode("div", { class: "nut-audio__button--custom" }, null, -1);
const _hoisted_6$e = { class: "nut-audio__time" };
const _hoisted_7$b = {
  key: 1,
  class: "nut-audio__icon"
};
const _hoisted_8$8 = ["controls", "src", "preload", "autoplay", "loop", "muted"];
function _sfc_render$v(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_range = resolveComponent("nut-range");
  const _component_Service = resolveComponent("Service");
  return openBlock(), createElementBlock("div", _hoisted_1$z, [
    _ctx.type == "progress" ? (openBlock(), createElementBlock("div", _hoisted_2$u, [
      createBaseVNode("div", _hoisted_3$q, toDisplayString(_ctx.currentDuration), 1),
      createBaseVNode("div", _hoisted_4$m, [
        createVNode(_component_nut_range, {
          modelValue: _ctx.percent,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.percent = $event),
          "hidden-range": "",
          "inactive-color": "#cccccc",
          "active-color": "#fa2c19",
          onChange: _ctx.progressChange
        }, {
          button: withCtx(() => [
            _hoisted_5$f
          ]),
          _: 1
        }, 8, ["modelValue", "onChange"])
      ]),
      createBaseVNode("div", _hoisted_6$e, toDisplayString(_ctx.duration), 1)
    ])) : createCommentVNode("", true),
    _ctx.type == "icon" ? (openBlock(), createElementBlock("div", _hoisted_7$b, [
      createBaseVNode("div", {
        class: normalizeClass(["nut-audio__icon--box", _ctx.playing ? "nut-audio__icon--play" : "nut-audio__icon--stop"]),
        onClick: _cache[1] || (_cache[1] = (...args) => _ctx.changeStatus && _ctx.changeStatus(...args))
      }, [
        _ctx.playing ? (openBlock(), createBlock(_component_Service, {
          key: 0,
          class: "nut-icon-am-rotate nut-icon-am-infinite"
        })) : (openBlock(), createBlock(_component_Service, { key: 1 }))
      ], 2)
    ])) : createCommentVNode("", true),
    _ctx.type == "none" ? (openBlock(), createElementBlock("div", {
      key: 2,
      onClick: _cache[2] || (_cache[2] = (...args) => _ctx.changeStatus && _ctx.changeStatus(...args))
    }, [
      renderSlot(_ctx.$slots, "default")
    ])) : createCommentVNode("", true),
    _ctx.type != "none" ? renderSlot(_ctx.$slots, "default", { key: 3 }) : createCommentVNode("", true),
    createBaseVNode("audio", {
      ref: "audioRef",
      class: "audioMain",
      controls: _ctx.type == "controls",
      src: _ctx.url,
      preload: _ctx.preload,
      autoplay: _ctx.autoplay,
      loop: _ctx.loop,
      muted: _ctx.hanMuted,
      onTimeupdate: _cache[3] || (_cache[3] = (...args) => _ctx.onTimeupdate && _ctx.onTimeupdate(...args)),
      onCanplay: _cache[4] || (_cache[4] = (...args) => _ctx.onCanplay && _ctx.onCanplay(...args)),
      onEnded: _cache[5] || (_cache[5] = (...args) => _ctx.audioEnd && _ctx.audioEnd(...args))
    }, null, 40, _hoisted_8$8)
  ]);
}
const index$m = /* @__PURE__ */ _export_sfc(_sfc_main$I, [["render", _sfc_render$v]]);
var __defProp$r = Object.defineProperty;
var __defProps$r = Object.defineProperties;
var __getOwnPropDescs$r = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$r = Object.getOwnPropertySymbols;
var __hasOwnProp$r = Object.prototype.hasOwnProperty;
var __propIsEnum$r = Object.prototype.propertyIsEnumerable;
var __defNormalProp$r = (obj, key, value) => key in obj ? __defProp$r(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$r = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$r.call(b, prop))
      __defNormalProp$r(a2, prop, b[prop]);
  if (__getOwnPropSymbols$r)
    for (var prop of __getOwnPropSymbols$r(b)) {
      if (__propIsEnum$r.call(b, prop))
        __defNormalProp$r(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$r = (a2, b) => __defProps$r(a2, __getOwnPropDescs$r(b));
const { create: create$u } = createComponent("audio-operate");
const cN$b = "NutAudioOperate";
const _sfc_main$H = create$u({
  props: {
    // 展示的形式   back 倒退   play 开始 or 暂停  forward 快进 mute 静音
    type: {
      type: String,
      default: () => "play"
    }
  },
  components: {
    NutButton: _sfc_main$1G
  },
  emits: ["click"],
  setup(props) {
    const translate = useLocale(cN$b);
    const audio = inject(AUDIO_KEY);
    const parent = reactive(audio);
    const customSlot = ref(useSlots().default);
    return __spreadProps$r(__spreadValues$r(__spreadValues$r({}, toRefs(props)), toRefs(parent)), { customSlot, translate });
  }
});
const _hoisted_1$y = { class: "nut-audio-operate" };
function _sfc_render$u(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_button = resolveComponent("nut-button");
  return openBlock(), createElementBlock("div", _hoisted_1$y, [
    _ctx.type == "back" ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: "nut-audio-operate-item",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.fastBack && _ctx.fastBack(...args))
    }, [
      !_ctx.customSlot ? (openBlock(), createBlock(_component_nut_button, {
        key: 0,
        type: "primary",
        size: "small"
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.translate("back")), 1)
        ]),
        _: 1
      })) : createCommentVNode("", true),
      renderSlot(_ctx.$slots, "default")
    ])) : createCommentVNode("", true),
    _ctx.type == "play" ? (openBlock(), createElementBlock("div", {
      key: 1,
      class: "nut-audio-operate-item",
      onClick: _cache[1] || (_cache[1] = (...args) => _ctx.changeStatus && _ctx.changeStatus(...args))
    }, [
      !_ctx.customSlot ? (openBlock(), createBlock(_component_nut_button, {
        key: 0,
        type: "primary",
        size: "small"
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(!_ctx.audioData.playing ? `${_ctx.translate("start")}` : `${_ctx.translate("pause")}`), 1)
        ]),
        _: 1
      })) : createCommentVNode("", true),
      renderSlot(_ctx.$slots, "default")
    ])) : createCommentVNode("", true),
    _ctx.type == "forward" ? (openBlock(), createElementBlock("div", {
      key: 2,
      class: "nut-audio-operate-item",
      onClick: _cache[2] || (_cache[2] = (...args) => _ctx.forward && _ctx.forward(...args))
    }, [
      !_ctx.customSlot ? (openBlock(), createBlock(_component_nut_button, {
        key: 0,
        type: "primary",
        size: "small"
      }, {
        default: withCtx(() => [
          createTextVNode("快进")
        ]),
        _: 1
      })) : createCommentVNode("", true),
      renderSlot(_ctx.$slots, "default")
    ])) : createCommentVNode("", true),
    _ctx.type == "mute" ? (openBlock(), createElementBlock("div", {
      key: 3,
      class: "nut-audio-operate-item",
      onClick: _cache[3] || (_cache[3] = (...args) => _ctx.handleMute && _ctx.handleMute(...args))
    }, [
      !_ctx.customSlot ? (openBlock(), createBlock(_component_nut_button, {
        key: 0,
        type: !_ctx.audioData.hanMuted ? "primary" : "default",
        size: "small"
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.translate("mute")), 1)
        ]),
        _: 1
      }, 8, ["type"])) : createCommentVNode("", true),
      renderSlot(_ctx.$slots, "default")
    ])) : createCommentVNode("", true)
  ]);
}
const index$l = /* @__PURE__ */ _export_sfc(_sfc_main$H, [["render", _sfc_render$u]]);
const AVATAR_KEY = Symbol("nut-avatar");
const { create: create$t } = createComponent("avatar");
const _sfc_main$G = create$t({
  props: {
    size: {
      type: [String, Number],
      default: "normal"
    },
    shape: {
      type: String,
      default: "round"
    },
    bgColor: {
      type: String,
      default: "#eee"
    },
    color: {
      type: String,
      default: "#666"
    }
  },
  setup(props) {
    const { size, shape, bgColor, color } = toRefs(props);
    const sizeValue = ["large", "normal", "small"];
    const avatarGroup = inject(AVATAR_KEY, null);
    const avatarRef = ref(null);
    const classes = computed(() => {
      var _a, _b;
      const prefixCls2 = "nut-avatar";
      return {
        [prefixCls2]: true,
        [`nut-avatar-${size.value || ((_a = avatarGroup == null ? void 0 : avatarGroup.props) == null ? void 0 : _a.size) || "normal"}`]: true,
        [`nut-avatar-${shape.value || ((_b = avatarGroup == null ? void 0 : avatarGroup.props) == null ? void 0 : _b.shape) || "round"}`]: true
      };
    });
    const styles = computed(() => {
      var _a, _b;
      return {
        width: size.value in sizeValue ? "" : `${size.value}px`,
        height: size.value in sizeValue ? "" : `${size.value}px`,
        backgroundColor: `${bgColor.value}`,
        color: `${color.value}`,
        marginLeft: ((_a = avatarGroup == null ? void 0 : avatarGroup.props) == null ? void 0 : _a.span) ? `${(_b = avatarGroup == null ? void 0 : avatarGroup.props) == null ? void 0 : _b.span}px` : ""
      };
    });
    return {
      classes,
      styles,
      avatarRef
    };
  }
});
function _sfc_render$t(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    ref: "avatarRef",
    style: normalizeStyle(_ctx.styles),
    class: normalizeClass(_ctx.classes)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 6);
}
const NutAvatar = /* @__PURE__ */ _export_sfc(_sfc_main$G, [["render", _sfc_render$t]]);
const { create: create$s } = createComponent("avatar-group");
const _sfc_main$F = create$s({
  components: {
    NutAvatar
  },
  props: {
    maxContent: {
      type: String,
      default: ""
    },
    maxCount: {
      type: [Number, String],
      default: ""
    },
    maxBgColor: {
      type: String,
      default: "#eee"
    },
    maxColor: {
      type: String,
      default: "#666"
    },
    size: {
      type: [String, Number],
      default: "normal"
    },
    shape: {
      type: String,
      default: "round"
    },
    span: {
      type: [String, Number],
      default: "-8"
    },
    zIndex: {
      type: String,
      default: "left"
    }
  },
  setup(props) {
    const avatarGroupRef = ref(null);
    const foldCount = ref(99);
    const observer = ref();
    const styles = computed(() => {
      return {
        marginLeft: -1 * Number(props.span) + "px"
      };
    });
    const foldAvatar = (element) => {
      let count2 = 0;
      if (element && element.$el) {
        element = element.$el;
      }
      const children = element.children;
      if (props.zIndex === "right") {
        for (let i2 = 0; i2 < Number(props.maxCount); i2++) {
          const child = children[i2];
          child.style.zIndex = `${99 - i2}`;
        }
      }
      for (let i2 = Number(props.maxCount); i2 < children.length; i2++) {
        const child = children[i2];
        if (child.className.includes("avater-fold")) {
          continue;
        }
        child.style.display = "none";
        count2++;
      }
      foldCount.value = count2;
    };
    const watchDefaultSlot = (element) => {
      const config = { attributes: false, childList: true, subtree: true };
      const callback = function(mutations) {
        let sig = false;
        for (let mutation of mutations) {
          if (mutation.type === "childList") {
            sig = true;
            break;
          }
        }
        if (sig) foldAvatar(element);
      };
      const observer2 = new MutationObserver(callback);
      observer2.observe(element, config);
      return observer2;
    };
    onMounted(() => {
      if (props.maxCount) {
        nextTick(() => {
          let element = unref(avatarGroupRef);
          if (element && element.$el) {
            element = element.$el;
          }
          foldAvatar(element);
          observer.value = watchDefaultSlot(element);
        });
      }
    });
    onUnmounted(() => {
      var _a;
      (_a = observer.value) == null ? void 0 : _a.disconnect();
    });
    provide(AVATAR_KEY, {
      props,
      avatarGroupRef
    });
    return {
      styles,
      foldCount,
      avatarGroupRef
    };
  }
});
function _sfc_render$s(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_avatar = resolveComponent("nut-avatar");
  return openBlock(), createElementBlock("view", {
    ref: "avatarGroupRef",
    class: "nut-avatar-group",
    style: normalizeStyle(_ctx.styles)
  }, [
    renderSlot(_ctx.$slots, "default"),
    _ctx.foldCount > 0 ? (openBlock(), createBlock(_component_nut_avatar, {
      key: 0,
      class: "avater-fold",
      color: _ctx.maxColor,
      "bg-color": _ctx.maxBgColor,
      size: _ctx.size,
      shape: _ctx.shape,
      style: normalizeStyle({ magrinLeft: `${_ctx.span}px` })
    }, {
      default: withCtx(() => [
        createTextVNode(toDisplayString(_ctx.maxContent || _ctx.foldCount), 1)
      ]),
      _: 1
    }, 8, ["color", "bg-color", "size", "shape", "style"])) : createCommentVNode("", true)
  ], 4);
}
const index$k = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["render", _sfc_render$s]]);
var __defProp$q = Object.defineProperty;
var __defProps$q = Object.defineProperties;
var __getOwnPropDescs$q = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$q = Object.getOwnPropertySymbols;
var __hasOwnProp$q = Object.prototype.hasOwnProperty;
var __propIsEnum$q = Object.prototype.propertyIsEnumerable;
var __defNormalProp$q = (obj, key, value) => key in obj ? __defProp$q(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$q = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$q.call(b, prop))
      __defNormalProp$q(a2, prop, b[prop]);
  if (__getOwnPropSymbols$q)
    for (var prop of __getOwnPropSymbols$q(b)) {
      if (__propIsEnum$q.call(b, prop))
        __defNormalProp$q(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$q = (a2, b) => __defProps$q(a2, __getOwnPropDescs$q(b));
var CompareResult = /* @__PURE__ */ ((CompareResult2) => {
  CompareResult2[CompareResult2["eq"] = 1] = "eq";
  CompareResult2[CompareResult2["lt"] = 2] = "lt";
  CompareResult2[CompareResult2["gt"] = 3] = "gt";
  return CompareResult2;
})(CompareResult || {});
function binarySearch(list, value, compareFunc) {
  let start = 0;
  let end = list.length - 1;
  let tempIndex = null;
  while (start <= end) {
    tempIndex = Math.floor((start + end) / 2);
    const midValue = list[tempIndex];
    const compareRes = compareFunc(midValue, value);
    if (compareRes === 1) {
      return tempIndex;
    }
    if (compareRes === 2) {
      start = tempIndex + 1;
    } else if (compareRes === 3) {
      end = tempIndex - 1;
    }
  }
  return tempIndex;
}
const { create: create$r } = createComponent("list");
const _sfc_main$E = create$r({
  props: {
    listData: {
      type: Array,
      default: () => {
        return [];
      }
    },
    bufferSize: {
      type: Number,
      default: 5
    },
    containerHeight: {
      type: Number
    },
    height: {
      type: Number,
      default: 80
    },
    margin: {
      type: Number,
      default: 10
    }
  },
  emits: ["scrollUp", "scrollDown", "scrollBottom"],
  setup(props, { emit: emit2 }) {
    const clientHeight = document.documentElement.clientHeight || document.body.clientHeight || 667;
    const list = ref(null);
    const phantom = ref(null);
    const actualContent = ref(null);
    const state = reactive({
      start: 0,
      originStartIndex: 0,
      scrollTop: 0,
      list: props.listData.slice(),
      cachePositions: [],
      phantomHeight: props.height * props.listData.length
    });
    const getContainerHeight = computed(() => {
      if (props.containerHeight) {
        return Math.min(props.containerHeight, clientHeight);
      }
      return clientHeight;
    });
    const visibleCount = computed(() => {
      return Math.ceil(getContainerHeight.value / props.height);
    });
    const end = computed(() => {
      return Math.min(state.originStartIndex + visibleCount.value + props.bufferSize, state.list.length);
    });
    const visibleData = computed(() => {
      return state.list.slice(state.start, end.value);
    });
    const getTransform = () => {
      if (actualContent.value) {
        return `translate3d(0, ${state.start >= 1 ? state.cachePositions[state.start - 1].bottom : 0}px, 0)`;
      }
    };
    const initCachedPosition = () => {
      state.cachePositions = [];
      for (let i2 = 0; i2 < state.list.length; ++i2) {
        state.cachePositions[i2] = {
          index: i2,
          height: props.height,
          top: i2 * props.height,
          bottom: (i2 + 1) * (props.height + props.margin),
          dValue: 0
        };
      }
    };
    const updateCachedPosition = () => {
      let nodes = actualContent.value.childNodes;
      nodes = Array.from(nodes).filter((node) => node.nodeType === 1);
      const start = nodes[0];
      nodes.forEach((node, index2) => {
        if (!node) return;
        const rect = useRect(node);
        const { height: height2 } = rect;
        const oldHeight = state.cachePositions[index2 + state.start].height;
        const dValue = oldHeight - height2;
        if (dValue) {
          state.cachePositions[index2 + state.start].bottom -= dValue;
          state.cachePositions[index2 + state.start].height = height2;
          state.cachePositions[index2 + state.start].dValue = dValue;
        }
      });
      let startIndex = 0;
      if (start) {
        startIndex = state.start;
      }
      const cachedPositionsLen = state.cachePositions.length;
      let cumulativeDiffHeight = state.cachePositions[startIndex].dValue;
      state.cachePositions[startIndex].dValue = 0;
      for (let i2 = startIndex + 1; i2 < cachedPositionsLen; ++i2) {
        const item = state.cachePositions[i2];
        state.cachePositions[i2].top = state.cachePositions[i2 - 1].bottom;
        state.cachePositions[i2].bottom = state.cachePositions[i2].bottom - cumulativeDiffHeight;
        if (item.dValue !== 0) {
          cumulativeDiffHeight += item.dValue;
          item.dValue = 0;
        }
      }
      const height = state.cachePositions[cachedPositionsLen - 1].bottom;
      state.phantomHeight = height;
    };
    const getStartIndex = (scrollTop = 0) => {
      let idx = binarySearch(
        state.cachePositions,
        scrollTop,
        (currentValue, targetValue) => {
          const currentCompareValue = currentValue.bottom;
          if (currentCompareValue === targetValue) {
            return CompareResult.eq;
          }
          if (currentCompareValue < targetValue) {
            return CompareResult.lt;
          }
          return CompareResult.gt;
        }
      );
      const targetItem = state.cachePositions[idx];
      if (targetItem.bottom < scrollTop) {
        idx += 1;
      }
      return idx;
    };
    const resetAllVirtualParam = () => {
      state.originStartIndex = 0;
      state.start = 0;
      state.scrollTop = 0;
      list.value.scrollTop = 0;
      initCachedPosition();
      state.phantomHeight = props.height * state.list.length;
    };
    const handleScrollEvent = () => {
      var _a;
      const scrollTop = (_a = list.value) == null ? void 0 : _a.scrollTop;
      const { originStartIndex } = state;
      const currentIndex = getStartIndex(scrollTop);
      if (currentIndex !== originStartIndex) {
        state.originStartIndex = currentIndex;
        state.start = Math.max(state.originStartIndex - props.bufferSize, 0);
        if (end.value >= state.list.length - 1) {
          emit2("scrollBottom");
        }
      }
      emit2(scrollTop > state.scrollTop ? "scrollUp" : "scrollDown", scrollTop);
      state.scrollTop = scrollTop;
    };
    initCachedPosition();
    watch(
      () => props.listData,
      (val) => {
        state.list = val.slice();
        if (state.list.length === val.length) {
          initCachedPosition();
          updateCachedPosition();
        } else {
          resetAllVirtualParam();
          return;
        }
      }
    );
    watch(
      () => state.start,
      () => {
        if (actualContent.value && state.list.length > 0) {
          updateCachedPosition();
        }
      }
    );
    return __spreadProps$q(__spreadValues$q({}, toRefs(state)), {
      list,
      phantom,
      actualContent,
      getTransform,
      visibleData,
      getContainerHeight,
      handleScrollEvent
    });
  }
});
function _sfc_render$r(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "list",
    class: "nut-list",
    style: normalizeStyle({ height: `${_ctx.getContainerHeight}px` }),
    onScrollPassive: _cache[0] || (_cache[0] = (...args) => _ctx.handleScrollEvent && _ctx.handleScrollEvent(...args))
  }, [
    createBaseVNode("div", {
      ref: "phantom",
      class: "nut-list-phantom",
      style: normalizeStyle({ height: _ctx.phantomHeight + "px" })
    }, null, 4),
    createBaseVNode("div", {
      ref: "actualContent",
      class: "nut-list-container",
      style: normalizeStyle({ transform: _ctx.getTransform() })
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.visibleData, (item, index2) => {
        return openBlock(), createElementBlock("div", {
          key: item,
          class: "nut-list-item"
        }, [
          renderSlot(_ctx.$slots, "default", {
            item,
            index: index2 + _ctx.start
          })
        ]);
      }), 128))
    ], 4)
  ], 36);
}
const index$j = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["render", _sfc_render$r]]);
var __defProp$p = Object.defineProperty;
var __defProps$p = Object.defineProperties;
var __getOwnPropDescs$p = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$p = Object.getOwnPropertySymbols;
var __hasOwnProp$p = Object.prototype.hasOwnProperty;
var __propIsEnum$p = Object.prototype.propertyIsEnumerable;
var __defNormalProp$p = (obj, key, value) => key in obj ? __defProp$p(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$p = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$p.call(b, prop))
      __defNormalProp$p(a2, prop, b[prop]);
  if (__getOwnPropSymbols$p)
    for (var prop of __getOwnPropSymbols$p(b)) {
      if (__propIsEnum$p.call(b, prop))
        __defNormalProp$p(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$p = (a2, b) => __defProps$p(a2, __getOwnPropDescs$p(b));
const _hoisted_1$x = { viewBox: "0 0 100 100" };
const _hoisted_2$t = ["id"];
const _hoisted_3$p = ["offset", "stop-color"];
const _hoisted_4$l = ["d", "stroke-width"];
const _hoisted_5$e = ["d", "stroke", "stroke-linecap", "stroke-width"];
const _hoisted_6$d = { class: "nut-circle-progress__text" };
const _sfc_main$D = /* @__PURE__ */ defineComponent(__spreadProps$p(__spreadValues$p({}, {
  name: "NutCircleProgress"
}), {
  __name: "circle-progress",
  props: {
    progress: { default: 0 },
    strokeWidth: { default: 5 },
    radius: { default: 50 },
    strokeLinecap: { default: "round" },
    color: { default: "#fa2c19" },
    pathColor: { default: "#d9d9d9" },
    clockwise: { type: Boolean, default: true }
  },
  setup(__props) {
    const props = __props;
    const refRandomId = Math.random().toString(36).slice(-8);
    const path = computed(() => {
      const isWise = props.clockwise ? 1 : 0;
      return `M 50 50 m 0 -45 a 45 45 0 1 ${isWise} 0 90 a 45 45 0 1, ${isWise} 0 -90`;
    });
    const hoverColor = computed(() => {
      return isObject$1(props.color) ? `url(#${refRandomId})` : props.color;
    });
    const hoverStyle = computed(() => {
      let perimeter = 283;
      let offset = perimeter * Number(props.progress) / 100;
      return {
        stroke: isObject$1(props.color) ? `url(#${refRandomId})` : props.color,
        strokeDasharray: `${offset}px ${perimeter}px`
      };
    });
    const pathStyle = computed(() => {
      return {
        stroke: props.pathColor
      };
    });
    const stop = computed(() => {
      if (!isObject$1(props.color)) {
        return;
      }
      let color = props.color;
      const colorArr = Object.keys(color).sort((a2, b) => parseFloat(a2) - parseFloat(b));
      let stopArr = [];
      colorArr.map((item) => {
        let obj = {
          key: "",
          value: ""
        };
        obj.key = item;
        obj.value = color[item];
        stopArr.push(obj);
      });
      return stopArr;
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "nut-circle-progress",
        style: normalizeStyle({ height: Number(_ctx.radius) * 2 + "px", width: Number(_ctx.radius) * 2 + "px" })
      }, [
        (openBlock(), createElementBlock("svg", _hoisted_1$x, [
          createBaseVNode("defs", null, [
            createBaseVNode("linearGradient", {
              id: unref(refRandomId),
              x1: "100%",
              y1: "0%",
              x2: "0%",
              y2: "0%"
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(stop.value, (item, index2) => {
                return openBlock(), createElementBlock("stop", {
                  key: index2,
                  offset: item.key,
                  "stop-color": item.value
                }, null, 8, _hoisted_3$p);
              }), 128))
            ], 8, _hoisted_2$t)
          ]),
          createBaseVNode("path", {
            class: "nut-circle-progress__path",
            style: normalizeStyle(pathStyle.value),
            d: path.value,
            fill: "none",
            "stroke-width": _ctx.strokeWidth
          }, " > ", 12, _hoisted_4$l),
          createBaseVNode("path", {
            class: "nut-circle-progress__hover",
            style: normalizeStyle(hoverStyle.value),
            d: path.value,
            fill: "none",
            stroke: hoverColor.value,
            "stroke-linecap": _ctx.strokeLinecap,
            "stroke-width": _ctx.strokeWidth
          }, null, 12, _hoisted_5$e)
        ])),
        createBaseVNode("div", _hoisted_6$d, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createBaseVNode("div", null, toDisplayString(_ctx.progress) + "%", 1)
          ])
        ])
      ], 4);
    };
  }
}));
withInstall(_sfc_main$D);
var __defProp$o = Object.defineProperty;
var __defProps$o = Object.defineProperties;
var __getOwnPropDescs$o = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$o = Object.getOwnPropertySymbols;
var __hasOwnProp$o = Object.prototype.hasOwnProperty;
var __propIsEnum$o = Object.prototype.propertyIsEnumerable;
var __defNormalProp$o = (obj, key, value) => key in obj ? __defProp$o(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$o = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$o.call(b, prop))
      __defNormalProp$o(a2, prop, b[prop]);
  if (__getOwnPropSymbols$o)
    for (var prop of __getOwnPropSymbols$o(b)) {
      if (__propIsEnum$o.call(b, prop))
        __defNormalProp$o(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$o = (a2, b) => __defProps$o(a2, __getOwnPropDescs$o(b));
const { create: create$q } = createComponent("noticebar");
const _sfc_main$C = create$q({
  props: {
    direction: {
      type: String,
      default: "across"
    },
    list: {
      type: Array,
      default: () => []
    },
    standTime: {
      type: Number,
      default: 1e3
    },
    complexAm: {
      type: Boolean,
      default: false
    },
    height: {
      type: Number,
      default: 40
    },
    text: {
      type: String,
      default: ""
    },
    closeMode: {
      type: Boolean,
      default: false
    },
    wrapable: {
      type: Boolean,
      default: false
    },
    leftIcon: { type: Boolean, default: true },
    color: {
      type: String,
      default: ""
    },
    background: {
      type: String,
      default: ""
    },
    delay: {
      type: [String, Number],
      default: 1
    },
    scrollable: {
      type: Boolean,
      default: null
    },
    speed: {
      type: Number,
      default: 50
    }
  },
  components: {
    ScrollItem: function(props) {
      props.item.props.style = props.style;
      props.item.key = props.key;
      return h$2(props.item);
    },
    Notice: C,
    CircleClose: z$1
  },
  emits: ["click", "close", "acrossEnd"],
  setup(props, { emit: emit2, slots }) {
    const wrap = ref(null);
    const content = ref(null);
    const state = reactive({
      wrapWidth: 0,
      firstRound: true,
      duration: 0,
      offsetWidth: 0,
      showNoticebar: true,
      animationClass: "",
      animate: false,
      scrollList: [],
      distance: 0,
      timer: null,
      keepAlive: false,
      isCanScroll: null,
      showNotica: true
    });
    const isEllipsis = computed(() => {
      if (state.isCanScroll == null) {
        return props.wrapable;
      } else {
        return !state.isCanScroll && !props.wrapable;
      }
    });
    const wrapContentClass = computed(() => {
      return {
        "nut-noticebar__page-wrap-content": true,
        "nut-ellipsis": isEllipsis.value,
        [state.animationClass]: true
      };
    });
    const barStyle = computed(() => {
      let style = {};
      props.color && (style.color = props.color);
      props.background && (style.background = props.background);
      if (props.direction == "vertical") {
        style.height = `${props.height}px`;
      }
      return style;
    });
    const contentStyle = computed(() => {
      return {
        animationDelay: (state.firstRound ? props.delay : 0) + "s",
        animationDuration: state.duration + "s",
        transform: `translateX(${state.firstRound ? 0 : state.wrapWidth + "px"})`
      };
    });
    const horseLampStyle = computed(() => {
      let styles = {};
      if (props.complexAm) {
        styles = {
          transform: `translateY(${state.distance}px)`
        };
      } else {
        if (state.animate) {
          let a2 = ~~(props.height / props.speed / 4);
          styles = {
            transition: `all ${a2 == 0 ? ~~(props.height / props.speed) : a2}s`,
            "margin-top": `-${props.height}px`
          };
        }
      }
      return styles;
    });
    watch(
      () => props.text,
      () => {
        initScrollWrap();
      }
    );
    watch(
      () => props.list,
      (value) => {
        state.scrollList = [].concat(value);
      }
    );
    const initScrollWrap = () => {
      if (state.showNoticebar == false) {
        return;
      }
      setTimeout(() => {
        if (!wrap.value || !content.value) {
          return;
        }
        const wrapWidth = wrap.value.getBoundingClientRect().width;
        const offsetWidth = content.value.getBoundingClientRect().width;
        state.isCanScroll = props.scrollable == null ? offsetWidth > wrapWidth : props.scrollable;
        if (state.isCanScroll) {
          state.wrapWidth = wrapWidth;
          state.offsetWidth = offsetWidth;
          state.duration = offsetWidth / props.speed;
          state.animationClass = "play";
        } else {
          state.animationClass = "";
        }
      }, 0);
    };
    const handleClick = (event) => {
      emit2("click", event);
    };
    const onClickIcon = (event) => {
      if (props.closeMode) {
        state.showNoticebar = !props.closeMode;
      }
      emit2("close", event);
    };
    const onAnimationEnd = (event) => {
      state.firstRound = false;
      emit2("acrossEnd", event);
      setTimeout(() => {
        state.duration = (state.offsetWidth + state.wrapWidth) / props.speed;
        state.animationClass = "play-infinite";
      }, 0);
    };
    const startRollEasy = () => {
      showhorseLamp();
      state.timer = setInterval(showhorseLamp, ~~(props.height / props.speed / 4 * 1e3) + props.standTime);
    };
    const showhorseLamp = () => {
      state.animate = true;
      setTimeout(
        () => {
          state.scrollList.push(state.scrollList[0]);
          state.scrollList.shift();
          state.animate = false;
        },
        ~~(props.height / props.speed / 4 * 1e3)
      );
    };
    const startRoll = () => {
      state.timer = setInterval(
        () => {
          let chunk = 100;
          for (let i2 = 0; i2 < chunk; i2++) {
            scroll(i2, i2 < chunk - 1 ? false : true);
          }
        },
        props.standTime + 100 * props.speed
      );
    };
    const scroll = (n, last) => {
      setTimeout(() => {
        state.distance -= props.height / 100;
        if (last) {
          state.scrollList.push(state.scrollList[0]);
          state.scrollList.shift();
          state.distance = 0;
        }
      }, n * props.speed);
    };
    const go = (item) => {
      emit2("click", item);
    };
    const handleClickIcon = () => {
      if (props.closeMode) {
        state.showNoticebar = !props.closeMode;
      }
      emit2("close", state.scrollList[0]);
    };
    onMounted(() => {
      if (props.direction == "vertical") {
        if (slots.default) {
          updateSlotChild();
          watchSlots();
        } else {
          state.scrollList = [].concat(props.list);
        }
        setTimeout(() => {
          props.complexAm ? startRoll() : startRollEasy();
        }, props.standTime);
      } else {
        initScrollWrap();
      }
    });
    const updateSlotChild = () => {
      if (slots.default) state.scrollList = [].concat(slots.default()[0].children);
    };
    const watchSlots = () => {
      setTimeout(() => {
        var observer = new MutationObserver(() => {
          state.showNotica = false;
          setTimeout(() => {
            state.showNotica = true;
          });
          updateSlotChild();
        });
        const ele = document.getElementsByClassName("nut-noticebar-custom-item")[0];
        if (ele) {
          observer.observe(ele, {
            childList: true,
            subtree: true
          });
        }
      }, 100);
    };
    onActivated(() => {
      if (state.keepAlive) {
        state.keepAlive = false;
      }
    });
    onDeactivated(() => {
      state.keepAlive = true;
      clearInterval(state.timer);
    });
    onUnmounted(() => {
      clearInterval(state.timer);
    });
    return __spreadProps$o(__spreadValues$o({}, toRefs(state)), {
      isEllipsis,
      barStyle,
      contentStyle,
      horseLampStyle,
      wrap,
      content,
      handleClick,
      onClickIcon,
      onAnimationEnd,
      go,
      handleClickIcon,
      slots,
      pxCheck,
      wrapContentClass
    });
  }
});
const _hoisted_1$w = { class: "nut-noticebar" };
const _hoisted_2$s = {
  key: 0,
  class: "nut-noticebar__page-lefticon"
};
const _hoisted_3$o = {
  ref: "wrap",
  class: "nut-noticebar__page-wrap"
};
const _hoisted_4$k = { class: "showNotica" };
const _hoisted_5$d = { class: "nut-noticebar-custom-item" };
const _hoisted_6$c = ["onClick"];
function _sfc_render$q(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Notice = resolveComponent("Notice");
  const _component_CircleClose = resolveComponent("CircleClose");
  const _component_ScrollItem = resolveComponent("ScrollItem");
  return openBlock(), createElementBlock("view", _hoisted_1$w, [
    _ctx.direction == "across" ? withDirectives((openBlock(), createElementBlock("view", {
      key: 0,
      class: normalizeClass(["nut-noticebar__page", {
        "nut-noticebar__page--withicon": _ctx.closeMode,
        "nut-noticebar__page--close": _ctx.closeMode,
        "nut-noticebar__page--wrapable": _ctx.wrapable
      }]),
      style: normalizeStyle(_ctx.barStyle),
      onClick: _cache[3] || (_cache[3] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    }, [
      _ctx.leftIcon ? (openBlock(), createElementBlock("view", _hoisted_2$s, [
        renderSlot(_ctx.$slots, "left-icon", {}, () => [
          createVNode(_component_Notice, { size: "16px" })
        ])
      ])) : createCommentVNode("", true),
      createBaseVNode("view", _hoisted_3$o, [
        createBaseVNode("view", {
          ref: "content",
          class: normalizeClass(_ctx.wrapContentClass),
          style: normalizeStyle(_ctx.contentStyle),
          onAnimationend: _cache[0] || (_cache[0] = (...args) => _ctx.onAnimationEnd && _ctx.onAnimationEnd(...args)),
          onWebkitAnimationEnd: _cache[1] || (_cache[1] = (...args) => _ctx.onAnimationEnd && _ctx.onAnimationEnd(...args))
        }, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString(_ctx.text), 1)
          ])
        ], 38)
      ], 512),
      _ctx.closeMode || _ctx.$slots["right-icon"] ? (openBlock(), createElementBlock("view", {
        key: 1,
        class: "nut-noticebar__page-righticon",
        onClick: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.onClickIcon && _ctx.onClickIcon(...args), ["stop"]))
      }, [
        _ctx.$slots["right-icon"] ? renderSlot(_ctx.$slots, "right-icon", { key: 0 }) : (openBlock(), createBlock(_component_CircleClose, { key: 1 }))
      ])) : createCommentVNode("", true)
    ], 6)), [
      [vShow, _ctx.showNoticebar]
    ]) : createCommentVNode("", true),
    _ctx.scrollList.length > 0 && _ctx.direction == "vertical" && _ctx.showNoticebar ? (openBlock(), createElementBlock("view", {
      key: 1,
      class: "nut-noticebar__vertical",
      style: normalizeStyle(_ctx.barStyle)
    }, [
      _ctx.slots.default ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        createBaseVNode("view", {
          class: "nut-noticebar__vertical-list",
          style: normalizeStyle(_ctx.horseLampStyle)
        }, [
          createBaseVNode("div", _hoisted_4$k, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.scrollList, (item, index2) => {
              return openBlock(), createBlock(_component_ScrollItem, {
                key: index2,
                style: normalizeStyle({ height: _ctx.height + "px", "line-height": _ctx.height + "px" }),
                item
              }, null, 8, ["style", "item"]);
            }), 128))
          ])
        ], 4),
        createBaseVNode("view", _hoisted_5$d, [
          renderSlot(_ctx.$slots, "default")
        ])
      ], 64)) : (openBlock(), createElementBlock("ul", {
        key: 1,
        class: "nut-noticebar__vertical-list",
        style: normalizeStyle(_ctx.horseLampStyle)
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.scrollList, (item, index2) => {
          return openBlock(), createElementBlock("li", {
            key: index2,
            class: "nut-noticebar__vertical-item",
            style: normalizeStyle({ height: _ctx.pxCheck(_ctx.height), lineHeight: _ctx.pxCheck(_ctx.height) }),
            onClick: ($event) => _ctx.go(item)
          }, toDisplayString(item), 13, _hoisted_6$c);
        }), 128))
      ], 4)),
      createBaseVNode("view", {
        class: "go",
        onClick: _cache[4] || (_cache[4] = ($event) => !_ctx.slots.rightIcon && _ctx.handleClickIcon())
      }, [
        renderSlot(_ctx.$slots, "right-icon", {}, () => [
          _ctx.closeMode ? (openBlock(), createBlock(_component_CircleClose, {
            key: 0,
            color: _ctx.color,
            size: "11px"
          }, null, 8, ["color"])) : createCommentVNode("", true)
        ])
      ])
    ], 4)) : createCommentVNode("", true)
  ]);
}
const index$i = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["render", _sfc_render$q]]);
var __defProp$n = Object.defineProperty;
var __defProps$n = Object.defineProperties;
var __getOwnPropDescs$n = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$n = Object.getOwnPropertySymbols;
var __hasOwnProp$n = Object.prototype.hasOwnProperty;
var __propIsEnum$n = Object.prototype.propertyIsEnumerable;
var __defNormalProp$n = (obj, key, value) => key in obj ? __defProp$n(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$n = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$n.call(b, prop))
      __defNormalProp$n(a2, prop, b[prop]);
  if (__getOwnPropSymbols$n)
    for (var prop of __getOwnPropSymbols$n(b)) {
      if (__propIsEnum$n.call(b, prop))
        __defNormalProp$n(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$n = (a2, b) => __defProps$n(a2, __getOwnPropDescs$n(b));
const _hoisted_1$v = { class: "nut-empty" };
const _hoisted_2$r = ["src"];
const _hoisted_3$n = { class: "nut-empty__description" };
const cN$a = "NutEmpty";
const _sfc_main$B = /* @__PURE__ */ defineComponent(__spreadProps$n(__spreadValues$n({}, {
  name: cN$a
}), {
  __name: "empty",
  props: {
    image: { default: "empty" },
    imageSize: { default: "" },
    description: { default: "" }
  },
  setup(__props) {
    const props = __props;
    const translate = useLocale(cN$a);
    const defaultStatus = {
      empty: "https://static-ftcms.jd.com/p/files/61a9e3183985005b3958672b.png",
      error: "https://ftcms.jd.com/p/files/61a9e33ee7dcdbcc0ce62736.png",
      network: "https://static-ftcms.jd.com/p/files/61a9e31de7dcdbcc0ce62734.png"
    };
    const style = computed(() => {
      if (props.imageSize) {
        return {
          width: pxCheck(props.imageSize),
          height: pxCheck(props.imageSize)
        };
      }
      return {};
    });
    const src = computed(() => /^https?:\/\/|^\/\//.test(props.image) ? props.image : defaultStatus[props.image]);
    const descriptionText = computed(() => props.description || translate("noData"));
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("view", _hoisted_1$v, [
        createBaseVNode("view", {
          class: "nut-empty__box",
          style: normalizeStyle(style.value)
        }, [
          renderSlot(_ctx.$slots, "image", {}, () => [
            src.value ? (openBlock(), createElementBlock("img", {
              key: 0,
              class: "nut-empty__box--img",
              src: src.value
            }, null, 8, _hoisted_2$r)) : createCommentVNode("", true)
          ])
        ], 4),
        renderSlot(_ctx.$slots, "description", {}, () => [
          createBaseVNode("view", _hoisted_3$n, toDisplayString(descriptionText.value), 1)
        ]),
        renderSlot(_ctx.$slots, "default")
      ]);
    };
  }
}));
withInstall(_sfc_main$B);
var __defProp$m = Object.defineProperty;
var __defProps$m = Object.defineProperties;
var __getOwnPropDescs$m = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$m = Object.getOwnPropertySymbols;
var __hasOwnProp$m = Object.prototype.hasOwnProperty;
var __propIsEnum$m = Object.prototype.propertyIsEnumerable;
var __defNormalProp$m = (obj, key, value) => key in obj ? __defProp$m(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$m = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$m.call(b, prop))
      __defNormalProp$m(a2, prop, b[prop]);
  if (__getOwnPropSymbols$m)
    for (var prop of __getOwnPropSymbols$m(b)) {
      if (__propIsEnum$m.call(b, prop))
        __defNormalProp$m(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$m = (a2, b) => __defProps$m(a2, __getOwnPropDescs$m(b));
function throttle(fn, delay) {
  let timer = null;
  let startTime = Date.now();
  return function(...args) {
    const now = Date.now();
    const remaining = delay - (now - startTime);
    if (timer) clearTimeout(timer);
    if (remaining <= 0) {
      fn(...args);
      startTime = Date.now();
    } else {
      timer = setTimeout(fn, remaining);
    }
  };
}
const { create: create$p } = createComponent("video");
const cN$9 = "NutVideo";
const _sfc_main$A = create$p({
  props: {
    source: {
      type: Object,
      default: {}
    },
    options: {
      type: Object,
      default: {
        autoplay: false,
        // 是否自动播放
        volume: 0.5,
        poster: "",
        loop: false,
        controls: true,
        muted: false,
        // 是否静音
        disabled: false,
        // 禁止操作
        playsinline: false,
        // 行内展示
        touchPlay: false,
        preload: ""
      },
      required: true
    },
    model: {
      type: String,
      default: ""
    }
  },
  components: {},
  emits: ["click", "play", "pause", "playend", "time"],
  setup(props, { emit: emit2, expose }) {
    const translate = useLocale(cN$9);
    const state = reactive({
      videoElm: null,
      initial: true,
      // 控制封面的显示
      showToolbox: false,
      // 控制控制器和标题的显示
      // 视频容器元素
      player: {
        $player: null,
        pos: null
      },
      // progress进度条元素
      progressBar: {
        progressElm: null,
        // 进度条DOM对象
        pos: null
      },
      // video控制显示设置
      videoSet: {
        loaded: 0,
        // 缓存长度
        displayTime: "00:00",
        // 进度时间
        totalTime: "00:00",
        // 总时间
        progress: {
          width: 0,
          // 进度条长度
          current: 0
          // 进度条当前位置
        }
      },
      state: {
        controlShow: true,
        vol: 0.5,
        // 音量
        currentTime: 0,
        // 当前时间
        fullScreen: false,
        playing: false,
        // 是否正在播放
        isLoading: false,
        isEnd: false,
        isError: false,
        isMuted: false
      },
      showTouchMask: false
    });
    const root = ref(null);
    const isDisabled = computed(() => {
      return props.options.disabled;
    });
    watch(
      () => props.source,
      (newValue) => {
        if (newValue.src) {
          nextTick(() => {
            state.videoElm.load();
          });
        }
      },
      { immediate: true, deep: true }
    );
    watch(
      () => props.options,
      (newValue) => {
        state.state.isMuted = newValue ? newValue.muted : false;
      },
      { immediate: true }
    );
    const init = () => {
      state.videoElm = root.value;
      if (props.options.autoplay) {
        setTimeout(() => {
          state.videoElm.play();
        }, 200);
      }
      if (props.options.touchPlay) {
        state.showTouchMask = true;
      }
      if (props.options.playsinline) {
        state.videoElm.setAttribute("playsinline", props.options.playsinline);
        state.videoElm.setAttribute("webkit-playsinline", props.options.playsinline);
        state.videoElm.setAttribute("x5-video-player-type", "h5-page");
        state.videoElm.setAttribute("x5-video-player-fullscreen", false);
      }
      volumeHandle();
      if (state.showToolbox) {
        customerInit();
      } else {
        state.videoElm.addEventListener("play", () => {
          state.state.playing = true;
          emit2("play", state.videoElm);
        });
        state.videoElm.addEventListener("pause", () => {
          state.state.playing = false;
          emit2("pause", state.videoElm);
        });
        state.videoElm.addEventListener("ended", playEnded);
        state.videoElm.addEventListener("timeupdate", throttle(getPlayTime, 1e3));
      }
    };
    const customerInit = () => {
      const $player = root.value;
      const $progress = root.value.getElementsByClassName("nut-video-controller__progress-value")[0];
      state.player.$player = $player;
      state.progressBar.progressElm = $progress;
      state.progressBar.pos = $progress.getBoundingClientRect();
      state.videoSet.progress.width = Math.round($progress.getBoundingClientRect().width);
    };
    const play = () => {
      if (props.options.autoplay && props.options.disabled) {
        state.state.playing = true;
        return false;
      }
      state.state.playing = !state.state.playing;
      if (state.videoElm) {
        if (state.state.playing) {
          try {
            setTimeout(() => {
              state.videoElm.play();
            }, 200);
            state.videoElm.addEventListener("progress", () => {
              getLoadTime();
            });
            state.videoElm.addEventListener("timeupdate", throttle(getPlayTime, 1e3));
            state.videoElm.addEventListener("ended", playEnded);
            emit2("play", state.videoElm);
          } catch (e) {
            handleError2();
          }
        } else {
          state.videoElm.pause();
          emit2("pause", state.videoElm);
        }
      }
    };
    const timeFormat = (t) => {
      var h2 = Math.floor(t / 3600);
      if (+h2 < 10) {
        h2 = "0" + h2;
      }
      var m2 = Math.floor(t % 3600 / 60);
      if (+m2 < 10) {
        m2 = "0" + m2;
      }
      var s = Math.round(t % 3600 % 60);
      if (+s < 10) {
        s = "0" + s;
      }
      var str = "";
      if (h2 != 0) {
        str = h2 + ":" + m2 + ":" + s;
      } else {
        str = m2 + ":" + s;
      }
      return str;
    };
    const getLoadTime = () => {
      if (state.videoSet.loaded)
        state.videoSet.loaded = state.videoElm.buffered.end(0) / state.videoElm.duration * 100;
    };
    const getPlayTime = () => {
      const percent = state.videoElm.currentTime / state.videoElm.duration;
      state.videoSet.progress.current = Math.round(state.videoSet.progress.width * percent);
      state.videoSet.totalTime = timeFormat(state.videoElm.duration);
      state.videoSet.displayTime = timeFormat(state.videoElm.currentTime);
      emit2("time", state.videoSet.displayTime, state.videoSet.totalTime);
    };
    const playEnded = () => {
      state.state.playing = false;
      state.state.isEnd = true;
      state.videoSet.displayTime = "00:00";
      state.videoSet.progress.current = 0;
      state.videoElm.currentTime = 0;
      emit2("playend", state.videoElm);
    };
    const handleError2 = () => {
      state.state.isError = true;
    };
    const volumeHandle = () => {
      state.state.vol = props.options.volume;
    };
    const handleMuted = () => {
      state.state.isMuted = !state.state.isMuted;
      state.videoElm.muted = state.state.isMuted;
    };
    const touchSlidSrart = () => {
    };
    const touchSlidMove = (e) => {
      let currentX = e.targetTouches[0].pageX;
      let offsetX = currentX - state.progressBar.pos.left;
      if (offsetX <= 0) {
        offsetX = 0;
      }
      if (offsetX >= state.videoSet.progress.width) {
        offsetX = state.videoSet.progress.width;
      }
      state.videoSet.progress.current = offsetX;
      let percent = state.videoSet.progress.current / state.videoSet.progress.width;
      state.videoElm.duration && setPlayTime(percent, state.videoElm.duration);
    };
    const touchSlidEnd = (e) => {
      let currentX = e.changedTouches[0].pageX;
      let offsetX = currentX - state.progressBar.pos.left;
      state.videoSet.progress.current = offsetX;
      let percent = offsetX / state.videoSet.progress.width;
      state.videoElm.duration && setPlayTime(percent, state.videoElm.duration);
    };
    const setPlayTime = (percent, totalTime) => {
      state.videoElm.currentTime = Math.floor(percent * totalTime);
    };
    const retry = () => {
      state.state.isError = false;
      init();
    };
    const fullScreen = () => {
      if (!state.state.fullScreen) {
        state.state.fullScreen = true;
        state.videoElm.webkitRequestFullScreen();
      } else {
        state.state.fullScreen = false;
        document.webkitCancelFullScreen();
      }
    };
    const pause = () => {
      state.state.playing = false;
      state.videoElm.pause();
      emit2("pause", state.videoElm);
    };
    const stop = () => {
      playEnded();
      state.videoElm.pause();
    };
    const muted = () => {
      state.state.isMuted = true;
      state.videoElm.muted = true;
    };
    const unmuted = () => {
      state.state.isMuted = false;
      state.videoElm.muted = false;
    };
    expose({
      play,
      pause,
      stop,
      muted,
      unmuted
    });
    onMounted(() => {
      init();
    });
    return __spreadProps$m(__spreadValues$m(__spreadValues$m({
      root
    }, toRefs(props)), toRefs(state)), {
      handleError: handleError2,
      isDisabled,
      play,
      handleMuted,
      touchSlidSrart,
      touchSlidMove,
      touchSlidEnd,
      retry,
      fullScreen,
      translate
    });
  }
});
const _hoisted_1$u = {
  ref: "videocon",
  class: "nut-video"
};
const _hoisted_2$q = ["muted", "autoplay", "loop", "poster", "controls", "preload"];
const _hoisted_3$m = ["src", "type"];
const _hoisted_4$j = { class: "nut-video-controller__now" };
const _hoisted_5$c = { class: "nut-video-controller__progress" };
const _hoisted_6$b = {
  ref: "progressBar",
  class: "nut-video-controller__progress-value"
};
const _hoisted_7$a = /* @__PURE__ */ createBaseVNode("div", { class: "nut-video-controller__ball-move" }, null, -1);
const _hoisted_8$7 = [
  _hoisted_7$a
];
const _hoisted_9$4 = {
  ref: "playedBar",
  class: "nut-video-controller__played"
};
const _hoisted_10$3 = { class: "nut-video-controller__total" };
const _hoisted_11$2 = { class: "nut-video-error" };
const _hoisted_12$2 = { class: "nut-video-error-tip" };
function _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$u, [
    createBaseVNode("video", {
      ref: "root",
      class: "nut-video-player",
      muted: _ctx.options.muted,
      autoplay: _ctx.options.autoplay,
      loop: _ctx.options.loop,
      poster: _ctx.options.poster,
      controls: _ctx.options.controls,
      preload: _ctx.options.preload,
      onError: _cache[0] || (_cache[0] = (...args) => _ctx.handleError && _ctx.handleError(...args))
    }, [
      createBaseVNode("source", {
        src: _ctx.source.src,
        type: _ctx.source.type
      }, null, 8, _hoisted_3$m)
    ], 40, _hoisted_2$q),
    _ctx.showToolbox && !_ctx.isDisabled ? (openBlock(), createElementBlock("div", {
      key: 0,
      ref: "touchMask",
      class: "nut-video-mask",
      onClick: _cache[1] || (_cache[1] = (...args) => _ctx.play && _ctx.play(...args))
    }, null, 512)) : createCommentVNode("", true),
    _ctx.showToolbox && !_ctx.isDisabled ? withDirectives((openBlock(), createElementBlock("div", {
      key: 1,
      ref: "palyBtn",
      class: "nut-video-play-btn",
      onClick: _cache[2] || (_cache[2] = (...args) => _ctx.play && _ctx.play(...args))
    }, null, 512)), [
      [vShow, !_ctx.state.playing]
    ]) : createCommentVNode("", true),
    withDirectives(createBaseVNode("div", {
      class: normalizeClass(["nut-video-controller", { "nut-video-controller--show": !_ctx.state.playing, "nut-video-controller--hide": _ctx.state.playing }])
    }, [
      createBaseVNode("div", {
        class: "nut-video-controller__playbtn",
        onClick: _cache[3] || (_cache[3] = (...args) => _ctx.play && _ctx.play(...args))
      }),
      createBaseVNode("div", _hoisted_4$j, toDisplayString(_ctx.videoSet.displayTime), 1),
      createBaseVNode("div", _hoisted_5$c, [
        createBaseVNode("div", _hoisted_6$b, [
          createBaseVNode("div", {
            class: "buffered",
            style: normalizeStyle({ width: `${_ctx.videoSet.loaded}%` })
          }, null, 4),
          createBaseVNode("div", {
            class: "nut-video-controller__ball",
            style: normalizeStyle({
              transform: `translate3d(${_ctx.videoSet.progress.current}px, -50%, 0)`
            }),
            onTouchmove: _cache[4] || (_cache[4] = withModifiers(($event) => _ctx.touchSlidMove($event), ["stop", "prevent"])),
            onTouchstart: _cache[5] || (_cache[5] = withModifiers(($event) => _ctx.touchSlidSrart(), ["stop"])),
            onTouchend: _cache[6] || (_cache[6] = withModifiers(($event) => _ctx.touchSlidEnd($event), ["stop"]))
          }, _hoisted_8$7, 36),
          createBaseVNode("div", _hoisted_9$4, null, 512)
        ], 512)
      ]),
      createBaseVNode("div", _hoisted_10$3, toDisplayString(_ctx.videoSet.totalTime), 1),
      createBaseVNode("div", {
        class: normalizeClass(["nut-video-controller__volume", { muted: _ctx.state.isMuted }]),
        onClick: _cache[7] || (_cache[7] = (...args) => _ctx.handleMuted && _ctx.handleMuted(...args))
      }, null, 2),
      createBaseVNode("div", {
        class: "nut-video-controller__full",
        onClick: _cache[8] || (_cache[8] = (...args) => _ctx.fullScreen && _ctx.fullScreen(...args))
      })
    ], 2), [
      [vShow, _ctx.showToolbox && !_ctx.isDisabled]
    ]),
    withDirectives(createBaseVNode("div", _hoisted_11$2, [
      createBaseVNode("p", _hoisted_12$2, toDisplayString(_ctx.translate("errorTip")), 1),
      createBaseVNode("p", {
        class: "nut-video-error-retry",
        onClick: _cache[9] || (_cache[9] = (...args) => _ctx.retry && _ctx.retry(...args))
      }, toDisplayString(_ctx.translate("clickRetry")), 1)
    ], 512), [
      [vShow, _ctx.state.isError]
    ])
  ], 512);
}
const NutVideo = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["render", _sfc_render$p]]);
const STEPS_KEY = Symbol("nut-steps");
var __defProp$l = Object.defineProperty;
var __defProps$l = Object.defineProperties;
var __getOwnPropDescs$l = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$l = Object.getOwnPropertySymbols;
var __hasOwnProp$l = Object.prototype.hasOwnProperty;
var __propIsEnum$l = Object.prototype.propertyIsEnumerable;
var __defNormalProp$l = (obj, key, value) => key in obj ? __defProp$l(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$l = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$l.call(b, prop))
      __defNormalProp$l(a2, prop, b[prop]);
  if (__getOwnPropSymbols$l)
    for (var prop of __getOwnPropSymbols$l(b)) {
      if (__propIsEnum$l.call(b, prop))
        __defNormalProp$l(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$l = (a2, b) => __defProps$l(a2, __getOwnPropDescs$l(b));
const _sfc_main$z = /* @__PURE__ */ defineComponent(__spreadProps$l(__spreadValues$l({}, {
  name: "NutSteps"
}), {
  __name: "steps",
  props: {
    direction: { default: "horizontal" },
    current: { default: "0" },
    progressDot: { type: Boolean, default: false }
  },
  emits: ["clickStep"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const classes = computed(() => {
      const prefixCls2 = "nut-steps";
      return {
        [prefixCls2]: true,
        [`${prefixCls2}-${props.direction}`]: true,
        [`${prefixCls2}-dot`]: !!props.progressDot
      };
    });
    const { linkChildren } = useChildren(STEPS_KEY);
    const onEmit = (index2) => {
      emit2("clickStep", index2);
    };
    linkChildren({ props, onEmit });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("view", {
        class: normalizeClass(classes.value)
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 2);
    };
  }
}));
withInstall(_sfc_main$z);
var __defProp$k = Object.defineProperty;
var __defProps$k = Object.defineProperties;
var __getOwnPropDescs$k = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$k = Object.getOwnPropertySymbols;
var __hasOwnProp$k = Object.prototype.hasOwnProperty;
var __propIsEnum$k = Object.prototype.propertyIsEnumerable;
var __defNormalProp$k = (obj, key, value) => key in obj ? __defProp$k(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$k = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$k.call(b, prop))
      __defNormalProp$k(a2, prop, b[prop]);
  if (__getOwnPropSymbols$k)
    for (var prop of __getOwnPropSymbols$k(b)) {
      if (__propIsEnum$k.call(b, prop))
        __defNormalProp$k(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$k = (a2, b) => __defProps$k(a2, __getOwnPropDescs$k(b));
const _hoisted_1$t = { class: "nut-step-head" };
const _hoisted_2$p = /* @__PURE__ */ createBaseVNode("view", { class: "nut-step-line" }, null, -1);
const _hoisted_3$l = { class: "nut-step-icon-inner" };
const _hoisted_4$i = {
  key: 0,
  class: "nut-step-inner"
};
const _hoisted_5$b = { class: "nut-step-main" };
const _hoisted_6$a = { class: "nut-step-title" };
const _hoisted_7$9 = {
  key: 0,
  class: "nut-step-content"
};
const _hoisted_8$6 = ["innerHTML"];
const _sfc_main$y = /* @__PURE__ */ defineComponent(__spreadProps$k(__spreadValues$k({}, {
  name: "NutStep"
}), {
  __name: "step",
  props: {
    title: { default: "" },
    content: { default: "" }
  },
  setup(__props) {
    const { index: index2, parent } = useParent(STEPS_KEY);
    const status = computed(() => {
      const activeIndex = index2.value + 1;
      if (activeIndex < +parent.props.current) return "finish";
      return activeIndex === +parent.props.current ? "process" : "wait";
    });
    const dot = computed(() => parent.props.progressDot);
    const classes = computed(() => {
      const prefixCls2 = "nut-step";
      return {
        [prefixCls2]: true,
        [`${prefixCls2}-${status.value}`]: true
      };
    });
    const handleClickStep = () => {
      parent.onEmit(index2.value + 1);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("view", {
        class: normalizeClass(classes.value),
        onClick: handleClickStep
      }, [
        createBaseVNode("view", _hoisted_1$t, [
          _hoisted_2$p,
          createBaseVNode("view", {
            class: normalizeClass(["nut-step-icon", [!dot.value ? "is-icon" : ""]])
          }, [
            createBaseVNode("view", _hoisted_3$l, [
              renderSlot(_ctx.$slots, "icon", {}, () => [
                !dot.value ? (openBlock(), createElementBlock("view", _hoisted_4$i, toDisplayString(unref(index2) + 1), 1)) : createCommentVNode("", true)
              ])
            ])
          ], 2)
        ]),
        createBaseVNode("view", _hoisted_5$b, [
          createBaseVNode("view", _hoisted_6$a, [
            renderSlot(_ctx.$slots, "title", {}, () => [
              createBaseVNode("span", null, toDisplayString(_ctx.title), 1)
            ])
          ]),
          _ctx.content || _ctx.$slots.content ? (openBlock(), createElementBlock("view", _hoisted_7$9, [
            renderSlot(_ctx.$slots, "content", {}, () => [
              createBaseVNode("span", { innerHTML: _ctx.content }, null, 8, _hoisted_8$6)
            ])
          ])) : createCommentVNode("", true)
        ])
      ], 2);
    };
  }
}));
withInstall(_sfc_main$y);
const SWIPER_KEY = Symbol("nut-swiper");
const { create: create$o, componentName: componentName$1 } = createComponent("swiper");
const _sfc_main$x = create$o({
  props: {
    width: {
      type: [Number, String]
    },
    height: {
      type: [Number, String]
    },
    direction: {
      type: String,
      default: "horizontal"
      // horizontal and vertical
    },
    paginationVisible: {
      type: Boolean,
      default: false
    },
    paginationColor: {
      type: String,
      default: "#fff"
    },
    loop: {
      type: Boolean,
      default: true
    },
    duration: {
      type: [Number, String],
      default: 500
    },
    autoPlay: {
      type: [Number, String],
      default: 0
    },
    initPage: {
      type: [Number, String],
      default: 0
    },
    touchable: {
      type: Boolean,
      default: true
    },
    isPreventDefault: {
      type: Boolean,
      default: true
    },
    isStopPropagation: {
      type: Boolean,
      default: true
    },
    paginationUnselectedColor: {
      type: String,
      default: "#ddd"
    }
  },
  emits: ["change"],
  setup(props, { emit: emit2, slots, expose }) {
    const container = ref();
    const state = reactive({
      active: 0,
      num: 0,
      rect: null,
      width: 0,
      height: 0,
      moving: false,
      offset: 0,
      touchTime: 0,
      autoplayTimer: null,
      children: [],
      childrenVNode: [],
      style: {}
    });
    const touch = useTouch();
    const isVertical = computed(() => props.direction === "vertical");
    const classesInner = computed(() => {
      const prefixCls2 = componentName$1;
      return {
        [`${prefixCls2}-inner`]: true,
        [`${prefixCls2}-vertical`]: isVertical.value
      };
    });
    const classesPagination = computed(() => {
      const prefixCls2 = componentName$1;
      return {
        [`${prefixCls2}-pagination`]: true,
        [`${prefixCls2}-pagination-vertical`]: isVertical.value
      };
    });
    const delTa = computed(() => {
      return isVertical.value ? touch.deltaY.value : touch.deltaX.value;
    });
    const isCorrectDirection = computed(() => {
      return touch.direction.value === props.direction;
    });
    const childCount = computed(() => state.children.length);
    const size = computed(() => state[isVertical.value ? "height" : "width"]);
    const trackSize = computed(() => childCount.value * size.value);
    const minOffset = computed(() => {
      if (state.rect) {
        const base = isVertical.value ? state.rect.height : state.rect.width;
        return base - size.value * childCount.value;
      }
      return 0;
    });
    const activePagination = computed(() => (state.active + childCount.value) % childCount.value);
    const getStyle = () => {
      let offset = 0;
      offset = state.offset;
      state.style = {
        transitionDuration: `${state.moving ? 0 : props.duration}ms`,
        transform: `translate${isVertical.value ? "Y" : "X"}(${offset}px)`,
        [isVertical.value ? "height" : "width"]: `${size.value * childCount.value}px`,
        [isVertical.value ? "width" : "height"]: `${isVertical.value ? state.width : state.height}px`
      };
    };
    const relation = (child) => {
      var _a;
      let children = [];
      const childrenVNodeLen = state.childrenVNode.length;
      let slot = (_a = slots == null ? void 0 : slots.default) == null ? void 0 : _a.call(slots);
      slot = slot.filter((item) => item.children && Array.isArray(item.children));
      slot.forEach((item) => {
        children = children.concat(item.children);
      });
      if (!childrenVNodeLen) {
        state.childrenVNode = children.slice();
        child.proxy && state.children.push(child.proxy);
      } else {
        if (childrenVNodeLen > children.length) {
          state.children = state.children.filter((item) => child.proxy !== item);
        } else if (childrenVNodeLen < children.length) {
          for (let i2 = 0; i2 < childrenVNodeLen; i2++) {
            if (children[i2].key !== state.childrenVNode[i2].key) {
              child.proxy && state.children.splice(i2, 0, child.proxy);
              child.vnode && state.childrenVNode.splice(i2, 0, child.vnode);
              break;
            }
          }
          if (childrenVNodeLen !== children.length) {
            child.proxy && state.children.push(child.proxy);
            child.vnode && state.childrenVNode.push(child.vnode);
          }
        } else {
          state.childrenVNode = children.slice();
          child.proxy && state.children.push(child.proxy);
        }
      }
    };
    const getOffset = (active, offset = 0) => {
      let currentPosition = active * size.value;
      if (!props.loop) {
        currentPosition = Math.min(currentPosition, -minOffset.value);
      }
      let targetOffset = offset - currentPosition;
      if (!props.loop) {
        targetOffset = clamp(targetOffset, minOffset.value, 0);
      }
      return targetOffset;
    };
    const getActive = (pace) => {
      const { active } = state;
      if (pace) {
        if (props.loop) {
          return clamp(active + pace, -1, childCount.value);
        }
        return clamp(active + pace, 0, childCount.value - 1);
      }
      return active;
    };
    const move = ({ pace = 0, offset = 0, isEmit = false }) => {
      if (childCount.value <= 1) return;
      const { active } = state;
      const targetActive = getActive(pace);
      const targetOffset = getOffset(targetActive, offset);
      if (props.loop) {
        if (state.children[0] && targetOffset !== minOffset.value) {
          const rightBound = targetOffset < minOffset.value;
          state.children[0].setOffset(rightBound ? trackSize.value : 0);
        }
        if (state.children[childCount.value - 1] && targetOffset !== 0) {
          const leftBound = targetOffset > 0;
          state.children[childCount.value - 1].setOffset(leftBound ? -trackSize.value : 0);
        }
      }
      state.active = targetActive;
      state.offset = targetOffset;
      if (isEmit && active !== state.active) {
        emit2("change", activePagination.value);
      }
      getStyle();
    };
    const resettPosition = () => {
      state.moving = true;
      if (state.active <= -1) {
        move({ pace: childCount.value });
      }
      if (state.active >= childCount.value) {
        move({ pace: -childCount.value });
      }
    };
    const stopAutoPlay = () => {
      if (state.autoplayTimer) {
        clearTimeout(state.autoplayTimer);
      }
    };
    const jump = (pace) => {
      resettPosition();
      touch.reset();
      requestAniFrame$1(() => {
        requestAniFrame$1(() => {
          state.moving = false;
          move({
            pace,
            isEmit: true
          });
        });
      });
    };
    const prev = () => {
      jump(-1);
    };
    const next = () => {
      jump(1);
    };
    const to = (index2) => {
      resettPosition();
      touch.reset();
      requestAniFrame$1(() => {
        state.moving = false;
        let targetIndex;
        if (props.loop && childCount.value === index2) {
          targetIndex = state.active === 0 ? 0 : index2;
        } else {
          targetIndex = index2 % childCount.value;
        }
        move({
          pace: targetIndex - state.active,
          isEmit: true
        });
      });
    };
    const autoplay = () => {
      if (+props.autoPlay <= 0 || childCount.value <= 1) return;
      stopAutoPlay();
      state.autoplayTimer = setTimeout(() => {
        next();
        autoplay();
      }, Number(props.autoPlay));
    };
    const init = (active = +props.initPage) => {
      stopAutoPlay();
      state.rect = container.value.getBoundingClientRect();
      active = Math.min(childCount.value - 1, active);
      state.width = props.width ? +props.width : state.rect.width;
      state.height = props.height ? +props.height : state.rect.height;
      state.active = active;
      state.offset = getOffset(state.active);
      state.moving = true;
      getStyle();
      autoplay();
    };
    const onTouchStart = (e) => {
      if (props.isPreventDefault) e.preventDefault();
      if (props.isStopPropagation) e.stopPropagation();
      if (!props.touchable) return;
      touch.start(e);
      state.touchTime = Date.now();
      stopAutoPlay();
      resettPosition();
    };
    const onTouchMove = (e) => {
      if (props.touchable && state.moving) {
        touch.move(e);
        if (isCorrectDirection.value) {
          move({
            offset: delTa.value
          });
        }
      }
    };
    const onTouchEnd = () => {
      if (!props.touchable || !state.moving) return;
      const speed = delTa.value / (Date.now() - state.touchTime);
      const isShouldMove = Math.abs(speed) > 0.3 || Math.abs(delTa.value) > +(size.value / 2).toFixed(2);
      if (isShouldMove && isCorrectDirection.value) {
        let pace = 0;
        const offset = isVertical.value ? touch.offsetY.value : touch.offsetX.value;
        if (props.loop) {
          pace = offset > 0 ? delTa.value > 0 ? -1 : 1 : 0;
        } else {
          pace = -Math[delTa.value > 0 ? "ceil" : "floor"](delTa.value / size.value);
        }
        move({
          pace,
          isEmit: true
        });
      } else if (delTa.value) {
        move({ pace: 0 });
      }
      state.moving = false;
      getStyle();
      autoplay();
    };
    provide(SWIPER_KEY, {
      props,
      size,
      relation
    });
    expose({
      prev,
      next,
      to
    });
    onDeactivated(() => {
      stopAutoPlay();
    });
    onBeforeUnmount(() => {
      stopAutoPlay();
    });
    watch(
      () => props.initPage,
      (val) => {
        nextTick(() => {
          init(Number(val));
        });
      }
    );
    watch(
      () => props.height,
      () => {
        nextTick(() => {
          init();
        });
      }
    );
    watch(
      () => state.children.length,
      () => {
        nextTick(() => {
          init();
        });
      }
    );
    watch(
      () => props.autoPlay,
      (val) => {
        +val > 0 ? autoplay() : stopAutoPlay();
      }
    );
    return {
      state,
      classesInner,
      classesPagination,
      container,
      activePagination,
      onTouchStart,
      onTouchMove,
      onTouchEnd
    };
  }
});
function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    ref: "container",
    class: "nut-swiper",
    onTouchstart: _cache[0] || (_cache[0] = (...args) => _ctx.onTouchStart && _ctx.onTouchStart(...args)),
    onTouchmove: _cache[1] || (_cache[1] = (...args) => _ctx.onTouchMove && _ctx.onTouchMove(...args)),
    onTouchend: _cache[2] || (_cache[2] = (...args) => _ctx.onTouchEnd && _ctx.onTouchEnd(...args)),
    onTouchcancel: _cache[3] || (_cache[3] = (...args) => _ctx.onTouchEnd && _ctx.onTouchEnd(...args))
  }, [
    createBaseVNode("view", {
      class: normalizeClass(_ctx.classesInner),
      style: normalizeStyle(_ctx.state.style)
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 6),
    renderSlot(_ctx.$slots, "page"),
    _ctx.paginationVisible && !_ctx.$slots.page ? (openBlock(), createElementBlock("view", {
      key: 0,
      class: normalizeClass(_ctx.classesPagination)
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.state.children.length, (item, index2) => {
        return openBlock(), createElementBlock("i", {
          key: index2,
          style: normalizeStyle({
            backgroundColor: _ctx.activePagination === index2 ? _ctx.paginationColor : _ctx.paginationUnselectedColor
          }),
          class: normalizeClass({ active: _ctx.activePagination === index2 })
        }, null, 6);
      }), 128))
    ], 2)) : createCommentVNode("", true)
  ], 544);
}
const NutSwiper = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["render", _sfc_render$o]]);
function useExpose(apis) {
  const instance = getCurrentInstance();
  if (instance) {
    Object.assign(instance.proxy, apis);
  }
}
const { create: create$n } = createComponent("swiper-item");
const _sfc_main$w = create$n({
  setup() {
    const parent = inject(SWIPER_KEY);
    parent["relation"](getCurrentInstance());
    const state = reactive({
      offset: 0
    });
    const style = computed(() => {
      const style2 = {};
      const direction = parent == null ? void 0 : parent.props.direction;
      if (parent == null ? void 0 : parent.size.value) {
        style2[direction === "horizontal" ? "width" : "height"] = `${parent == null ? void 0 : parent.size.value}px`;
      }
      if (state.offset) {
        style2["transform"] = `translate${direction === "horizontal" ? "X" : "Y"}(${state.offset}px)`;
      }
      return style2;
    });
    const setOffset = (offset) => {
      state.offset = offset;
    };
    onUnmounted(() => {
      parent["relation"](getCurrentInstance(), "unmount");
    });
    useExpose({ setOffset });
    return {
      style
    };
  }
});
function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    class: "nut-swiper-item",
    style: normalizeStyle(_ctx.style)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 4);
}
const NutSwiperItem = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["render", _sfc_render$n]]);
var __defProp$j = Object.defineProperty;
var __defProps$j = Object.defineProperties;
var __getOwnPropDescs$j = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$j = Object.getOwnPropertySymbols;
var __hasOwnProp$j = Object.prototype.hasOwnProperty;
var __propIsEnum$j = Object.prototype.propertyIsEnumerable;
var __defNormalProp$j = (obj, key, value) => key in obj ? __defProp$j(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$j = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$j.call(b, prop))
      __defNormalProp$j(a2, prop, b[prop]);
  if (__getOwnPropSymbols$j)
    for (var prop of __getOwnPropSymbols$j(b)) {
      if (__propIsEnum$j.call(b, prop))
        __defNormalProp$j(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$j = (a2, b) => __defProps$j(a2, __getOwnPropDescs$j(b));
const _hoisted_1$s = ["innerHTML"];
const _hoisted_2$o = ["innerHTML"];
const prefix = "nut-price";
const _sfc_main$v = /* @__PURE__ */ defineComponent(__spreadProps$j(__spreadValues$j({}, {
  name: "NutPrice"
}), {
  __name: "price",
  props: {
    price: { default: 0 },
    needSymbol: { type: Boolean, default: true },
    symbol: { default: "&yen;" },
    decimalDigits: { default: 2 },
    thousands: { type: Boolean, default: false },
    position: { default: "before" },
    size: { default: "normal" },
    strikeThrough: { type: Boolean, default: false }
  },
  setup(__props) {
    const props = __props;
    const classes = computed(() => {
      return {
        [prefix]: true,
        [`${prefix}--strike`]: props.strikeThrough
      };
    });
    const showSymbol = computed(() => {
      const symbol = props.needSymbol ? props.symbol : "";
      return symbol;
    });
    const checkPoint = (price) => {
      return String(price).indexOf(".") > 0;
    };
    const formatThousands = (num) => {
      if (Number(num) == 0) {
        num = 0;
      }
      if (checkPoint(num)) {
        num = Number(num).toFixed(props.decimalDigits);
        num = typeof num.split(".") === "string" ? num.split(".") : num.split(".")[0];
      } else {
        num = num.toString();
      }
      if (props.thousands) {
        return (num || 0).toString().replace(/(\d)(?=(?:\d{3})+$)/g, "$1,");
      } else {
        return num;
      }
    };
    const formatDecimal = (decimalNum) => {
      if (Number(decimalNum) == 0) {
        decimalNum = 0;
      }
      if (checkPoint(decimalNum)) {
        decimalNum = Number(decimalNum).toFixed(props.decimalDigits);
        decimalNum = typeof decimalNum.split(".") === "string" ? 0 : decimalNum.split(".")[1] ? decimalNum.split(".")[1] : 0;
      } else {
        decimalNum = 0;
      }
      const result = "0." + decimalNum;
      const resultFixed = Number(result).toFixed(props.decimalDigits);
      return String(resultFixed).substring(2, resultFixed.length);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("view", {
        class: normalizeClass(classes.value)
      }, [
        _ctx.needSymbol && _ctx.position === "before" ? (openBlock(), createElementBlock("view", {
          key: 0,
          class: normalizeClass(["nut-price--symbol", `nut-price--symbol-${_ctx.size}`]),
          innerHTML: showSymbol.value
        }, null, 10, _hoisted_1$s)) : createCommentVNode("", true),
        createBaseVNode("view", {
          class: normalizeClass(`nut-price--${_ctx.size}`)
        }, toDisplayString(formatThousands(_ctx.price)), 3),
        _ctx.decimalDigits != 0 ? (openBlock(), createElementBlock("view", {
          key: 1,
          class: normalizeClass(`nut-price--decimal-${_ctx.size}`)
        }, ".", 2)) : createCommentVNode("", true),
        createBaseVNode("view", {
          class: normalizeClass(`nut-price--decimal-${_ctx.size}`)
        }, toDisplayString(formatDecimal(_ctx.price)), 3),
        _ctx.needSymbol && _ctx.position === "after" ? (openBlock(), createElementBlock("view", {
          key: 2,
          class: normalizeClass(["nut-price--symbol", `nut-price--symbol-${_ctx.size}`]),
          innerHTML: showSymbol.value
        }, null, 10, _hoisted_2$o)) : createCommentVNode("", true)
      ], 2);
    };
  }
}));
withInstall(_sfc_main$v);
var __defProp$i = Object.defineProperty;
var __defProps$i = Object.defineProperties;
var __getOwnPropDescs$i = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$i = Object.getOwnPropertySymbols;
var __hasOwnProp$i = Object.prototype.hasOwnProperty;
var __propIsEnum$i = Object.prototype.propertyIsEnumerable;
var __pow$1 = Math.pow;
var __defNormalProp$i = (obj, key, value) => key in obj ? __defProp$i(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$i = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$i.call(b, prop))
      __defNormalProp$i(a2, prop, b[prop]);
  if (__getOwnPropSymbols$i)
    for (var prop of __getOwnPropSymbols$i(b)) {
      if (__propIsEnum$i.call(b, prop))
        __defNormalProp$i(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$i = (a2, b) => __defProps$i(a2, __getOwnPropDescs$i(b));
const baseProps = {
  show: { type: Boolean, default: false },
  initNo: { type: Number, default: 0 },
  showIndex: { type: Boolean, default: true },
  minZoom: { type: Number, default: 1 / 3 },
  maxZoom: { type: Number, default: 3 }
};
const { create: create$1$3 } = createComponent("image-preview-item");
const _sfc_main$1$4 = create$1$3({
  props: __spreadProps$i(__spreadValues$i({}, baseProps), {
    image: {
      type: Object,
      default: () => ({})
    },
    video: {
      type: Object,
      default: () => ({})
    },
    rootWidth: {
      type: Number,
      default: 0
    },
    rootHeight: {
      type: Number,
      default: 0
    },
    contentClose: {
      type: Boolean,
      default: true
    }
  }),
  emits: ["close", "scale"],
  components: {
    NutVideo,
    NutSwiperItem
  },
  setup(props, { emit: emit2 }) {
    const state = reactive({
      scale: 1,
      moveX: 0,
      moveY: 0,
      moving: false,
      zooming: false,
      imageRatio: 0,
      displayWidth: 0,
      displayHeight: 0
    });
    const touch = useTouch();
    const vertical = computed(() => {
      const { rootWidth, rootHeight } = props;
      const rootRatio = rootHeight / rootWidth;
      return state.imageRatio > rootRatio;
    });
    const imageStyle = computed(() => {
      const images = props.image;
      if (images && images.src) {
        const { scale, moveX, moveY, moving, zooming } = state;
        const style = {
          transitionDuration: zooming || moving ? "0s" : ".3s"
        };
        if (scale !== 1) {
          const offsetX = moveX / scale;
          const offsetY = moveY / scale;
          style.transform = `scale(${scale}, ${scale}) translate(${offsetX}px, ${offsetY}px)`;
        }
        return style;
      }
      return {};
    });
    const maxMoveX = computed(() => {
      if (state.imageRatio) {
        const { rootWidth, rootHeight } = props;
        const displayWidth = vertical.value ? rootHeight / state.imageRatio : rootWidth;
        return Math.max(0, (state.scale * displayWidth - rootWidth) / 2);
      }
      return 0;
    });
    const maxMoveY = computed(() => {
      if (state.imageRatio) {
        const { rootWidth, rootHeight } = props;
        const displayHeight = vertical.value ? rootHeight : rootWidth * state.imageRatio;
        return Math.max(0, (state.scale * displayHeight - rootHeight) / 2);
      }
      return 0;
    });
    const imageLoad = (event) => {
      const { naturalWidth, naturalHeight } = event.target;
      state.imageRatio = naturalHeight / naturalWidth;
    };
    const resetScale = () => {
      setScale(1);
      state.moveX = 0;
      state.moveY = 0;
    };
    const setScale = (scale) => {
      scale = clamp(scale, +props.minZoom, +props.maxZoom + 1);
      if (scale !== state.scale) {
        state.scale = scale;
        emit2("scale", {
          scale,
          index: props.initNo
        });
      }
    };
    const toggleScale = () => {
      const scale = state.scale > 1 ? 1 : 2;
      setScale(scale);
      state.moveX = 0;
      state.moveY = 0;
    };
    const getDistance = (touches) => Math.sqrt(__pow$1(touches[0].clientX - touches[1].clientX, 2) + __pow$1(touches[0].clientY - touches[1].clientY, 2));
    let startMoveX;
    let startMoveY;
    let startScale;
    let startDistance;
    let doubleTapTimer;
    let touchStartTime;
    let fingerNum;
    const onTouchStart = (event) => {
      const { touches } = event;
      const { offsetX } = touch;
      touch.start(event);
      fingerNum = touches.length;
      startMoveX = state.moveX;
      startMoveY = state.moveY;
      touchStartTime = Date.now();
      state.moving = fingerNum === 1 && state.scale !== 1;
      state.zooming = fingerNum === 2 && !offsetX.value;
      if (state.zooming) {
        startScale = state.scale;
        startDistance = getDistance(event.touches);
      }
    };
    const onTouchMove = (event) => {
      const { touches } = event;
      touch.move(event);
      if (state.moving || state.zooming) {
        preventDefault(event, true);
      }
      if (state.moving) {
        const { deltaX, deltaY } = touch;
        const moveX = deltaX.value + startMoveX;
        const moveY = deltaY.value + startMoveY;
        state.moveX = clamp(moveX, -maxMoveX.value, maxMoveX.value);
        state.moveY = clamp(moveY, -maxMoveY.value, maxMoveY.value);
      }
      if (state.zooming && touches.length === 2) {
        const distance = getDistance(touches);
        const scale = startScale * distance / startDistance;
        setScale(scale);
      }
    };
    const checkTap = () => {
      if (fingerNum == 1 && props.video && props.video.source) {
        return;
      }
      if (fingerNum > 1) {
        return;
      }
      const { offsetX, offsetY } = touch;
      const deltaTime = Date.now() - touchStartTime;
      const TAP_TIME = 250;
      const TAP_OFFSET = 5;
      if (offsetX.value < TAP_OFFSET && offsetY.value < TAP_OFFSET && deltaTime < TAP_TIME) {
        if (doubleTapTimer) {
          clearTimeout(doubleTapTimer);
          doubleTapTimer = null;
          toggleScale();
        } else {
          doubleTapTimer = setTimeout(() => {
            if (props.contentClose) {
              emit2("close");
            }
            doubleTapTimer = null;
          }, TAP_TIME);
        }
      }
    };
    const onTouchEnd = (event) => {
      let stopPropagation = false;
      if (state.moving || state.zooming) {
        stopPropagation = true;
        if (state.moving && startMoveX === state.moveX && startMoveY === state.moveY) {
          stopPropagation = false;
        }
        if (!event.touches.length) {
          if (state.zooming) {
            state.moveX = clamp(state.moveX, -maxMoveX.value, maxMoveX.value);
            state.moveY = clamp(state.moveY, -maxMoveY.value, maxMoveY.value);
            state.zooming = false;
          }
          state.moving = false;
          startMoveX = 0;
          startMoveY = 0;
          startScale = 1;
          if (state.scale < 1) {
            resetScale();
          }
          if (state.scale > props.maxZoom) {
            state.scale = +props.maxZoom;
          }
        }
      }
      preventDefault(event, stopPropagation);
      checkTap();
      touch.reset();
    };
    const closeSwiper = () => {
      emit2("close");
    };
    watch(() => props.initNo, resetScale);
    watch(
      () => props.show,
      (value) => {
        if (!value) {
          resetScale();
        }
      }
    );
    return __spreadProps$i(__spreadValues$i({}, toRefs(state)), {
      onTouchStart,
      onTouchMove,
      onTouchEnd,
      getDistance,
      imageStyle,
      imageLoad,
      closeSwiper
    });
  }
});
const _hoisted_1$1$4 = ["src"];
function _sfc_render$1$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_video = resolveComponent("nut-video");
  const _component_nut_swiper_item = resolveComponent("nut-swiper-item");
  return openBlock(), createBlock(_component_nut_swiper_item, { onClick: _ctx.closeSwiper }, {
    default: withCtx(() => [
      createBaseVNode("view", {
        style: normalizeStyle(_ctx.imageStyle),
        class: "nut-image-preview-box",
        onTouchstart: _cache[1] || (_cache[1] = (...args) => _ctx.onTouchStart && _ctx.onTouchStart(...args)),
        onTouchmove: _cache[2] || (_cache[2] = (...args) => _ctx.onTouchMove && _ctx.onTouchMove(...args)),
        onTouchend: _cache[3] || (_cache[3] = (...args) => _ctx.onTouchEnd && _ctx.onTouchEnd(...args)),
        onTouchcancel: _cache[4] || (_cache[4] = (...args) => _ctx.onTouchEnd && _ctx.onTouchEnd(...args))
      }, [
        _ctx.image && _ctx.image.src ? (openBlock(), createElementBlock("img", {
          key: 0,
          src: _ctx.image.src,
          class: "nut-image-preview-img",
          onLoad: _cache[0] || (_cache[0] = (...args) => _ctx.imageLoad && _ctx.imageLoad(...args))
        }, null, 40, _hoisted_1$1$4)) : createCommentVNode("", true),
        _ctx.video && _ctx.video.source ? (openBlock(), createBlock(_component_nut_video, {
          key: 1,
          source: _ctx.video.source,
          options: _ctx.video.options
        }, null, 8, ["source", "options"])) : createCommentVNode("", true)
      ], 36)
    ]),
    _: 1
  }, 8, ["onClick"]);
}
const ImagePreviewItem = /* @__PURE__ */ _export_sfc(_sfc_main$1$4, [["render", _sfc_render$1$3]]);
const { create: create$m } = createComponent("image-preview");
const _sfc_main$u = create$m({
  props: __spreadProps$i(__spreadValues$i({}, baseProps), {
    images: { type: Array, default: () => [] },
    videos: { type: Array, default: () => [] },
    contentClose: { type: Boolean, default: true },
    paginationVisible: { type: Boolean, default: false },
    paginationColor: { type: String, default: "#fff" },
    autoplay: { type: [Number, String], default: 0 },
    teleport: { type: [String, Element], default: "body" },
    teleportDisable: { ype: Boolean, default: false },
    closeable: {
      type: Boolean,
      default: false
    },
    closeIconPosition: {
      type: String,
      default: "top-right"
      // top-right  top-left
    },
    beforeClose: Function,
    isLoop: {
      type: Boolean,
      default: true
    }
  }),
  emits: ["close", "change"],
  components: {
    ImagePreviewItem,
    CircleClose: z$1,
    NutPopup,
    NutSwiper
  },
  setup(props, { emit: emit2 }) {
    const swipeRef = ref();
    const state = reactive({
      showPop: props.show,
      active: 0,
      rootWidth: 0,
      rootHeight: 0
    });
    const iconClasses = computed(() => {
      const pre = "nut-image-preview-close";
      const iconn = props.closeIconPosition == "top-right" ? `${pre}-right` : `${pre}-left`;
      return `nut-image-preview-close-icon ${iconn}`;
    });
    const mergeImages = computed(() => {
      if (isArray(props.videos)) {
        return [].concat(props.videos).concat(props.images);
      }
      return props.images;
    });
    const setActive = (active) => {
      if (active !== state.active) {
        state.active = active;
        emit2("change", state.active);
      }
    };
    const onClose = () => {
      funInterceptor(props.beforeClose, {
        args: [state.active],
        done: () => closeDone()
      });
    };
    const closeDone = () => {
      state.showPop = false;
      emit2("close");
    };
    const init = () => {
      if (swipeRef.value) {
        const rect = useRect(swipeRef.value);
        state.rootHeight = rect.height;
        state.rootWidth = rect.width;
      }
    };
    watch(
      () => props.show,
      (val) => {
        state.showPop = val;
        if (val) {
          setActive(props.initNo);
          nextTick(() => {
            init();
          });
        }
      }
    );
    watch(
      () => props.initNo,
      (val) => {
        if (val != state.active) setActive(val);
      }
    );
    onMounted(() => {
      setActive(props.initNo);
    });
    return __spreadProps$i(__spreadValues$i({
      swipeRef
    }, toRefs(state)), {
      onClose,
      mergeImages,
      setActive,
      iconClasses
    });
  }
});
const _hoisted_1$r = {
  ref: "swipeRef",
  class: "nut-image-preview"
};
const _hoisted_2$n = {
  key: 0,
  class: "nut-image-preview-index"
};
function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_image_preview_item = resolveComponent("image-preview-item");
  const _component_nut_swiper = resolveComponent("nut-swiper");
  const _component_CircleClose = resolveComponent("CircleClose");
  const _component_nut_popup = resolveComponent("nut-popup");
  return openBlock(), createBlock(_component_nut_popup, {
    visible: _ctx.showPop,
    "onUpdate:visible": _cache[1] || (_cache[1] = ($event) => _ctx.showPop = $event),
    "pop-class": "nut-image-preview-custom-pop",
    "teleport-disable": _ctx.teleportDisable,
    teleport: _ctx.teleport,
    "lock-scroll": "",
    onClosed: _ctx.onClose
  }, {
    default: withCtx(() => [
      createBaseVNode("view", _hoisted_1$r, [
        _ctx.showPop ? (openBlock(), createBlock(_component_nut_swiper, {
          key: 0,
          "auto-play": _ctx.autoplay,
          class: "nut-image-preview-swiper",
          loop: _ctx.isLoop,
          "is-prevent-default": false,
          direction: "horizontal",
          "init-page": _ctx.initNo,
          "pagination-visible": _ctx.paginationVisible,
          "pagination-color": _ctx.paginationColor,
          onChange: _ctx.setActive
        }, {
          default: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.mergeImages, (item, index2) => {
              return openBlock(), createBlock(_component_image_preview_item, {
                key: index2,
                video: index2 < _ctx.videos.length ? item : {},
                image: index2 >= _ctx.videos.length ? item : {},
                "root-height": _ctx.rootHeight,
                "root-width": _ctx.rootWidth,
                show: _ctx.showPop,
                "init-no": _ctx.active + 1,
                "content-close": _ctx.contentClose,
                "max-zoom": _ctx.maxZoom,
                "min-zoom": _ctx.minZoom,
                onClose: _ctx.onClose
              }, null, 8, ["video", "image", "root-height", "root-width", "show", "init-no", "content-close", "max-zoom", "min-zoom", "onClose"]);
            }), 128))
          ]),
          _: 1
        }, 8, ["auto-play", "loop", "init-page", "pagination-visible", "pagination-color", "onChange"])) : createCommentVNode("", true)
      ], 512),
      _ctx.showIndex ? (openBlock(), createElementBlock("view", _hoisted_2$n, toDisplayString(_ctx.active + 1) + " / " + toDisplayString(_ctx.mergeImages.length), 1)) : createCommentVNode("", true),
      _ctx.closeable ? (openBlock(), createElementBlock("view", {
        key: 1,
        class: normalizeClass(_ctx.iconClasses),
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClose && _ctx.onClose(...args))
      }, [
        renderSlot(_ctx.$slots, "close-icon", {}, () => [
          createVNode(_component_CircleClose, { color: "#ffffff" })
        ])
      ], 2)) : createCommentVNode("", true)
    ]),
    _: 3
  }, 8, ["visible", "teleport-disable", "teleport", "onClosed"]);
}
const ImagePreview = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["render", _sfc_render$m]]);
var __defProp$h = Object.defineProperty;
var __defProps$h = Object.defineProperties;
var __getOwnPropDescs$h = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$h = Object.getOwnPropertySymbols;
var __hasOwnProp$h = Object.prototype.hasOwnProperty;
var __propIsEnum$h = Object.prototype.propertyIsEnumerable;
var __defNormalProp$h = (obj, key, value) => key in obj ? __defProp$h(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$h = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$h.call(b, prop))
      __defNormalProp$h(a2, prop, b[prop]);
  if (__getOwnPropSymbols$h)
    for (var prop of __getOwnPropSymbols$h(b)) {
      if (__propIsEnum$h.call(b, prop))
        __defNormalProp$h(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$h = (a2, b) => __defProps$h(a2, __getOwnPropDescs$h(b));
function useExtend(apis) {
  const instance = getCurrentInstance();
  if (instance) {
    Object.assign(instance.proxy, apis);
  }
}
const { create: create$l } = createComponent("countup");
const _sfc_main$t = create$l({
  props: {
    initNum: {
      type: Number,
      default: 0
    },
    endNum: {
      type: Number,
      default: 0
    },
    speed: {
      type: Number,
      default: 1
    },
    toFixed: {
      type: Number,
      default: 0
    },
    during: {
      type: Number,
      default: 1e3
    },
    startFlag: {
      type: Boolean,
      default: true
    },
    // 数字滚动
    numWidth: {
      type: Number,
      default: 20
    },
    numHeight: {
      type: Number,
      default: 20
    },
    scrolling: {
      type: Boolean,
      default: false
    },
    // 自定义图片
    customBgImg: {
      type: String,
      default: ""
    },
    customSpacNum: {
      type: Number,
      default: 0
    },
    customChangeNum: {
      type: Number,
      default: 1
    },
    // 抽奖
    type: {
      type: String,
      default: ""
    },
    machineNum: {
      type: Number,
      default: 3
    },
    machinePrizeNum: {
      type: Number,
      default: 0
    },
    machinePrizeLevel: {
      type: Number,
      default: 0
    },
    machineTurnMore: {
      type: Number,
      default: 0
    }
  },
  components: {},
  emits: ["click", "scrollEnd"],
  setup(props, { emit: emit2 }) {
    const runNumberImg = ref(null);
    const numberItemRef = ref([]);
    const setRef2 = (el) => {
      if (el) {
        numberItemRef.value.push(el);
      }
    };
    const data = reactive({
      valFlag: false,
      current: 0,
      sortFlag: "add",
      initDigit1: 0,
      initDigit2: 0,
      to0_10: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0],
      to10_0: [0, 9, 8, 7, 6, 5, 4, 3, 2, 1, 1],
      timer: null,
      totalCount: 0,
      // 正整数
      pointNum: 0,
      // 小数位
      numberVal: 0,
      // 数字
      num_total_len: 0,
      // 数字长度
      relNum: 0,
      // 去除小数点
      customNumber: 1,
      prizeLevelTrun: 0,
      prizeY: [],
      prizeYPrev: [],
      // machineTransition: 'none',
      finshMachine: 0,
      notPrize: [],
      typeMachine: ""
    });
    const { startFlag, scrolling, customBgImg, type } = reactive(props);
    watch(
      () => props.customChangeNum,
      () => {
        clearIntervalTime();
        countGo(0);
      }
    );
    watch(
      () => props.machinePrizeLevel,
      (count2) => {
        data.prizeLevelTrun = count2;
      }
    );
    watch(
      () => props.initNum,
      (count2) => {
        data.current = count2;
        data.valFlag = false;
        valChange();
      }
    );
    watch(
      () => props.endNum,
      () => {
        data.current = props.initNum;
        data.valFlag = false;
        valChange();
      }
    );
    const valChange = () => {
      if (data.valFlag) {
        return false;
      }
      if (startFlag) {
        if (scrolling || customBgImg) {
          if (type != "machine") {
            countGo();
          }
        } else {
          countChange();
          setTimeout(() => {
            data.valFlag = true;
          }, 300);
        }
      }
    };
    const clearIntervalTime = () => {
      clearInterval(Number(data.timer));
      data.timer = null;
    };
    const calculation = (num1, num2, type2) => {
      const num1Digits = (num1.toString().split(".")[1] || "").length;
      const num2Digits = (num2.toString().split(".")[1] || "").length;
      const baseNum = Math.pow(10, Math.max(num1Digits, num2Digits));
      {
        const n = Number((num1 * baseNum - num2 * baseNum).toFixed(0));
        return n / baseNum;
      }
    };
    const topNumber = (index2) => {
      let { num_total_len, pointNum, initDigit1, initDigit2, sortFlag } = data;
      let idx1 = sortFlag == "add" || sortFlag == "equal" ? String(initDigit2)[index2 - (num_total_len - pointNum)] : 10 - Number(String(initDigit2)[index2 - (num_total_len - pointNum)]);
      let idx2 = sortFlag == "add" || sortFlag == "equal" ? String(initDigit1)[index2] : 10 - Number(String(initDigit1)[index2]);
      let num = index2 > num_total_len - pointNum - 1 ? -idx1 * 100 + "%" : index2 <= String(initDigit1).length - 1 ? -idx2 * 100 + "%" : 0;
      if (num == "-1000%") {
        num = 0;
      }
      return num;
    };
    const turnNumber = (index2) => {
      let { num_total_len, pointNum, initDigit1, initDigit2 } = data;
      let idx1 = String(initDigit2)[index2 - (num_total_len - pointNum)];
      let num = index2 > num_total_len - pointNum - 1 ? idx1 ? idx1 : 0 : index2 <= String(initDigit1).length - 1 ? String(initDigit1)[index2] : 0;
      return num;
    };
    const countChange = () => {
      let { endNum, initNum, speed, toFixed } = props;
      let countTimer = setInterval(() => {
        if (initNum > endNum) {
          if (Number(data.current) <= endNum || Number(data.current) <= speed) {
            data.current = endNum.toFixed(toFixed);
            clearInterval(countTimer);
            emit2("scrollEnd");
            data.valFlag = false;
          } else {
            let num = parseFloat(String(data.current)) - parseFloat(String(speed));
            data.current = num.toFixed(toFixed);
          }
        } else {
          if (Number(data.current) >= endNum) {
            data.current = endNum.toFixed(toFixed);
            clearInterval(countTimer);
            emit2("scrollEnd");
            data.valFlag = false;
          } else {
            let num = parseFloat(String(data.current)) + parseFloat(String(speed));
            data.current = num.toFixed(toFixed);
          }
        }
      }, props.during);
    };
    const countGo = (flag) => {
      let { initNum, endNum, toFixed, customBgImg: customBgImg2 } = props;
      if (customBgImg2) {
        initNum = props.customChangeNum;
      }
      let startNumber1, startNumber2, endNumber1, endNumber2;
      if (initNum != 0) {
        if (toFixed != 0) {
          initNum = Number(initNum.toFixed(toFixed));
        }
        if (String(initNum).indexOf(".") > -1) {
          startNumber1 = String(initNum).split(".")[0].length;
          startNumber2 = String(initNum).split(".")[1].length;
        } else {
          startNumber1 = String(initNum).length;
          startNumber2 = 0;
        }
      } else {
        startNumber1 = 1;
        startNumber2 = 0;
      }
      if (endNum != 0) {
        if (toFixed != 0) {
          endNum = Number(endNum.toFixed(toFixed));
        }
        if (String(endNum).indexOf(".") > -1) {
          endNumber1 = String(endNum).split(".")[0].length;
          endNumber2 = String(endNum).split(".")[1].length;
        } else {
          endNumber1 = String(endNum).length;
          endNumber2 = 0;
        }
      } else {
        endNumber1 = 1;
        endNumber2 = 0;
      }
      let len1 = startNumber1 >= endNumber1 ? startNumber1 : endNumber1;
      let len2 = startNumber2 >= endNumber2 ? startNumber2 : endNumber2;
      data.num_total_len = len1 + len2;
      data.pointNum = len2;
      if (initNum > endNum) {
        data.sortFlag = "reduce";
        data.to0_10 = [0, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0];
        data.totalCount = calculation(initNum, endNum);
        data.numberVal = Number(String(initNum));
      } else if (initNum < endNum) {
        data.sortFlag = "add";
        data.to0_10 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0];
        data.totalCount = calculation(endNum, initNum);
        data.numberVal = Number(String(endNum));
      } else {
        data.sortFlag = "equal";
      }
      var unit = 1;
      for (let i2 = 0; i2 < data.pointNum; i2++) {
        unit *= 10;
      }
      var rel_big = data.numberVal * unit;
      data.relNum = rel_big;
      if (toFixed != 0) {
        data.pointNum = String(data.numberVal).split(".")[1] ? String(data.numberVal).split(".")[1].length : 0;
        data.num_total_len = String(rel_big).length;
      }
      if (String(initNum).indexOf(".") > -1) {
        let n = String(initNum).split(".");
        data.initDigit1 = Number(n[0]);
        data.initDigit2 = Number(n[1]);
      } else {
        data.initDigit1 = initNum;
        data.initDigit2 = 0;
      }
      if (scrolling && !customBgImg2) {
        nextTick(() => {
          if (data.sortFlag == "equal") {
            return false;
          }
          let element = numberItemRef.value[data.num_total_len - 1];
          runTurn(element);
        });
      } else {
        if (flag !== 0) {
          imgNumberScroll();
        }
      }
    };
    const runTurn = (el) => {
      clearIntervalTime();
      var m2 = 1;
      if (data.pointNum != 0) {
        m2 = 1 / Math.pow(10, data.pointNum);
      }
      data.timer = setInterval(() => {
        runStep(el);
        data.totalCount = calculation(data.totalCount, m2);
        if (data.totalCount <= 0) {
          clearIntervalTime();
          emit2("scrollEnd");
          data.valFlag = false;
        }
      }, props.during);
    };
    const runStep = (el) => {
      let currentTurn = el.getAttribute("turn-number");
      let turningNum;
      if (data.sortFlag == "add") {
        turningNum = parseInt(String(currentTurn)) + 1;
      } else {
        turningNum = parseInt(String(currentTurn)) - 1 >= 0 ? parseInt(String(currentTurn)) - 1 : 9;
      }
      el.setAttribute("turn-number", String(turningNum));
      if (el.style.transition == "none 0s ease 0s" || turningNum == 1 || !el.style.transition) {
        el.style.transition = `all linear ${props.during}ms`;
      }
      if (turningNum == 10 || data.sortFlag == "reduce" && turningNum == 0) {
        var timeOut = null;
        el.style.top = `-${data.sortFlag == "add" ? turningNum * 100 : (10 - turningNum) * 100}%`;
        el.setAttribute("turn-number", "0");
        timeOut = setTimeout(() => {
          timeOut && clearTimeout(timeOut);
          el.style.transition = "none";
          el.style.top = "0";
          reset(el, turningNum);
        }, 0.975 * props.during);
      } else {
        el.style.top = `-${data.sortFlag == "add" ? turningNum * 100 : (10 - turningNum) * 100}%`;
      }
      if (el.style.top == "-100%" && data.sortFlag == "reduce") {
        runStep(el.previousSibling);
      }
    };
    const reset = (el, turningNum) => {
      setTimeout(() => {
        if (turningNum == 10) {
          if (el.previousSibling) {
            runStep(el.previousSibling);
          }
        }
      }, 200);
    };
    const imgNumberScroll = () => {
      nextTick(() => {
        runNumberImg.value.addEventListener("webkitTransitionEnd", () => {
          emit2("scrollEnd");
          data.valFlag = false;
        });
      });
    };
    const generateRandom = () => {
      data.notPrize = [];
      while (data.notPrize.length < 3) {
        var rand = Math.floor(Math.random() * props.machinePrizeNum + 1);
        if (data.notPrize.indexOf(rand) == -1) {
          data.notPrize.push(rand);
        }
      }
    };
    const machineLuck = () => {
      const machineTurnMoreNum = props.machineTurnMore < 0 ? 0 : props.machineTurnMore;
      let distance = props.numHeight * props.machinePrizeNum;
      if (data.prizeLevelTrun < 0) {
        generateRandom();
      }
      for (let i2 = 0; i2 < props.machineNum; i2++) {
        setTimeout(() => {
          let turn = distance * (i2 + 1 + parseFloat(String(machineTurnMoreNum)));
          if (data.prizeYPrev.length != 0) {
            data.prizeY[i2] = data.prizeYPrev[i2];
          }
          let local = data.prizeYPrev[i2] ? data.prizeYPrev[i2] : 0;
          let newLocation = turn + local + (props.machinePrizeNum - data.prizeLevelTrun + 1) * props.numHeight + (distance - local);
          if (data.prizeLevelTrun < 0) {
            newLocation += props.numHeight * data.notPrize[i2];
          }
          scrollTime(
            i2,
            // parseFloat((this.machinePrizeNum-(this.prizeLevelTrun-1))*this.numHeight + turn + local),
            newLocation,
            local
          );
        }, 500 * i2);
      }
    };
    useExtend({ machineLuck });
    const scrollTime = (index2, total, num) => {
      let t = setInterval(() => {
        if (num <= total) {
          num += 10;
          data.prizeY[index2] = parseFloat(String(num));
        } else {
          clearInterval(t);
          t = null;
          data.finshMachine += 1;
          data.prizeY[index2] = total;
          if (data.finshMachine == props.machineNum) {
            let distance = props.numHeight * props.machinePrizeNum;
            data.prizeYPrev = [];
            let prevAry = JSON.parse(JSON.stringify(data.prizeY));
            prevAry.forEach((item) => {
              let n = item;
              while (n > distance) {
                n -= distance;
              }
              data.prizeYPrev.push(n);
            });
            setTimeout(() => {
              data.finshMachine = 0;
              if (data.prizeLevelTrun < 0) {
                emit2("scrollEnd", false);
                data.valFlag = false;
              } else {
                emit2("scrollEnd", true);
                data.valFlag = false;
              }
            }, 130);
          }
        }
      }, 30);
    };
    onMounted(() => {
      data.current = props.initNum;
      nextTick(() => {
        valChange();
      });
    });
    onUnmounted(() => {
      clearIntervalTime();
      data.timer = null;
    });
    return __spreadProps$h(__spreadValues$h(__spreadValues$h({}, toRefs(data)), toRefs(reactive(props))), {
      runNumberImg,
      setRef: setRef2,
      topNumber,
      turnNumber
    });
  }
});
const _hoisted_1$q = { class: "nut-countup" };
const _hoisted_2$m = ["turn-number"];
function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", _hoisted_1$q, [
    _ctx.customBgImg != "" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
      _ctx.type == "machine" ? (openBlock(), createElementBlock("view", {
        key: 0,
        class: "nut-countup__machine",
        style: normalizeStyle({ height: _ctx.numHeight + "px" })
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.machineNum, (val, index2) => {
          return openBlock(), createElementBlock("view", {
            key: "mImg" + index2,
            class: "nut-countup__machine-item",
            style: normalizeStyle({
              width: _ctx.numWidth + "px",
              height: _ctx.numHeight + "px",
              backgroundImage: "url(" + _ctx.customBgImg + ")",
              backgroundPositionY: _ctx.prizeY[index2] + "px"
            })
          }, null, 4);
        }), 128))
      ], 4)) : (openBlock(), createElementBlock("view", {
        key: 1,
        ref: "runNumberImg",
        class: "nut-countup__numberimg",
        style: normalizeStyle({ height: _ctx.numHeight + "px" })
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.num_total_len, (val, index2) => {
          return openBlock(), createElementBlock("view", {
            key: "cImg" + index2,
            class: "nut-countup__numberimg__item",
            style: normalizeStyle({
              width: _ctx.numWidth + "px",
              height: _ctx.numHeight + "px",
              left: _ctx.numWidth * (index2 > _ctx.num_total_len - _ctx.pointNum - 1 ? index2 == _ctx.num_total_len - _ctx.pointNum ? index2 * 1.5 : index2 * 1.3 : index2) + "px",
              backgroundImage: "url(" + _ctx.customBgImg + ")",
              backgroundPositionX: "0",
              backgroundPositionY: -(+String(_ctx.relNum)[index2] * _ctx.numHeight + _ctx.customSpacNum * +String(_ctx.relNum)[index2]) + "px",
              transition: "all linear " + _ctx.during / 10 + "ms"
            })
          }, null, 4);
        }), 128)),
        _ctx.pointNum > 0 ? (openBlock(), createElementBlock("view", {
          key: 0,
          class: "nut-countup-pointstyl",
          style: normalizeStyle({
            width: _ctx.numWidth / 2 + "px",
            bottom: 0,
            left: _ctx.numWidth * (_ctx.num_total_len - _ctx.pointNum) * 1.1 + "px",
            fontSize: "30px"
          })
        }, " . ", 4)) : createCommentVNode("", true)
      ], 4))
    ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
      _ctx.scrolling ? (openBlock(), createElementBlock("view", {
        key: 0,
        class: "nut-countup__number",
        style: normalizeStyle({
          width: _ctx.numWidth * _ctx.num_total_len + _ctx.numWidth / 3 + "px",
          height: _ctx.numHeight + "px",
          lineHeight: _ctx.numHeight + "px"
        })
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.num_total_len, (val, index2) => {
          return openBlock(), createElementBlock("view", {
            ref_for: true,
            ref: (el) => _ctx.setRef(el),
            key: val,
            class: "nut-countup__number-item",
            style: normalizeStyle({
              top: _ctx.topNumber(index2),
              left: _ctx.numWidth * (index2 > _ctx.num_total_len - _ctx.pointNum - 1 ? index2 * 1.1 : index2) + "px"
            }),
            "turn-number": _ctx.turnNumber(index2)
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.to0_10, (item, idx) => {
              return openBlock(), createElementBlock("view", {
                key: "dote" + idx,
                class: "nut-countup__number-item__span",
                style: normalizeStyle({
                  width: _ctx.numWidth + "px",
                  height: _ctx.numHeight + "px",
                  lineHeight: _ctx.numHeight + "px"
                })
              }, toDisplayString(item), 5);
            }), 128))
          ], 12, _hoisted_2$m);
        }), 128)),
        _ctx.pointNum > 0 ? (openBlock(), createElementBlock("view", {
          key: 0,
          class: "nut-countup-pointstyl",
          style: normalizeStyle({
            width: _ctx.numWidth / 3 + "px",
            height: _ctx.numHeight + "px",
            lineHeight: _ctx.numHeight + "px",
            top: 0,
            left: _ctx.numWidth * (_ctx.num_total_len - _ctx.pointNum) + "px"
          })
        }, " . ", 4)) : createCommentVNode("", true)
      ], 4)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        createTextVNode(toDisplayString(_ctx.current), 1)
      ], 64))
    ], 64))
  ]);
}
const index$h = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["render", _sfc_render$l]]);
var __defProp$g = Object.defineProperty;
var __defProps$g = Object.defineProperties;
var __getOwnPropDescs$g = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$g = Object.getOwnPropertySymbols;
var __hasOwnProp$g = Object.prototype.hasOwnProperty;
var __propIsEnum$g = Object.prototype.propertyIsEnumerable;
var __defNormalProp$g = (obj, key, value) => key in obj ? __defProp$g(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$g = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$g.call(b, prop))
      __defNormalProp$g(a2, prop, b[prop]);
  if (__getOwnPropSymbols$g)
    for (var prop of __getOwnPropSymbols$g(b)) {
      if (__propIsEnum$g.call(b, prop))
        __defNormalProp$g(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$g = (a2, b) => __defProps$g(a2, __getOwnPropDescs$g(b));
const getTimeStamp = (timeStr) => {
  if (!timeStr) return Date.now();
  let t = timeStr;
  t = +t > 0 ? +t : t.toString().replace(/-/g, "/");
  return new Date(t).getTime();
};
const parseFormat = (time, format2) => {
  let { h: h2, m: m2, s, ms } = time;
  const { d: d2 } = time;
  if (format2.includes("DD")) {
    format2 = format2.replace("DD", padZero(d2));
  } else {
    h2 += Number(d2) * 24;
  }
  if (format2.includes("HH")) {
    format2 = format2.replace("HH", padZero(h2));
  } else {
    m2 += Number(h2) * 60;
  }
  if (format2.includes("mm")) {
    format2 = format2.replace("mm", padZero(m2));
  } else {
    s += Number(m2) * 60;
  }
  if (format2.includes("ss")) {
    format2 = format2.replace("ss", padZero(s));
  } else {
    ms += Number(s) * 1e3;
  }
  if (format2.includes("S")) {
    const msC = padZero(ms, 3).toString();
    if (format2.includes("SSS")) {
      format2 = format2.replace("SSS", msC);
    } else if (format2.includes("SS")) {
      format2 = format2.replace("SS", msC.slice(0, 2));
    } else if (format2.includes("S")) {
      format2 = format2.replace("S", msC.slice(0, 1));
    }
  }
  return format2;
};
const formatRemainTime = (t, format2, type) => {
  const ts = t;
  const rest = {
    d: 0,
    h: 0,
    m: 0,
    s: 0,
    ms: 0
  };
  const SECOND = 1e3;
  const MINUTE = 60 * SECOND;
  const HOUR = 60 * MINUTE;
  const DAY = 24 * HOUR;
  if (ts > 0) {
    rest.d = ts >= SECOND ? Math.floor(ts / DAY) : 0;
    rest.h = Math.floor(ts % DAY / HOUR);
    rest.m = Math.floor(ts % HOUR / MINUTE);
    rest.s = Math.floor(ts % MINUTE / SECOND);
    rest.ms = Math.floor(ts % SECOND);
  }
  return type == "custom" ? rest : parseFormat(__spreadValues$g({}, rest), format2);
};
const _hoisted_1$p = { class: "nut-countdown" };
const _hoisted_2$l = ["innerHTML"];
const _sfc_main$s = /* @__PURE__ */ defineComponent(__spreadProps$g(__spreadValues$g({}, {
  name: "NutCountdown"
}), {
  __name: "countdown",
  props: {
    modelValue: {},
    paused: { type: Boolean, default: false },
    startTime: { default: "" },
    endTime: { default: "" },
    millisecond: { type: Boolean, default: false },
    format: { default: "HH:mm:ss" },
    autoStart: { type: Boolean, default: true },
    time: { default: 0 }
  },
  emits: [
    "input",
    "update:modelValue",
    "end",
    "restart",
    "paused",
    // will be deprecated
    "onEnd",
    "onRestart",
    "onPaused"
  ],
  setup(__props, { expose: __expose, emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const restTime = ref(0);
    const timer = ref(null);
    const counting = ref(!props.paused && props.autoStart);
    const handleEndTime = ref(Date.now());
    const diffTime = ref(0);
    const renderTime = computed(() => {
      return formatRemainTime(restTime.value, props.format);
    });
    const initTime = () => {
      handleEndTime.value = Number(props.endTime);
      diffTime.value = Date.now() - getTimeStamp(props.startTime);
      if (!counting.value) counting.value = true;
      tick();
    };
    const tick = () => {
      if (window !== void 0) {
        timer.value = requestAnimationFrame(() => {
          if (counting.value) {
            const currentTime = Date.now() - diffTime.value;
            const remainTime = Math.max(handleEndTime.value - currentTime, 0);
            restTime.value = remainTime;
            if (!remainTime) {
              counting.value = false;
              pause();
              emit2("end");
              emit2("onEnd");
            }
            if (remainTime > 0) {
              tick();
            }
          }
        });
      }
    };
    const start = () => {
      if (!counting.value && !props.autoStart) {
        counting.value = true;
        handleEndTime.value = Date.now() + Number(restTime.value);
        tick();
        emit2("restart", restTime.value);
        emit2("onRestart", restTime.value);
      }
    };
    const pause = () => {
      cancelAnimationFrame(timer.value);
      counting.value = false;
      emit2("paused", restTime.value);
      emit2("onPaused", restTime.value);
    };
    const reset = () => {
      if (!props.autoStart) {
        pause();
        restTime.value = Number(props.time);
      }
    };
    __expose({
      start,
      pause,
      reset
    });
    onBeforeMount(() => {
      if (props.autoStart) {
        initTime();
      } else {
        restTime.value = Number(props.time);
      }
    });
    watch(
      () => restTime.value,
      (value) => {
        const tranTime = formatRemainTime(value, props.format, "custom");
        emit2("update:modelValue", tranTime);
        emit2("input", tranTime);
      }
    );
    watch(
      () => props.paused,
      (v2, ov) => {
        if (!ov) {
          if (counting.value) {
            pause();
          }
        } else {
          if (!counting.value) {
            counting.value = true;
            handleEndTime.value = Date.now() + Number(restTime.value);
            tick();
          }
          emit2("restart", restTime.value);
          emit2("onRestart", restTime.value);
        }
      }
    );
    watch(
      () => props.endTime,
      () => {
        initTime();
      }
    );
    watch(
      () => props.startTime,
      () => {
        initTime();
      }
    );
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("view", _hoisted_1$p, [
        renderSlot(_ctx.$slots, "default", {}, () => [
          createBaseVNode("view", {
            class: "nut-countdown__content",
            innerHTML: renderTime.value
          }, null, 8, _hoisted_2$l)
        ])
      ]);
    };
  }
}));
withInstall(_sfc_main$s);
var __defProp$f = Object.defineProperty;
var __defProps$f = Object.defineProperties;
var __getOwnPropDescs$f = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$f = Object.getOwnPropertySymbols;
var __hasOwnProp$f = Object.prototype.hasOwnProperty;
var __propIsEnum$f = Object.prototype.propertyIsEnumerable;
var __defNormalProp$f = (obj, key, value) => key in obj ? __defProp$f(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$f = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$f.call(b, prop))
      __defNormalProp$f(a2, prop, b[prop]);
  if (__getOwnPropSymbols$f)
    for (var prop of __getOwnPropSymbols$f(b)) {
      if (__propIsEnum$f.call(b, prop))
        __defNormalProp$f(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$f = (a2, b) => __defProps$f(a2, __getOwnPropDescs$f(b));
const _sfc_main$r = /* @__PURE__ */ defineComponent(__spreadProps$f(__spreadValues$f({}, {
  name: "NutTag"
}), {
  __name: "tag",
  props: {
    color: { default: "" },
    textColor: { default: "" },
    type: { default: "default" },
    plain: { type: Boolean, default: false },
    round: { type: Boolean, default: false },
    mark: { type: Boolean, default: false },
    closeable: { type: Boolean, default: false }
  },
  emits: ["close", "click"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emits = __emit;
    const classes = computed(() => {
      const prefixCls2 = "nut-tag";
      return {
        [prefixCls2]: true,
        [`${prefixCls2}--${props.type}`]: props.type,
        [`${prefixCls2}--plain`]: props.plain,
        [`${prefixCls2}--round`]: props.round,
        [`${prefixCls2}--mark`]: props.mark
      };
    });
    const style = computed(() => {
      const style2 = {};
      if (props.textColor) {
        style2.color = props.textColor;
      } else if (props.color && props.plain) {
        style2.color = props.color;
      }
      if (props.plain) {
        style2.background = "#fff";
        style2.borderColor = props.color;
      } else if (props.color) {
        style2.background = props.color;
      }
      return style2;
    });
    const onClose = (event) => {
      emits("close", event);
    };
    const onClick = (event) => {
      emits("click", event);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("view", {
        class: normalizeClass(classes.value),
        style: normalizeStyle(style.value),
        onClick
      }, [
        renderSlot(_ctx.$slots, "default"),
        _ctx.closeable ? (openBlock(), createBlock(unref(g$4), {
          key: 0,
          class: "nut-tag--close",
          width: "12px",
          height: "12px",
          onClick: withModifiers(onClose, ["stop"])
        })) : createCommentVNode("", true)
      ], 6);
    };
  }
}));
withInstall(_sfc_main$r);
const { create: create$k } = createComponent("popover");
const _sfc_main$q = create$k({
  components: {
    NutPopup
  },
  props: {
    visible: { type: Boolean, default: false },
    list: { type: Array, default: [] },
    theme: { type: String, default: "light" },
    location: { type: String, default: "bottom" },
    offset: { type: Array, default: [0, 12] },
    arrowOffset: { type: Number, default: 0 },
    customClass: { type: String, default: "" },
    showArrow: { type: Boolean, default: true },
    duration: { type: [Number, String], default: 0.3 },
    overlay: { type: Boolean, default: false },
    overlayClass: { type: String, default: "" },
    overlayStyle: { type: Object },
    closeOnClickOverlay: { type: Boolean, default: true },
    closeOnClickAction: { type: Boolean, default: true },
    closeOnClickOutside: { type: Boolean, default: true },
    targetId: { type: String, default: "" },
    bgColor: { type: String, default: "" }
  },
  emits: ["update", "update:visible", "close", "choose", "open"],
  setup(props, { emit: emit2 }) {
    const popoverRef = ref();
    const popoverContentRef = ref();
    const showPopup = ref(props.visible);
    const rootPosition = ref();
    const elRect = ref({
      width: 0,
      height: 0
    });
    const popoverArrow = computed(() => {
      const prefixCls2 = "nut-popover-arrow";
      const loca = props.location;
      const direction = loca.split("-")[0];
      return `${prefixCls2} ${prefixCls2}-${direction} ${prefixCls2}--${loca}`;
    });
    const popoverArrowStyle = computed(() => {
      const styles = {};
      const { bgColor, arrowOffset, location: location2 } = props;
      const direction = location2.split("-")[0];
      const skew = location2.split("-")[1];
      const base = 16;
      if (bgColor) {
        styles[`border${upperCaseFirst(direction)}Color`] = bgColor;
      }
      if (props.arrowOffset != 0) {
        if (["bottom", "top"].includes(direction)) {
          if (!skew) {
            styles.left = `calc(50% + ${arrowOffset}px)`;
          }
          if (skew == "start") {
            styles.left = `${base + arrowOffset}px`;
          }
          if (skew == "end") {
            styles.right = `${base - arrowOffset}px`;
          }
        }
        if (["left", "right"].includes(direction)) {
          if (!skew) {
            styles.top = `calc(50% - ${arrowOffset}px)`;
          }
          if (skew == "start") {
            styles.top = `${base - arrowOffset}px`;
          }
          if (skew == "end") {
            styles.bottom = `${base + arrowOffset}px`;
          }
        }
      }
      return styles;
    });
    const upperCaseFirst = (str) => {
      str = str.toLowerCase();
      str = str.replace(/\b\w+\b/g, (word) => word.substring(0, 1).toUpperCase() + word.substring(1));
      return str;
    };
    const getRootPosition = computed(() => {
      const styles = {};
      if (!rootPosition.value) return {};
      const contentWidth = elRect.value.width;
      const contentHeight = elRect.value.height;
      const { width, height, left, top, right } = rootPosition.value;
      const { location: location2, offset } = props;
      const direction = location2 == null ? void 0 : location2.split("-")[0];
      const skew = location2 == null ? void 0 : location2.split("-")[1];
      let cross = 0;
      let parallel = 0;
      if (Array.isArray(offset) && (offset == null ? void 0 : offset.length) === 2) {
        cross += Number(offset[1]);
        parallel += Number(offset[0]);
      }
      if (width) {
        if (["bottom", "top"].includes(direction)) {
          const h2 = direction === "bottom" ? height + cross : -(contentHeight + cross);
          styles.top = `${top + h2}px`;
          if (!skew) {
            styles.left = `${-(contentWidth - width) / 2 + left + parallel}px`;
          }
          if (skew === "start") {
            styles.left = `${left + parallel}px`;
          }
          if (skew === "end") {
            styles.left = `${right + parallel}px`;
          }
        }
        if (["left", "right"].includes(direction)) {
          const contentW = direction === "left" ? -(contentWidth + cross) : width + cross;
          styles.left = `${left + contentW}px`;
          if (!skew) {
            styles.top = `${top - contentHeight / 2 + height / 2 - 4 + parallel}px`;
          }
          if (skew === "start") {
            styles.top = `${top + parallel}px`;
          }
          if (skew === "end") {
            styles.top = `${top + height + parallel}px`;
          }
        }
      }
      return styles;
    });
    const getContentWidth = () => {
      var _a, _b, _c, _d;
      const rect = useRect(
        props.targetId ? document.querySelector(`#${props.targetId}`) : popoverRef.value
      );
      rootPosition.value = {
        width: rect.width,
        height: rect.height,
        left: rect.left,
        top: rect.top + Math.max(((_a = document.documentElement) == null ? void 0 : _a.scrollTop) || 0, ((_b = document.body) == null ? void 0 : _b.scrollTop) || 0),
        right: rect.right
      };
      elRect.value = {
        height: (_c = popoverContentRef.value) == null ? void 0 : _c.clientHeight,
        width: (_d = popoverContentRef.value) == null ? void 0 : _d.clientWidth
      };
    };
    onMounted(() => {
      setTimeout(() => {
        getContentWidth();
      }, 300);
    });
    watch(
      () => props.visible,
      (value) => {
        showPopup.value = value;
        if (value) {
          window.addEventListener("touchstart", clickAway, true);
          nextTick(() => {
            getContentWidth();
          });
        } else {
          window.removeEventListener("touchstart", clickAway, true);
        }
      }
    );
    const update = (val) => {
      emit2("update", val);
      emit2("update:visible", val);
    };
    const openPopover = () => {
      update(!props.visible);
      emit2("open");
    };
    const closePopover = () => {
      emit2("update:visible", false);
      emit2("close");
    };
    const chooseItem = (item, index2) => {
      !item.disabled && emit2("choose", item, index2);
      if (props.closeOnClickAction) {
        closePopover();
      }
    };
    const clickAway = (event) => {
      const element = popoverRef.value;
      const elContent = popoverContentRef.value;
      let el = element && !element.contains(event.target);
      if (props.targetId) {
        const dom = document.querySelector(`#${props.targetId}`);
        el = dom && !dom.contains(event.target);
      }
      if (el && elContent && !elContent.contains(event.target) && props.closeOnClickOutside) {
        closePopover();
      }
    };
    return {
      showPopup,
      openPopover,
      popoverArrow,
      closePopover,
      chooseItem,
      popoverRef,
      popoverContentRef,
      getRootPosition,
      popoverArrowStyle,
      renderIcon
    };
  }
});
const _hoisted_1$o = {
  ref: "popoverContentRef",
  class: "nut-popover-content-group"
};
const _hoisted_2$k = ["onClick"];
const _hoisted_3$k = { class: "nut-popover-menu-item-name" };
function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_popup = resolveComponent("nut-popup");
  return openBlock(), createElementBlock(Fragment, null, [
    !_ctx.targetId ? (openBlock(), createElementBlock("div", {
      key: 0,
      ref: "popoverRef",
      class: "nut-popover-wrapper",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.openPopover && _ctx.openPopover(...args))
    }, [
      renderSlot(_ctx.$slots, "reference")
    ], 512)) : createCommentVNode("", true),
    (openBlock(), createBlock(Teleport, { to: "body" }, [
      createBaseVNode("div", {
        class: normalizeClass(["nut-popover", `nut-popover--${_ctx.theme}`, `${_ctx.customClass}`]),
        style: normalizeStyle(_ctx.getRootPosition)
      }, [
        createVNode(_component_nut_popup, {
          visible: _ctx.showPopup,
          "onUpdate:visible": _cache[1] || (_cache[1] = ($event) => _ctx.showPopup = $event),
          "pop-class": `nut-popover-content nut-popover-content--${_ctx.location}`,
          style: normalizeStyle({ background: _ctx.bgColor }),
          position: "",
          transition: "nut-popover",
          overlay: _ctx.overlay,
          duration: _ctx.duration,
          "overlay-style": _ctx.overlayStyle,
          "overlay-class": _ctx.overlayClass,
          "close-on-click-overlay": _ctx.closeOnClickOverlay
        }, {
          default: withCtx(() => [
            createBaseVNode("div", _hoisted_1$o, [
              _ctx.showArrow ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(_ctx.popoverArrow),
                style: normalizeStyle(_ctx.popoverArrowStyle)
              }, null, 6)) : createCommentVNode("", true),
              renderSlot(_ctx.$slots, "content"),
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.list, (item, index2) => {
                return openBlock(), createElementBlock("div", {
                  key: index2,
                  class: normalizeClass([item.className, item.disabled && "nut-popover-menu-disabled", "nut-popover-menu-item"]),
                  onClick: withModifiers(($event) => _ctx.chooseItem(item, index2), ["stop"])
                }, [
                  item.icon ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.renderIcon(item.icon)), {
                    key: 0,
                    class: "nut-popover-item-img"
                  })) : createCommentVNode("", true),
                  createBaseVNode("div", _hoisted_3$k, toDisplayString(item.name), 1)
                ], 10, _hoisted_2$k);
              }), 128))
            ], 512)
          ]),
          _: 3
        }, 8, ["visible", "pop-class", "style", "overlay", "duration", "overlay-style", "overlay-class", "close-on-click-overlay"])
      ], 6)
    ]))
  ], 64);
}
const NutPopover = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["render", _sfc_render$k]]);
var __defProp$e = Object.defineProperty;
var __defProps$e = Object.defineProperties;
var __getOwnPropDescs$e = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$e = Object.getOwnPropertySymbols;
var __hasOwnProp$e = Object.prototype.hasOwnProperty;
var __propIsEnum$e = Object.prototype.propertyIsEnumerable;
var __defNormalProp$e = (obj, key, value) => key in obj ? __defProp$e(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$e = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$e.call(b, prop))
      __defNormalProp$e(a2, prop, b[prop]);
  if (__getOwnPropSymbols$e)
    for (var prop of __getOwnPropSymbols$e(b)) {
      if (__propIsEnum$e.call(b, prop))
        __defNormalProp$e(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$e = (a2, b) => __defProps$e(a2, __getOwnPropDescs$e(b));
const _hoisted_1$n = { key: 0 };
const _hoisted_2$j = {
  key: 1,
  class: "nut-skeleton"
};
const _hoisted_3$j = {
  key: 0,
  class: "nut-skeleton-animation"
};
const _hoisted_4$h = { class: "nut-skeleton-content" };
const _sfc_main$p = /* @__PURE__ */ defineComponent(__spreadProps$e(__spreadValues$e({}, {
  name: "NutSkeleton"
}), {
  __name: "skeleton",
  props: {
    width: { default: "100px" },
    height: { default: "15px" },
    animated: { type: Boolean, default: false },
    avatar: { type: Boolean, default: false },
    avatarShape: { default: "round" },
    avatarSize: { default: "50px" },
    loading: { type: Boolean, default: true },
    round: { type: Boolean, default: false },
    row: { default: "1" },
    title: { type: Boolean, default: true }
  },
  setup(__props) {
    const props = __props;
    const avatarClass = computed(() => {
      const prefixCls2 = "avatarClass";
      return {
        [prefixCls2]: true,
        [`${prefixCls2}--${props.avatarShape}`]: props.avatarShape
      };
    });
    const getBlockClass = (prefixCls2) => {
      return {
        [prefixCls2]: true,
        [`${prefixCls2}--round`]: props.round
      };
    };
    const avatarStyle = computed(() => {
      return {
        width: props.avatarSize,
        height: props.avatarSize
      };
    });
    return (_ctx, _cache) => {
      return !_ctx.loading ? (openBlock(), createElementBlock("view", _hoisted_1$n, [
        renderSlot(_ctx.$slots, "default")
      ])) : (openBlock(), createElementBlock("view", _hoisted_2$j, [
        _ctx.animated ? (openBlock(), createElementBlock("view", _hoisted_3$j)) : createCommentVNode("", true),
        createBaseVNode("view", _hoisted_4$h, [
          _ctx.avatar ? (openBlock(), createBlock(NutAvatar, {
            key: 0,
            class: normalizeClass(avatarClass.value),
            shape: _ctx.avatarShape,
            style: normalizeStyle(avatarStyle.value)
          }, null, 8, ["class", "shape", "style"])) : createCommentVNode("", true),
          createBaseVNode("view", {
            class: "nut-skeleton-content__line",
            style: normalizeStyle({ width: _ctx.width })
          }, [
            _ctx.title ? (openBlock(), createElementBlock("view", {
              key: 0,
              class: normalizeClass(getBlockClass("nut-skeleton-blockTitle")),
              style: normalizeStyle({ height: _ctx.height })
            }, null, 6)) : createCommentVNode("", true),
            (openBlock(true), createElementBlock(Fragment, null, renderList(Number(_ctx.row), (_) => {
              return openBlock(), createElementBlock("view", {
                key: _,
                class: normalizeClass(getBlockClass("nut-skeleton-blockLine")),
                style: normalizeStyle({ height: _ctx.height })
              }, null, 6);
            }), 128))
          ], 4)
        ])
      ]));
    };
  }
}));
withInstall(_sfc_main$p);
const COLLAPSE_KEY = Symbol("nut-collapse");
var __defProp$d = Object.defineProperty;
var __defProps$d = Object.defineProperties;
var __getOwnPropDescs$d = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$d = Object.getOwnPropertySymbols;
var __hasOwnProp$d = Object.prototype.hasOwnProperty;
var __propIsEnum$d = Object.prototype.propertyIsEnumerable;
var __defNormalProp$d = (obj, key, value) => key in obj ? __defProp$d(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$d = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$d.call(b, prop))
      __defNormalProp$d(a2, prop, b[prop]);
  if (__getOwnPropSymbols$d)
    for (var prop of __getOwnPropSymbols$d(b)) {
      if (__propIsEnum$d.call(b, prop))
        __defNormalProp$d(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$d = (a2, b) => __defProps$d(a2, __getOwnPropDescs$d(b));
const _hoisted_1$m = { class: "nut-collapse" };
const _sfc_main$o = /* @__PURE__ */ defineComponent(__spreadProps$d(__spreadValues$d({}, {
  name: "NutCollapse"
}), {
  __name: "collapse",
  props: {
    modelValue: { default: "" },
    accordion: { type: Boolean, default: false }
  },
  emits: ["update:modelValue", "change"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const innerValue = ref(props.modelValue || (props.accordion ? "" : []));
    watch(
      () => props.modelValue,
      (val) => {
        innerValue.value = val;
      }
    );
    const changeVal = (val, name, status = true) => {
      innerValue.value = val;
      emit2("update:modelValue", val);
      emit2("change", val, name, status);
    };
    const updateVal = (name) => {
      if (props.accordion) {
        if (innerValue.value === name) {
          changeVal("", name, false);
        } else {
          changeVal(name, name, true);
        }
      } else {
        if (Array.isArray(innerValue.value)) {
          if (innerValue.value.includes(name)) {
            const newValue = innerValue.value.filter((v2) => v2 !== name);
            changeVal(newValue, name, false);
          } else {
            const newValue = innerValue.value.concat([name]);
            changeVal(newValue, name, true);
          }
        } else {
          console.warn("[NutUI] <Collapse> 未开启手风琴模式时 v-model 应为数组");
        }
      }
    };
    const isExpanded = (name) => {
      if (props.accordion) {
        return innerValue.value === name;
      } else if (Array.isArray(innerValue.value)) {
        return innerValue.value.includes(name);
      }
      return false;
    };
    provide(COLLAPSE_KEY, {
      updateVal,
      isExpanded
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("view", _hoisted_1$m, [
        renderSlot(_ctx.$slots, "default")
      ]);
    };
  }
}));
withInstall(_sfc_main$o);
var __defProp$c = Object.defineProperty;
var __defProps$c = Object.defineProperties;
var __getOwnPropDescs$c = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$c = Object.getOwnPropertySymbols;
var __hasOwnProp$c = Object.prototype.hasOwnProperty;
var __propIsEnum$c = Object.prototype.propertyIsEnumerable;
var __defNormalProp$c = (obj, key, value) => key in obj ? __defProp$c(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$c = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$c.call(b, prop))
      __defNormalProp$c(a2, prop, b[prop]);
  if (__getOwnPropSymbols$c)
    for (var prop of __getOwnPropSymbols$c(b)) {
      if (__propIsEnum$c.call(b, prop))
        __defNormalProp$c(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$c = (a2, b) => __defProps$c(a2, __getOwnPropDescs$c(b));
const _hoisted_1$l = { class: "nut-collapse-item__title-main" };
const _hoisted_2$i = { class: "nut-collapse-item__title-main-value" };
const _hoisted_3$i = ["innerHTML"];
const _hoisted_4$g = {
  key: 2,
  class: "nut-collapse-item__title-label"
};
const _hoisted_5$a = {
  key: 0,
  class: "nut-collapse-item__title-sub"
};
const _hoisted_6$9 = ["innerHTML"];
const _hoisted_7$8 = {
  key: 0,
  class: "nut-collapse__item-extraWrapper"
};
const _hoisted_8$5 = { class: "nut-collapse__item-extraWrapper__extraRender" };
const _sfc_main$n = /* @__PURE__ */ defineComponent(__spreadProps$c(__spreadValues$c({}, {
  name: "NutCollapseItem"
}), {
  __name: "collapse-item",
  props: {
    title: { default: "" },
    value: { default: "" },
    label: { default: "" },
    disabled: { type: Boolean, default: false },
    name: { default: -1 },
    border: { type: Boolean, default: true },
    icon: { default: () => g$3 },
    rotate: { default: 180 }
  },
  setup(__props) {
    const props = __props;
    const wrapperRef = ref(null);
    const contentRef = ref(null);
    const parent = inject(COLLAPSE_KEY);
    const classes = computed(() => {
      const prefixCls2 = "nut-collapse-item";
      return {
        [prefixCls2]: true,
        [prefixCls2 + "__border"]: props.border
      };
    });
    const expanded = computed(() => {
      if (parent) {
        return parent.isExpanded(props.name);
      }
      return false;
    });
    const wrapperHeight = ref(expanded.value ? "auto" : "0px");
    const toggle = () => {
      parent && parent.updateVal(props.name);
    };
    const onTransitionEnd = () => {
      if (expanded.value) {
        wrapperHeight.value = "auto";
      }
    };
    const open = () => {
      wrapperHeight.value = "0px";
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          var _a;
          const height = (_a = contentRef.value) == null ? void 0 : _a.offsetHeight;
          wrapperHeight.value = height ? `${height}px` : "auto";
        });
      });
    };
    const close = () => {
      var _a;
      const height = (_a = contentRef.value) == null ? void 0 : _a.offsetHeight;
      wrapperHeight.value = height ? `${height}px` : "auto";
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          wrapperHeight.value = "0px";
        });
      });
    };
    watch(expanded, (value) => {
      value ? open() : close();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("view", {
        class: normalizeClass(classes.value)
      }, [
        createBaseVNode("view", {
          class: normalizeClass(["nut-collapse-item__title", { "nut-collapse-item__title--disabled": _ctx.disabled }]),
          onClick: toggle
        }, [
          createBaseVNode("view", _hoisted_1$l, [
            createBaseVNode("view", _hoisted_2$i, [
              _ctx.$slots.title ? renderSlot(_ctx.$slots, "title", { key: 0 }) : (openBlock(), createElementBlock("view", {
                key: 1,
                class: "nut-collapse-item__title-mtitle",
                innerHTML: _ctx.title
              }, null, 8, _hoisted_3$i)),
              _ctx.label ? (openBlock(), createElementBlock("view", _hoisted_4$g, toDisplayString(_ctx.label), 1)) : createCommentVNode("", true)
            ])
          ]),
          _ctx.$slots.value ? (openBlock(), createElementBlock("view", _hoisted_5$a, [
            renderSlot(_ctx.$slots, "value")
          ])) : (openBlock(), createElementBlock("view", {
            key: 1,
            class: "nut-collapse-item__title-sub",
            innerHTML: _ctx.value
          }, null, 8, _hoisted_6$9)),
          createBaseVNode("view", {
            class: normalizeClass(["nut-collapse-item__title-icon", { "nut-collapse-item__title-icon--expanded": expanded.value }]),
            style: normalizeStyle({ transform: "rotate(" + (expanded.value ? _ctx.rotate : 0) + "deg)" })
          }, [
            _ctx.$slots.icon ? renderSlot(_ctx.$slots, "icon", { key: 0 }) : (openBlock(), createBlock(resolveDynamicComponent(unref(renderIcon)(_ctx.icon)), { key: 1 }))
          ], 6)
        ], 2),
        _ctx.$slots.extra ? (openBlock(), createElementBlock("view", _hoisted_7$8, [
          createBaseVNode("div", _hoisted_8$5, [
            renderSlot(_ctx.$slots, "extra")
          ])
        ])) : createCommentVNode("", true),
        createBaseVNode("view", {
          ref_key: "wrapperRef",
          ref: wrapperRef,
          class: "nut-collapse__item-wrapper",
          style: normalizeStyle({
            willChange: "height",
            height: wrapperHeight.value
          }),
          onTransitionend: onTransitionEnd
        }, [
          createBaseVNode("view", {
            ref_key: "contentRef",
            ref: contentRef,
            class: "nut-collapse__item-wrapper__content"
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 512)
        ], 36)
      ], 2);
    };
  }
}));
withInstall(_sfc_main$n);
var __defProp$b = Object.defineProperty;
var __defProps$b = Object.defineProperties;
var __getOwnPropDescs$b = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$b = Object.getOwnPropertySymbols;
var __hasOwnProp$b = Object.prototype.hasOwnProperty;
var __propIsEnum$b = Object.prototype.propertyIsEnumerable;
var __defNormalProp$b = (obj, key, value) => key in obj ? __defProp$b(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$b = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$b.call(b, prop))
      __defNormalProp$b(a2, prop, b[prop]);
  if (__getOwnPropSymbols$b)
    for (var prop of __getOwnPropSymbols$b(b)) {
      if (__propIsEnum$b.call(b, prop))
        __defNormalProp$b(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$b = (a2, b) => __defProps$b(a2, __getOwnPropDescs$b(b));
const RenderColumn = /* @__PURE__ */ defineComponent({
  props: {
    slots: {
      type: Array,
      default: () => []
    },
    record: {
      type: Object,
      default: () => ({})
    }
  },
  setup(props) {
    return () => h$2(`view`, {}, props.slots[0] ? props.slots[0](props.record) : props.slots[1](props.record));
  }
});
const { create: create$j } = createComponent("table");
const cN$8 = "NutTable";
const _sfc_main$m = create$j({
  components: {
    RenderColumn,
    DownArrow: g$3
  },
  props: {
    bordered: {
      type: Boolean,
      default: true
    },
    columns: {
      type: Array,
      default: () => []
    },
    data: {
      type: Object,
      default: () => ({})
    },
    summary: {
      type: Function,
      default: null
    },
    striped: {
      type: Boolean,
      default: false
    }
  },
  emits: ["sorter"],
  setup(props, { emit: emit2 }) {
    const translate = useLocale(cN$8);
    const state = reactive({
      curData: props.data
    });
    const cellClasses = (item) => {
      return {
        "nut-table__main__head__tr--border": props.bordered,
        [`nut-table__main__head__tr--align${item.align ? item.align : ""}`]: true
      };
    };
    const stylehead = (item) => {
      return item.stylehead ? item.stylehead : "";
    };
    const stylecolumn = (item) => {
      return item.stylecolumn ? item.stylecolumn : "";
    };
    const getColumnItem = (value) => {
      return props.columns.filter((item) => item.key === value)[0];
    };
    const getColumnItemStyle = (value) => {
      const style = props.columns.filter((item) => item.key === value);
      return style[0].stylecolumn ? style[0].stylecolumn : "";
    };
    const handleSorterClick = (item) => {
      if (item.sorter) {
        emit2("sorter", item);
        state.curData = typeof item.sorter === "function" ? state.curData.sort(item.sorter) : item.sorter === "default" ? state.curData.sort() : state.curData;
      }
    };
    const sortDataItem = () => {
      return props.columns.map((columns) => {
        return [columns.key, columns.render];
      });
    };
    watch(
      () => props.data,
      (val) => {
        state.curData = val.slice();
      }
    );
    return __spreadProps$b(__spreadValues$b({}, toRefs(state)), {
      cellClasses,
      getColumnItem,
      getColumnItemStyle,
      handleSorterClick,
      sortDataItem,
      translate,
      stylehead,
      stylecolumn
    });
  }
});
const _hoisted_1$k = { class: "nut-table" };
const _hoisted_2$h = { class: "nut-table__main__head" };
const _hoisted_3$h = { class: "nut-table__main__head__tr" };
const _hoisted_4$f = ["onClick"];
const _hoisted_5$9 = { class: "nut-table__main__body" };
const _hoisted_6$8 = { key: 1 };
const _hoisted_7$7 = {
  key: 0,
  class: "nut-table__nodata"
};
const _hoisted_8$4 = {
  key: 0,
  class: "nut-table__nodata__text"
};
const _hoisted_9$3 = {
  key: 1,
  class: "nut-table__summary"
};
const _hoisted_10$2 = ["innerHTML"];
function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_DownArrow = resolveComponent("DownArrow");
  const _component_RenderColumn = resolveComponent("RenderColumn");
  return openBlock(), createElementBlock("view", _hoisted_1$k, [
    createBaseVNode("view", {
      class: normalizeClass(["nut-table__main", { "nut-table__main--striped": _ctx.striped }])
    }, [
      createBaseVNode("view", _hoisted_2$h, [
        createBaseVNode("view", _hoisted_3$h, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.columns, (item) => {
            return openBlock(), createElementBlock("span", {
              key: item.key,
              class: normalizeClass(["nut-table__main__head__tr__th", _ctx.cellClasses(item)]),
              style: normalizeStyle(item.stylehead),
              onClick: ($event) => _ctx.handleSorterClick(item)
            }, [
              createTextVNode(toDisplayString(item.title) + " ", 1),
              renderSlot(_ctx.$slots, "icon"),
              !_ctx.$slots.icon && item.sorter ? (openBlock(), createBlock(_component_DownArrow, {
                key: 0,
                width: "12px",
                height: "12px"
              })) : createCommentVNode("", true)
            ], 14, _hoisted_4$f);
          }), 128))
        ])
      ]),
      createBaseVNode("view", _hoisted_5$9, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.curData, (item) => {
          return openBlock(), createElementBlock("view", {
            key: item,
            class: "nut-table__main__body__tr"
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.sortDataItem(), ([value, render]) => {
              return openBlock(), createElementBlock("span", {
                key: value,
                class: normalizeClass(["nut-table__main__body__tr__td", _ctx.cellClasses(_ctx.getColumnItem(value))]),
                style: normalizeStyle(_ctx.getColumnItemStyle(value))
              }, [
                typeof item[value] === "function" || typeof render === "function" ? (openBlock(), createBlock(_component_RenderColumn, {
                  key: 0,
                  slots: [render, item[value]],
                  record: item
                }, null, 8, ["slots", "record"])) : (openBlock(), createElementBlock("view", _hoisted_6$8, toDisplayString(item[value]), 1))
              ], 6);
            }), 128))
          ]);
        }), 128))
      ])
    ], 2),
    !_ctx.curData.length ? (openBlock(), createElementBlock("view", _hoisted_7$7, [
      createBaseVNode("div", {
        class: normalizeClass(["nut-table__nodata", { "nut-table__nodata--border": _ctx.bordered }])
      }, [
        renderSlot(_ctx.$slots, "nodata"),
        !_ctx.$slots.nodata ? (openBlock(), createElementBlock("div", _hoisted_8$4, toDisplayString(_ctx.translate("noData")), 1)) : createCommentVNode("", true)
      ], 2)
    ])) : createCommentVNode("", true),
    _ctx.summary ? (openBlock(), createElementBlock("view", _hoisted_9$3, [
      createBaseVNode("span", {
        class: "nut-table__summary__text",
        innerHTML: _ctx.summary().value
      }, null, 8, _hoisted_10$2)
    ])) : createCommentVNode("", true)
  ]);
}
const index$g = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["render", _sfc_render$j]]);
var __defProp$a = Object.defineProperty;
var __defProps$a = Object.defineProperties;
var __getOwnPropDescs$a = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$a = Object.getOwnPropertySymbols;
var __hasOwnProp$a = Object.prototype.hasOwnProperty;
var __propIsEnum$a = Object.prototype.propertyIsEnumerable;
var __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$a(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$a = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$a.call(b, prop))
      __defNormalProp$a(a2, prop, b[prop]);
  if (__getOwnPropSymbols$a)
    for (var prop of __getOwnPropSymbols$a(b)) {
      if (__propIsEnum$a.call(b, prop))
        __defNormalProp$a(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$a = (a2, b) => __defProps$a(a2, __getOwnPropDescs$a(b));
const _hoisted_1$j = { class: "nut-animate" };
const _sfc_main$l = /* @__PURE__ */ defineComponent(__spreadProps$a(__spreadValues$a({}, {
  name: "NutAnimate"
}), {
  __name: "animate",
  props: {
    type: {},
    show: { type: Boolean, default: false },
    action: { default: "" },
    loop: { type: Boolean, default: false },
    duration: { default: 500 }
  },
  emits: ["click", "animate"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit2 = __emit;
    const animated = ref(props.action === "initial" || props.show === true || props.loop);
    const classes = computed(() => {
      const prefixCls2 = "nut-animate";
      return {
        "nut-animate__container": true,
        [`${prefixCls2}-${props.type}`]: animated.value,
        loop: props.loop
      };
    });
    const animate = () => {
      animated.value = false;
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          animated.value = true;
        });
      });
    };
    const handleClick = (event) => {
      if (props.action === "click") {
        animate();
        emit2("click", event);
        emit2("animate");
      }
    };
    watch(
      () => props.show,
      (val) => {
        if (val) {
          animate();
          emit2("animate");
        }
      }
    );
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("view", _hoisted_1$j, [
        createBaseVNode("view", {
          class: normalizeClass(classes.value),
          style: normalizeStyle({
            animationDuration: _ctx.duration ? `${_ctx.duration}ms` : void 0
          }),
          onClick: handleClick
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 6)
      ]);
    };
  }
}));
withInstall(_sfc_main$l);
var __defProp$9 = Object.defineProperty;
var __defProps$9 = Object.defineProperties;
var __getOwnPropDescs$9 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;
var __hasOwnProp$9 = Object.prototype.hasOwnProperty;
var __propIsEnum$9 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$9 = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$9.call(b, prop))
      __defNormalProp$9(a2, prop, b[prop]);
  if (__getOwnPropSymbols$9)
    for (var prop of __getOwnPropSymbols$9(b)) {
      if (__propIsEnum$9.call(b, prop))
        __defNormalProp$9(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$9 = (a2, b) => __defProps$9(a2, __getOwnPropDescs$9(b));
const { create: create$i } = createComponent("ellipsis");
const _sfc_main$k = create$i({
  props: {
    content: {
      type: String,
      default: ""
    },
    direction: {
      type: String,
      default: "end"
    },
    rows: {
      type: [Number, String],
      default: 1
    },
    expandText: {
      type: String,
      default: ""
    },
    collapseText: {
      type: String,
      default: ""
    },
    symbol: {
      type: String,
      default: "..."
    },
    lineHeight: {
      type: [Number, String],
      default: "20"
    }
  },
  emits: ["click", "change"],
  setup(props, { emit: emit2 }) {
    const root = ref(null);
    let container = null;
    let maxHeight = 0;
    const ellipsis = ref();
    const state = reactive({
      exceeded: false,
      // 是否超出
      expanded: false
      // 是否折叠
    });
    watch(
      () => props.content,
      (newV, oldVal) => {
        if (newV != oldVal) {
          createContainer();
        }
      }
    );
    onMounted(() => {
      createContainer();
    });
    const createContainer = () => {
      if (!root.value) return;
      const originStyle = window.getComputedStyle(root.value);
      container = document.createElement("div");
      const styleNames = Array.prototype.slice.apply(originStyle);
      styleNames.forEach((name) => {
        container.style.setProperty(name, originStyle.getPropertyValue(name));
      });
      container.style.position = "fixed";
      container.style.left = "999999px";
      container.style.top = "999999px";
      container.style.zIndex = "-1000";
      container.style.height = "auto";
      container.style.minHeight = "auto";
      container.style.maxHeight = "auto";
      container.style.textOverflow = "clip";
      container.style.whiteSpace = "normal";
      container.style.webkitLineClamp = "unset";
      container.style.display = "block";
      const lineHeight = pxToNumber(originStyle.lineHeight === "normal" ? props.lineHeight : originStyle.lineHeight);
      maxHeight = Math.floor(
        lineHeight * (Number(props.rows) + 0.5) + pxToNumber(originStyle.paddingTop) + pxToNumber(originStyle.paddingBottom)
      );
      container.innerText = props.content;
      document.body.appendChild(container);
      calcEllipse();
    };
    const calcEllipse = () => {
      if (container.offsetHeight <= maxHeight) {
        state.exceeded = false;
        document.body.removeChild(container);
      } else {
        state.exceeded = true;
        const end = props.content.length;
        const middle = Math.floor((0 + end) / 2);
        const ellipsised = props.direction === "middle" ? tailorMiddle([0, middle], [middle, end]) : tailor(0, end);
        ellipsis.value = ellipsised;
        document.body.removeChild(container);
      }
    };
    const tailor = (left, right) => {
      const actionText = state.expanded ? props.collapseText : props.expandText;
      const end = props.content.length;
      if (right - left <= 1) {
        if (props.direction === "end") {
          return {
            leading: props.content.slice(0, left) + props.symbol
          };
        } else {
          return {
            tailing: props.symbol + props.content.slice(right, end)
          };
        }
      }
      const middle = Math.round((left + right) / 2);
      if (props.direction === "end") {
        container.innerText = props.content.slice(0, middle) + props.symbol + actionText;
      } else {
        container.innerText = actionText + props.symbol + props.content.slice(middle, end);
      }
      if (container.offsetHeight <= maxHeight) {
        if (props.direction === "end") {
          return tailor(middle, right);
        } else {
          return tailor(left, middle);
        }
      } else {
        if (props.direction === "end") {
          return tailor(left, middle);
        } else {
          return tailor(middle, right);
        }
      }
    };
    const tailorMiddle = (leftPart, rightPart) => {
      const actionText = state.expanded ? props.collapseText : props.expandText;
      const end = props.content.length;
      if (leftPart[1] - leftPart[0] <= 1 && rightPart[1] - rightPart[0] <= 1) {
        return {
          leading: props.content.slice(0, leftPart[0]) + props.symbol,
          tailing: props.symbol + props.content.slice(rightPart[1], end)
        };
      }
      const leftPartMiddle = Math.floor((leftPart[0] + leftPart[1]) / 2);
      const rightPartMiddle = Math.ceil((rightPart[0] + rightPart[1]) / 2);
      container.innerText = props.content.slice(0, leftPartMiddle) + props.symbol + actionText + props.symbol + props.content.slice(rightPartMiddle, end);
      if (container.offsetHeight <= maxHeight) {
        return tailorMiddle([leftPartMiddle, leftPart[1]], [rightPart[0], rightPartMiddle]);
      } else {
        return tailorMiddle([leftPart[0], leftPartMiddle], [rightPartMiddle, rightPart[1]]);
      }
    };
    const pxToNumber = (value) => {
      if (!value) return 0;
      const match = value.match(/^\d*(\.\d*)?/);
      return match ? Number(match[0]) : 0;
    };
    const clickHandle = (type) => {
      if (type == 1) {
        state.expanded = true;
        emit2("change", "expand");
      } else {
        state.expanded = false;
        emit2("change", "collapse");
      }
    };
    const handleClick = () => {
      emit2("click");
    };
    return __spreadProps$9(__spreadValues$9({}, toRefs(state)), { root, ellipsis, clickHandle, handleClick });
  }
});
const _hoisted_1$i = { key: 0 };
const _hoisted_2$g = { key: 1 };
const _hoisted_3$g = { key: 2 };
function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    ref: "root",
    class: "nut-ellipsis",
    onClick: _cache[2] || (_cache[2] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    !_ctx.exceeded ? (openBlock(), createElementBlock("view", _hoisted_1$i, toDisplayString(_ctx.content), 1)) : createCommentVNode("", true),
    _ctx.exceeded && !_ctx.expanded ? (openBlock(), createElementBlock("view", _hoisted_2$g, [
      createTextVNode(toDisplayString(_ctx.ellipsis && _ctx.ellipsis.leading), 1),
      _ctx.expandText ? (openBlock(), createElementBlock("span", {
        key: 0,
        class: "nut-ellipsis__text",
        onClick: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.clickHandle(1), ["stop"]))
      }, toDisplayString(_ctx.expandText), 1)) : createCommentVNode("", true),
      createTextVNode(toDisplayString(_ctx.ellipsis && _ctx.ellipsis.tailing), 1)
    ])) : createCommentVNode("", true),
    _ctx.exceeded && _ctx.expanded ? (openBlock(), createElementBlock("view", _hoisted_3$g, [
      createTextVNode(toDisplayString(_ctx.content) + " ", 1),
      _ctx.expandText ? (openBlock(), createElementBlock("span", {
        key: 0,
        class: "nut-ellipsis__text",
        onClick: _cache[1] || (_cache[1] = withModifiers(($event) => _ctx.clickHandle(2), ["stop"]))
      }, toDisplayString(_ctx.collapseText), 1)) : createCommentVNode("", true)
    ])) : createCommentVNode("", true)
  ], 512);
}
const index$f = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", _sfc_render$i]]);
var __defProp$8 = Object.defineProperty;
var __defProps$8 = Object.defineProperties;
var __getOwnPropDescs$8 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;
var __hasOwnProp$8 = Object.prototype.hasOwnProperty;
var __propIsEnum$8 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$8 = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$8.call(b, prop))
      __defNormalProp$8(a2, prop, b[prop]);
  if (__getOwnPropSymbols$8)
    for (var prop of __getOwnPropSymbols$8(b)) {
      if (__propIsEnum$8.call(b, prop))
        __defNormalProp$8(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$8 = (a2, b) => __defProps$8(a2, __getOwnPropDescs$8(b));
const _sfc_main$j = /* @__PURE__ */ defineComponent(__spreadProps$8(__spreadValues$8({}, {
  name: "NutWatermark"
}), {
  __name: "watermark",
  props: {
    gapX: { default: 24 },
    gapY: { default: 48 },
    zIndex: { default: 2e3 },
    width: { default: 120 },
    height: { default: 64 },
    rotate: { default: -22 },
    image: {},
    imageWidth: { default: 120 },
    imageHeight: { default: 64 },
    content: { default: "" },
    fontColor: { default: "rgba(0,0,0,.15)" },
    fontStyle: { default: "normal" },
    fontFamily: { default: "PingFang SC" },
    fontWeight: { default: "normal" },
    fontSize: { default: 14 },
    fullPage: { type: Boolean, default: true }
  },
  setup(__props) {
    const props = __props;
    const base64Url = ref("");
    const classes = computed(() => {
      const prefixCls2 = "nut-watermark";
      return {
        [prefixCls2]: true,
        [`${prefixCls2}-full-page`]: props.fullPage
      };
    });
    const init = () => {
      const canvas = document.createElement("canvas");
      const ratio = window.devicePixelRatio;
      const ctx = canvas.getContext("2d");
      const canvasWidth = `${(props.gapX + props.width) * ratio}px`;
      const canvasHeight = `${(props.gapY + props.height) * ratio}px`;
      const markWidth = props.width * ratio;
      const markHeight = props.height * ratio;
      canvas.setAttribute("width", canvasWidth);
      canvas.setAttribute("height", canvasHeight);
      if (ctx) {
        if (props.image) {
          ctx.translate(markWidth / 2, markHeight / 2);
          ctx.rotate(Math.PI / 180 * Number(props.rotate));
          const img = new Image();
          img.crossOrigin = "anonymous";
          img.referrerPolicy = "no-referrer";
          img.src = props.image;
          img.onload = () => {
            ctx.drawImage(
              img,
              -props.imageWidth * ratio / 2,
              -props.imageHeight * ratio / 2,
              props.imageWidth * ratio,
              props.imageHeight * ratio
            );
            ctx.restore();
            base64Url.value = canvas.toDataURL();
          };
        } else if (props.content) {
          ctx.textBaseline = "middle";
          ctx.textAlign = "center";
          ctx.translate(markWidth / 2, markHeight / 2);
          ctx.rotate(Math.PI / 180 * Number(props.rotate));
          const markSize = Number(props.fontSize) * ratio;
          ctx.font = `${props.fontStyle} normal ${props.fontWeight} ${markSize}px/${markHeight}px ${props.fontFamily}`;
          ctx.fillStyle = props.fontColor;
          if (Array.isArray(props.content)) {
            props.content.map((item, index2) => {
              ctx.fillText(item, 0, (index2 - 1) * markSize);
            });
          } else {
            ctx.fillText(props.content, 0, 0);
          }
          ctx.restore();
          base64Url.value = canvas.toDataURL();
        }
      } else {
        throw new Error("当前环境不支持Canvas");
      }
    };
    watchEffect(() => {
      init();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("view", {
        class: normalizeClass(classes.value),
        style: normalizeStyle({
          zIndex: _ctx.zIndex,
          backgroundSize: `${_ctx.gapX + _ctx.width}px`,
          backgroundImage: `url('${base64Url.value}')`
        })
      }, null, 6);
    };
  }
}));
withInstall(_sfc_main$j);
var __defProp$7 = Object.defineProperty;
var __defProps$7 = Object.defineProperties;
var __getOwnPropDescs$7 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;
var __hasOwnProp$7 = Object.prototype.hasOwnProperty;
var __propIsEnum$7 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$7 = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$7.call(b, prop))
      __defNormalProp$7(a2, prop, b[prop]);
  if (__getOwnPropSymbols$7)
    for (var prop of __getOwnPropSymbols$7(b)) {
      if (__propIsEnum$7.call(b, prop))
        __defNormalProp$7(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$7 = (a2, b) => __defProps$7(a2, __getOwnPropDescs$7(b));
const _hoisted_1$h = { class: "nut-trend-arrow" };
const _sfc_main$i = /* @__PURE__ */ defineComponent(__spreadProps$7(__spreadValues$7({}, {
  name: "NutTrendArrow"
}), {
  __name: "trend-arrow",
  props: {
    rate: { default: 0 },
    digits: { default: 2 },
    showSign: { type: Boolean, default: false },
    showZero: { type: Boolean, default: false },
    arrowLeft: { type: Boolean, default: false },
    syncTextColor: { type: Boolean, default: true },
    textColor: { default: "#333" },
    riseColor: { default: "#fa2c19" },
    dropColor: { default: "#64b578" }
  },
  setup(__props) {
    const props = __props;
    const isPositive = computed(() => {
      return props.rate > 0 ? true : false;
    });
    const calcRate = computed(() => {
      const absRate = Math.abs(props.rate);
      if (!props.showZero && props.rate === 0) {
        return "--";
      }
      let resultRate = `${props.showSign && props.rate !== 0 ? isPositive.value ? "+" : "-" : ""}${myFixed(
        Number(absRate),
        props.digits
      )}%`;
      return resultRate;
    });
    const calcStyle = computed(() => {
      return {
        color: props.rate === 0 ? props.textColor : props.syncTextColor ? isPositive.value ? props.riseColor : props.dropColor : props.textColor
      };
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("view", _hoisted_1$h, [
        !_ctx.arrowLeft ? (openBlock(), createElementBlock("span", {
          key: 0,
          class: "nut-trend-arrow-icon-before nut-trend-arrow-rate",
          style: normalizeStyle(calcStyle.value)
        }, toDisplayString(calcRate.value), 5)) : createCommentVNode("", true),
        Number(_ctx.rate) !== 0 && isPositive.value ? renderSlot(_ctx.$slots, "up-icon", { key: 1 }, () => [
          createVNode(unref(v), { color: _ctx.riseColor }, null, 8, ["color"])
        ]) : createCommentVNode("", true),
        Number(_ctx.rate) !== 0 && !isPositive.value ? renderSlot(_ctx.$slots, "down-icon", { key: 2 }, () => [
          createVNode(unref(v$1), { color: _ctx.dropColor }, null, 8, ["color"])
        ]) : createCommentVNode("", true),
        _ctx.arrowLeft ? (openBlock(), createElementBlock("span", {
          key: 3,
          class: "nut-trend-arrow-icon-after nut-trend-arrow-rate",
          style: normalizeStyle(calcStyle.value)
        }, toDisplayString(calcRate.value), 5)) : createCommentVNode("", true)
      ]);
    };
  }
}));
withInstall(_sfc_main$i);
var __defProp$6 = Object.defineProperty;
var __defProps$6 = Object.defineProperties;
var __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;
var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
var __propIsEnum$6 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$6 = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$6.call(b, prop))
      __defNormalProp$6(a2, prop, b[prop]);
  if (__getOwnPropSymbols$6)
    for (var prop of __getOwnPropSymbols$6(b)) {
      if (__propIsEnum$6.call(b, prop))
        __defNormalProp$6(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$6 = (a2, b) => __defProps$6(a2, __getOwnPropDescs$6(b));
const { create: create$h } = createComponent("tour");
const _sfc_main$h = create$h({
  components: {
    NutPopover,
    Close: g$4
  },
  props: {
    modelValue: { type: Boolean, default: false },
    type: {
      type: String,
      default: "step"
    },
    steps: {
      type: Array,
      default: () => []
    },
    location: {
      type: String,
      default: "bottom"
    },
    current: {
      type: Number,
      default: 0
    },
    nextStepTxt: {
      type: String,
      default: "下一步"
    },
    prevStepTxt: {
      type: String,
      default: "上一步"
    },
    completeTxt: {
      type: String,
      default: "完成"
    },
    mask: {
      type: Boolean,
      default: true
    },
    offset: {
      type: Array,
      default: [8, 10]
    },
    bgColor: {
      type: String,
      default: ""
    },
    theme: {
      type: String,
      default: "light"
    },
    maskWidth: {
      type: [Number, String],
      default: ""
    },
    maskHeight: {
      type: [Number, String],
      default: ""
    },
    closeOnClickOverlay: {
      type: Boolean,
      default: true
    },
    showPrevStep: {
      type: Boolean,
      default: true
    },
    showTitleBar: {
      type: Boolean,
      default: true
    }
  },
  emits: ["update:modelValue", "change", "close"],
  setup(props, { emit: emit2 }) {
    const state = reactive({
      showTour: props.modelValue,
      showPopup: false,
      active: 0
    });
    const maskRect = ref({});
    const classes = computed(() => {
      const prefixCls2 = "nut-tour";
      return `${prefixCls2}`;
    });
    const maskStyle = computed(() => {
      const { offset, maskWidth, maskHeight } = props;
      const { width, height, left, top } = maskRect.value;
      const center = [left + width / 2, top + height / 2];
      const w2 = Number(maskWidth ? maskWidth : width);
      const h2 = Number(maskHeight ? maskHeight : height);
      const styles = {
        width: `${w2 + +offset[1] * 2}px`,
        height: `${h2 + +offset[0] * 2}px`,
        top: `${center[1] - h2 / 2 - +offset[0]}px`,
        left: `${center[0] - w2 / 2 - +offset[1]}px`
      };
      return styles;
    });
    const changeStep = (type) => {
      if (type == "next") {
        state.active = state.active + 1;
      } else {
        state.active = state.active - 1;
      }
      state.showPopup = false;
      nextTick(() => {
        state.showPopup = true;
        getRootPosition();
      });
      emit2("change", state.active);
    };
    const getRootPosition = () => {
      const el = document.querySelector(`#${props.steps[state.active].target}`);
      const rect = useRect(el);
      maskRect.value = rect;
    };
    const close = () => {
      state.showTour = false;
      state.showPopup = false;
      emit2("close", state.active);
      emit2("update:modelValue", false);
    };
    const handleClickMask = () => {
      props.closeOnClickOverlay && close();
    };
    onMounted(() => {
      state.active = 0;
      getRootPosition();
    });
    watch(
      () => props.modelValue,
      (val) => {
        if (val) {
          getRootPosition();
        }
        state.active = 0;
        state.showTour = val;
        state.showPopup = val;
      }
    );
    return __spreadProps$6(__spreadValues$6({}, toRefs(state)), {
      classes,
      maskStyle,
      changeStep,
      close,
      handleClickMask
    });
  }
});
const _hoisted_1$g = {
  key: 0,
  class: "nut-tour-content"
};
const _hoisted_2$f = {
  key: 0,
  class: "nut-tour-content-top"
};
const _hoisted_3$f = { class: "nut-tour-content-inner" };
const _hoisted_4$e = { class: "nut-tour-content-bottom" };
const _hoisted_5$8 = { class: "nut-tour-content-bottom-init" };
const _hoisted_6$7 = { class: "nut-tour-content-bottom-operate" };
const _hoisted_7$6 = {
  key: 1,
  class: "nut-tour-content nut-tour-content-tile"
};
const _hoisted_8$3 = { class: "nut-tour-content-inner" };
function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Close = resolveComponent("Close");
  const _component_nut_popover = resolveComponent("nut-popover");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classes)
  }, [
    withDirectives(createBaseVNode("div", {
      class: "nut-tour-masked",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClickMask && _ctx.handleClickMask(...args))
    }, null, 512), [
      [vShow, _ctx.showTour]
    ]),
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.steps, (step, i2) => {
      return openBlock(), createElementBlock("div", {
        key: i2,
        style: { "height": "0" }
      }, [
        i2 == _ctx.active ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          _ctx.showTour ? (openBlock(), createElementBlock("div", {
            key: 0,
            id: "nut-tour-popid",
            class: normalizeClass(["nut-tour-mask", [_ctx.mask ? "" : "nut-tour-mask-none"]]),
            style: normalizeStyle(_ctx.maskStyle)
          }, null, 6)) : createCommentVNode("", true),
          createVNode(_component_nut_popover, {
            visible: _ctx.showPopup,
            "onUpdate:visible": _cache[5] || (_cache[5] = ($event) => _ctx.showPopup = $event),
            location: step.location || _ctx.location,
            "target-id": "nut-tour-popid",
            "bg-color": _ctx.bgColor,
            theme: _ctx.theme,
            "close-on-click-outside": false,
            offset: step.popoverOffset || [0, 12],
            "arrow-offset": step.arrowOffset || 0
          }, {
            content: withCtx(() => [
              renderSlot(_ctx.$slots, "default", {}, () => [
                _ctx.type == "step" ? (openBlock(), createElementBlock("div", _hoisted_1$g, [
                  _ctx.showTitleBar ? (openBlock(), createElementBlock("div", _hoisted_2$f, [
                    createBaseVNode("div", {
                      onClick: _cache[1] || (_cache[1] = (...args) => _ctx.close && _ctx.close(...args))
                    }, [
                      createVNode(_component_Close, { class: "nut-tour-content-top-close" })
                    ])
                  ])) : createCommentVNode("", true),
                  createBaseVNode("div", _hoisted_3$f, toDisplayString(step.content), 1),
                  createBaseVNode("div", _hoisted_4$e, [
                    createBaseVNode("div", _hoisted_5$8, toDisplayString(_ctx.active + 1) + "/" + toDisplayString(_ctx.steps.length), 1),
                    createBaseVNode("div", _hoisted_6$7, [
                      renderSlot(_ctx.$slots, "prev-step", {}, () => [
                        _ctx.active != 0 && _ctx.showPrevStep ? (openBlock(), createElementBlock("div", {
                          key: 0,
                          class: "nut-tour-content-bottom-operate-btn",
                          onClick: _cache[2] || (_cache[2] = ($event) => _ctx.changeStep("prev"))
                        }, toDisplayString(_ctx.prevStepTxt), 1)) : createCommentVNode("", true)
                      ]),
                      _ctx.steps.length - 1 == _ctx.active ? (openBlock(), createElementBlock("div", {
                        key: 0,
                        class: "nut-tour-content-bottom-operate-btn active",
                        onClick: _cache[3] || (_cache[3] = (...args) => _ctx.close && _ctx.close(...args))
                      }, toDisplayString(_ctx.completeTxt), 1)) : createCommentVNode("", true),
                      renderSlot(_ctx.$slots, "next-step", {}, () => [
                        _ctx.steps.length - 1 != _ctx.active ? (openBlock(), createElementBlock("div", {
                          key: 0,
                          class: "nut-tour-content-bottom-operate-btn active",
                          onClick: _cache[4] || (_cache[4] = ($event) => _ctx.changeStep("next"))
                        }, toDisplayString(_ctx.nextStepTxt), 1)) : createCommentVNode("", true)
                      ])
                    ])
                  ])
                ])) : createCommentVNode("", true),
                _ctx.type == "tile" ? (openBlock(), createElementBlock("div", _hoisted_7$6, [
                  createBaseVNode("div", _hoisted_8$3, toDisplayString(step.content), 1)
                ])) : createCommentVNode("", true)
              ])
            ]),
            _: 2
          }, 1032, ["visible", "location", "bg-color", "theme", "offset", "arrow-offset"])
        ], 64)) : createCommentVNode("", true)
      ]);
    }), 128))
  ], 2);
}
const index$e = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$h]]);
var __defProp$5 = Object.defineProperty;
var __defProps$5 = Object.defineProperties;
var __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;
var __hasOwnProp$5 = Object.prototype.hasOwnProperty;
var __propIsEnum$5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$5 = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$5.call(b, prop))
      __defNormalProp$5(a2, prop, b[prop]);
  if (__getOwnPropSymbols$5)
    for (var prop of __getOwnPropSymbols$5(b)) {
      if (__propIsEnum$5.call(b, prop))
        __defNormalProp$5(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$5 = (a2, b) => __defProps$5(a2, __getOwnPropDescs$5(b));
const { create: create$g } = createComponent("address");
const cN$7 = "NutAddress";
const _sfc_main$g = create$g({
  components: {
    NutPopup,
    NutElevator,
    Location: S,
    Location2: w$6,
    Check: g$6,
    Close: g$4,
    Left: v$7
  },
  inheritAttrs: false,
  props: __spreadProps$5(__spreadValues$5({}, popupProps), {
    modelValue: {
      type: Array,
      default: () => []
    },
    type: {
      type: String,
      default: "custom"
    },
    customAddressTitle: {
      type: String,
      default: ""
    },
    province: {
      type: Array,
      default: () => []
    },
    city: {
      type: Array,
      default: () => []
    },
    // 市
    country: {
      type: Array,
      default: () => []
    },
    // 县
    town: {
      type: Array,
      default: () => []
    },
    // 镇
    isShowCustomAddress: {
      type: Boolean,
      default: true
    },
    existAddress: {
      type: Array,
      default: () => []
    },
    existAddressTitle: {
      type: String,
      default: ""
    },
    customAndExistTitle: {
      type: String,
      default: ""
    },
    height: {
      type: [String, Number],
      default: "200px"
    },
    columnsPlaceholder: {
      type: [String, Array],
      default: ""
    }
  }),
  emits: ["update:visible", "update:modelValue", "type", "change", "selected", "close", "closeMask", "switchModule"],
  setup(props, { emit: emit2 }) {
    const translate = useLocale(cN$7);
    const regionLine = ref(null);
    const tabRegion = ref(null);
    const showPopup = ref(props.visible);
    const privateType = ref(props.type);
    const tabIndex = ref(0);
    const prevTabIndex = ref(0);
    const tabName = ref(["province", "city", "country", "town"]);
    const scrollDom = ref(null);
    const scrollDis = ref([0, 0, 0, 0]);
    const regionData = reactive([]);
    const regionList = computed(() => {
      switch (tabIndex.value) {
        case 0:
          return props.province;
        case 1:
          return props.city;
        case 2:
          return props.country;
        default:
          return props.town;
      }
    });
    const transformData = (data) => {
      if (!Array.isArray(data)) throw new TypeError("params muse be array.");
      if (!data.length) return [];
      data.forEach((item) => {
        if (!item.title) {
          console.warn("[NutUI] <Address> 请检查数组选项的 title 值是否有设置 ,title 为必填项 .");
          return;
        }
      });
      const newData = [];
      data = data.sort((a2, b) => a2.title.localeCompare(b.title));
      data.forEach((item) => {
        const index2 = newData.findIndex((value) => value.title === item.title);
        if (index2 <= -1) {
          newData.push({
            title: item.title,
            list: [].concat(item)
          });
        } else {
          newData[index2].list.push(item);
        }
      });
      return newData;
    };
    let selectedRegion = ref([]);
    let selectedExistAddress = reactive({});
    const closeWay = ref("self");
    const lineDistance = ref(20);
    const initCustomSelected = () => {
      regionData[0] = props.province || [];
      regionData[1] = props.city || [];
      regionData[2] = props.country || [];
      regionData[3] = props.town || [];
      const defaultValue = props.modelValue;
      const num = defaultValue.length;
      if (num > 0) {
        tabIndex.value = num - 1;
        if (regionList.value.length == 0) {
          tabIndex.value = 0;
          return;
        }
        for (let index2 = 0; index2 < num; index2++) {
          let arr = regionData[index2];
          selectedRegion.value[index2] = arr.filter((item) => item.id == defaultValue[index2])[0];
        }
        lineAnimation();
      }
    };
    const getTabName = (item, index2) => {
      if (item && item.name) return item.name;
      if (tabIndex.value < index2 && item) {
        return item.name;
      } else {
        return props.columnsPlaceholder[index2] || translate("select");
      }
    };
    const lineAnimation = () => {
      scrollTo();
      nextTick(() => {
        const name = tabRegion.value && tabRegion.value.getElementsByClassName("active")[0];
        if (name) {
          const distance = name.offsetLeft;
          lineDistance.value = distance ? distance : 20;
        }
      });
    };
    const nextAreaList = (item) => {
      var _a;
      const tab = tabIndex.value;
      prevTabIndex.value = tabIndex.value;
      const callBackParams = {
        custom: tabName.value[tab]
      };
      selectedRegion.value[tab] = item;
      selectedRegion.value.splice(tab + 1, selectedRegion.value.length - (tab + 1));
      callBackParams.value = item;
      if (((_a = regionData[tab + 1]) == null ? void 0 : _a.length) > 0) {
        tabIndex.value = tab + 1;
        lineAnimation();
        callBackParams.next = tabName.value[tabIndex.value];
      } else {
        handClose();
        emit2("update:modelValue");
      }
      emit2("change", callBackParams);
    };
    const changeRegionTab = (item, index2) => {
      prevTabIndex.value = tabIndex.value;
      if (getTabName(item, index2)) {
        tabIndex.value = index2;
        lineAnimation();
      }
    };
    const scrollTo = () => {
      const dom = scrollDom.value;
      const prev = prevTabIndex.value;
      const cur = scrollDis.value[tabIndex.value];
      (dom == null ? void 0 : dom.scrollTop) && (scrollDis.value[prev] = dom == null ? void 0 : dom.scrollTop);
      nextTick(() => {
        dom == null ? void 0 : dom.scrollTo({
          top: cur,
          behavior: "auto"
        });
      });
    };
    const selectedExist = (item) => {
      const copyExistAdd = props.existAddress;
      let prevExistAdd = {};
      copyExistAdd.forEach((list) => {
        if (list && list.selectedAddress) prevExistAdd = list;
        list.selectedAddress = false;
      });
      item.selectedAddress = true;
      selectedExistAddress = item;
      emit2("selected", prevExistAdd, item, copyExistAdd);
      handClose();
    };
    const initAddress = () => {
      selectedRegion.value = [];
      tabIndex.value = 0;
      lineAnimation();
    };
    const handClose = (type = "self") => {
      closeWay.value = type == "cross" ? "cross" : "self";
      showPopup.value = false;
    };
    const clickOverlay = () => {
      closeWay.value = "mask";
    };
    const close = () => {
      const data = {
        addressIdStr: "",
        addressStr: "",
        province: selectedRegion.value[0],
        city: selectedRegion.value[1],
        country: selectedRegion.value[2],
        town: selectedRegion.value[3]
      };
      const callBackParams = {
        data: {},
        type: privateType.value
      };
      if (["custom", "custom2"].includes(privateType.value)) {
        [0, 1, 2, 3].forEach((i2) => {
          const item = selectedRegion.value[i2];
          data.addressIdStr += `${i2 ? "_" : ""}${item && item.id || 0}`;
          data.addressStr += item && item.name || "";
        });
        callBackParams.data = data;
      } else {
        callBackParams.data = selectedExistAddress;
      }
      initAddress();
      if (closeWay.value == "self") {
        emit2("close", callBackParams);
      } else {
        emit2("closeMask", { closeWay });
      }
      emit2("update:visible", false);
    };
    const switchModule = () => {
      const type = privateType.value;
      privateType.value = type == "exist" ? "custom" : "exist";
      initAddress();
      emit2("switchModule", { type: privateType.value });
    };
    const handleElevatorItem = (key, item) => {
      nextAreaList(item);
    };
    watch(
      () => props.visible,
      (value) => {
        showPopup.value = value;
      }
    );
    watch(
      () => showPopup.value,
      (value) => {
        if (value) {
          initCustomSelected();
        }
      }
    );
    return __spreadProps$5(__spreadValues$5({
      showPopup,
      privateType,
      tabIndex,
      tabName,
      selectedRegion,
      switchModule,
      closeWay,
      close,
      getTabName,
      nextAreaList,
      regionLine,
      tabRegion,
      lineDistance,
      changeRegionTab,
      selectedExist,
      clickOverlay,
      handClose,
      handleElevatorItem,
      initCustomSelected
    }, toRefs(props)), {
      translate,
      regionList,
      transformData,
      scrollDom
    });
  }
});
const _hoisted_1$f = { class: "nut-address" };
const _hoisted_2$e = { class: "nut-address__header" };
const _hoisted_3$e = { class: "nut-address__header__title" };
const _hoisted_4$d = {
  key: 0,
  class: "nut-address__custom"
};
const _hoisted_5$7 = {
  ref: "tabRegion",
  class: "nut-address__region"
};
const _hoisted_6$6 = ["onClick"];
const _hoisted_7$5 = {
  key: 0,
  class: "active nut-address__region-item"
};
const _hoisted_8$2 = {
  key: 0,
  class: "nut-address__detail"
};
const _hoisted_9$2 = {
  ref: "scrollDom",
  class: "nut-address__detail-list"
};
const _hoisted_10$1 = ["onClick"];
const _hoisted_11$1 = {
  key: 1,
  class: "nut-address__elevator-group"
};
const _hoisted_12$1 = {
  key: 1,
  class: "nut-address__exist"
};
const _hoisted_13$1 = { class: "nut-address__exist-group" };
const _hoisted_14$1 = { class: "nut-address__exist-group-list" };
const _hoisted_15 = ["onClick"];
const _hoisted_16 = { class: "nut-address__exist-item-info" };
const _hoisted_17 = {
  key: 0,
  class: "nut-address__exist-item-info-name"
};
const _hoisted_18 = {
  key: 1,
  class: "nut-address__exist-item-info-phone"
};
const _hoisted_19 = { class: "nut-address__exist-item-info-bottom" };
const _hoisted_20 = { class: "nut-address__exist-choose-btn" };
function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Left = resolveComponent("Left");
  const _component_Close = resolveComponent("Close");
  const _component_Check = resolveComponent("Check");
  const _component_nut_elevator = resolveComponent("nut-elevator");
  const _component_Location2 = resolveComponent("Location2");
  const _component_nut_popup = resolveComponent("nut-popup");
  return openBlock(), createBlock(_component_nut_popup, {
    visible: _ctx.showPopup,
    "onUpdate:visible": _cache[3] || (_cache[3] = ($event) => _ctx.showPopup = $event),
    position: "bottom",
    "lock-scroll": _ctx.lockScroll,
    round: _ctx.round,
    "teleport-disable": _ctx.teleportDisable,
    teleport: _ctx.teleport,
    "z-index": _ctx.zIndex,
    onClose: _ctx.close,
    onClickOverlay: _ctx.clickOverlay,
    onOpen: _cache[4] || (_cache[4] = ($event) => _ctx.closeWay = "self")
  }, {
    default: withCtx(() => [
      createBaseVNode("view", _hoisted_1$f, [
        createBaseVNode("view", _hoisted_2$e, [
          createBaseVNode("view", {
            class: "nut-address__header-back",
            onClick: _cache[0] || (_cache[0] = (...args) => _ctx.switchModule && _ctx.switchModule(...args))
          }, [
            renderSlot(_ctx.$slots, "back-icon", {}, () => [
              withDirectives(createVNode(_component_Left, { size: "14px" }, null, 512), [
                [vShow, _ctx.type == "exist" && _ctx.privateType == "custom"]
              ])
            ])
          ]),
          createBaseVNode("view", _hoisted_3$e, toDisplayString(_ctx.privateType == "custom" ? _ctx.customAddressTitle || _ctx.translate("selectRegion") : _ctx.existAddressTitle || _ctx.translate("deliveryTo")), 1),
          createBaseVNode("view", {
            class: "nut-address__header-close",
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.handClose("cross"))
          }, [
            renderSlot(_ctx.$slots, "close-icon", {}, () => [
              createVNode(_component_Close, {
                color: "#cccccc",
                size: "14px"
              })
            ])
          ])
        ]),
        ["custom", "custom2"].includes(_ctx.privateType) ? (openBlock(), createElementBlock("view", _hoisted_4$d, [
          createBaseVNode("view", _hoisted_5$7, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.selectedRegion, (item, index2) => {
              return openBlock(), createElementBlock("view", {
                key: index2,
                class: normalizeClass(["nut-address__region-item", index2 == _ctx.tabIndex ? "active" : ""]),
                onClick: ($event) => _ctx.changeRegionTab(item, index2)
              }, [
                createBaseVNode("view", null, toDisplayString(_ctx.getTabName(item, index2)), 1)
              ], 10, _hoisted_6$6);
            }), 128)),
            _ctx.tabIndex == _ctx.selectedRegion.length ? (openBlock(), createElementBlock("view", _hoisted_7$5, [
              createBaseVNode("view", null, toDisplayString(_ctx.getTabName(null, _ctx.selectedRegion.length)), 1)
            ])) : createCommentVNode("", true),
            createBaseVNode("view", {
              ref: "regionLine",
              class: "nut-address__region-line",
              style: normalizeStyle({ left: _ctx.lineDistance + "px" })
            }, null, 4)
          ], 512),
          _ctx.privateType == "custom" ? (openBlock(), createElementBlock("view", _hoisted_8$2, [
            createBaseVNode("ul", _hoisted_9$2, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.regionList, (item, index2) => {
                var _a, _b;
                return openBlock(), createElementBlock("li", {
                  key: index2,
                  class: normalizeClass(["nut-address__detail-item", ((_a = _ctx.selectedRegion[_ctx.tabIndex]) == null ? void 0 : _a.id) == item.id ? "active" : ""]),
                  onClick: ($event) => _ctx.nextAreaList(item)
                }, [
                  createBaseVNode("div", null, [
                    ((_b = _ctx.selectedRegion[_ctx.tabIndex]) == null ? void 0 : _b.id) == item.id ? renderSlot(_ctx.$slots, "icon", { key: 0 }, () => [
                      createVNode(_component_Check, {
                        class: "nut-address-select-icon",
                        size: "13px"
                      })
                    ]) : createCommentVNode("", true),
                    createTextVNode(" " + toDisplayString(item.name), 1)
                  ])
                ], 10, _hoisted_10$1);
              }), 128))
            ], 512)
          ])) : (openBlock(), createElementBlock("view", _hoisted_11$1, [
            createVNode(_component_nut_elevator, {
              height: _ctx.height,
              "index-list": _ctx.transformData(_ctx.regionList),
              onClickItem: _ctx.handleElevatorItem
            }, null, 8, ["height", "index-list", "onClickItem"])
          ]))
        ])) : (openBlock(), createElementBlock("view", _hoisted_12$1, [
          createBaseVNode("div", _hoisted_13$1, [
            createBaseVNode("ul", _hoisted_14$1, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.existAddress, (item, index2) => {
                return openBlock(), createElementBlock("li", {
                  key: index2,
                  class: normalizeClass(["nut-address__exist-group-item", item.selectedAddress ? "active" : ""]),
                  onClick: ($event) => _ctx.selectedExist(item)
                }, [
                  !item.selectedAddress ? renderSlot(_ctx.$slots, "unselected-icon", { key: 0 }, () => [
                    createVNode(_component_Location2, {
                      class: "nut-address-select-icon",
                      size: "13px"
                    })
                  ]) : createCommentVNode("", true),
                  item.selectedAddress ? renderSlot(_ctx.$slots, "icon", { key: 1 }, () => [
                    createVNode(_component_Check, {
                      class: "nut-address-select-icon",
                      size: "13px"
                    })
                  ]) : createCommentVNode("", true),
                  createBaseVNode("div", _hoisted_16, [
                    item.name ? (openBlock(), createElementBlock("div", _hoisted_17, toDisplayString(item.name), 1)) : createCommentVNode("", true),
                    item.phone ? (openBlock(), createElementBlock("div", _hoisted_18, toDisplayString(item.phone), 1)) : createCommentVNode("", true),
                    createBaseVNode("div", _hoisted_19, [
                      createBaseVNode("view", null, toDisplayString(item.provinceName + item.cityName + item.countyName + item.townName + item.addressDetail), 1)
                    ])
                  ])
                ], 10, _hoisted_15);
              }), 128))
            ])
          ]),
          _ctx.isShowCustomAddress ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: "nut-address__exist-choose",
            onClick: _cache[2] || (_cache[2] = (...args) => _ctx.switchModule && _ctx.switchModule(...args))
          }, [
            createBaseVNode("div", _hoisted_20, toDisplayString(_ctx.customAndExistTitle || _ctx.translate("chooseAnotherAddress")), 1)
          ])) : createCommentVNode("", true)
        ])),
        renderSlot(_ctx.$slots, "bottom")
      ])
    ]),
    _: 3
  }, 8, ["visible", "lock-scroll", "round", "teleport-disable", "teleport", "z-index", "onClose", "onClickOverlay"]);
}
const index$d = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$g]]);
const { create: create$f } = createComponent("barrage");
const _sfc_main$f = create$f({
  name: "barrage",
  props: {
    danmu: {
      type: Array,
      default: () => []
    },
    frequency: {
      type: Number,
      default: 500
    },
    speeds: {
      type: Number,
      default: 5e3
    },
    rows: {
      type: Number,
      default: 3
    },
    top: {
      type: Number,
      default: 10
    },
    loop: {
      type: Boolean,
      default: true
    }
  },
  setup(props) {
    const classTime = (/* @__PURE__ */ new Date()).getTime();
    const slotDefault = !!useSlots().default;
    let dmBody = ref(document.createElement("div"));
    let dmContainer = ref(document.createElement("div"));
    let timer = null;
    const danmuList = ref(props.danmu);
    const rows = ref(props.rows);
    const top = ref(props.top);
    const index2 = ref(0);
    const speeds = props.speeds;
    const danmuCWidth = ref(0);
    onMounted(() => {
      init();
      if (slotDefault) {
        document.addEventListener("visibilitychange", function() {
          if (document.visibilityState === "hidden") {
            clearTime();
            index2.value = 0;
            eleSlot("hidden");
          } else if (document.visibilityState === "visible") {
            init();
          }
        });
      }
    });
    onUnmounted(() => {
      danmuList.value = [];
      clearTime();
    });
    const init = () => {
      danmuCWidth.value = dmBody.value.offsetWidth;
      if (slotDefault) {
        eleSlot("init");
      }
      setTimeout(() => {
        var _a;
        (_a = dmBody.value) == null ? void 0 : _a.style.setProperty("--move-distance", `-${danmuCWidth.value}px`);
        run();
      }, 300);
    };
    const eleSlot = (flag) => {
      var _a;
      const list = document.getElementsByClassName("slotBody" + classTime);
      let childrens = ((_a = list == null ? void 0 : list[0]) == null ? void 0 : _a.children) || [];
      const dmList = [];
      {
        Array.from(childrens).forEach((item) => {
          if (flag == "init") {
            item.style.opacity = "0";
            dmList.push(item);
          } else {
            item.classList = "";
            item.style = {};
          }
        });
      }
      if (flag == "init") {
        danmuList.value = dmList;
      }
    };
    const clearTime = () => {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }
    };
    watch(
      () => props.danmu,
      (newValue) => {
        if (props.danmu.length > 0) {
          danmuList.value = [...newValue];
        }
      }
    );
    const add = (word) => {
      const _index = index2.value % danmuList.value.length;
      if (!props.loop && index2.value === danmuList.value.length) {
        danmuList.value.splice(danmuList.value.length, 0, word);
      } else {
        danmuList.value.splice(_index, 0, word);
      }
    };
    const run = () => {
      clearTime();
      timer = setTimeout(() => {
        play();
      }, props.frequency);
    };
    const play = () => {
      var _a;
      const _index = props.loop ? index2.value % danmuList.value.length : index2.value;
      let el = document.createElement(`view`);
      if (slotDefault && typeof danmuList.value[_index] == "object") {
        el = danmuList.value[_index];
        (_a = el == null ? void 0 : el.classList) == null ? void 0 : _a.add("nut-barrage__item");
      } else {
        el.innerHTML = danmuList.value[_index];
        el.classList.add("nut-barrage__item");
        dmContainer.value.appendChild(el);
      }
      nextTick(() => {
        var _a2;
        const height = el.offsetHeight;
        (_a2 = el == null ? void 0 : el.classList) == null ? void 0 : _a2.add("move");
        el.style.animationDuration = `${speeds}ms`;
        el.style.top = _index % rows.value * (height + top.value) + 20 + "px";
        el.style.opacity = "1";
        if (!slotDefault) {
          const width = el.offsetWidth;
          el.style.width = width + 20 + "px";
        }
        el.addEventListener("animationend", () => {
          if (slotDefault) {
            el.classList.remove("move");
          } else {
            dmContainer.value.removeChild(el);
          }
        });
        if (!props.loop && index2.value >= danmuList.value.length - 1) {
          return;
        }
        index2.value++;
        if (index2.value >= danmuList.value.length) {
          index2.value = 0;
        }
        el.removeEventListener("animationend", () => {
        });
        run();
      });
    };
    return { classTime, danmuList, dmBody, dmContainer, add };
  }
});
const _hoisted_1$e = {
  ref: "dmBody",
  class: "nut-barrage"
};
function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$e, [
    createBaseVNode("div", {
      ref: "dmContainer",
      class: normalizeClass(["dmContainer", _ctx.$slots.default && "slotContainer"])
    }, [
      _ctx.$slots.default ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(["slotBody", "slotBody" + _ctx.classTime])
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 2)) : createCommentVNode("", true)
    ], 2)
  ], 512);
}
const index$c = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$f]]);
var __defProp$4 = Object.defineProperty;
var __defProps$4 = Object.defineProperties;
var __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;
var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
var __propIsEnum$4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$4 = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$4.call(b, prop))
      __defNormalProp$4(a2, prop, b[prop]);
  if (__getOwnPropSymbols$4)
    for (var prop of __getOwnPropSymbols$4(b)) {
      if (__propIsEnum$4.call(b, prop))
        __defNormalProp$4(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$4 = (a2, b) => __defProps$4(a2, __getOwnPropDescs$4(b));
const { create: create$e } = createComponent("signature");
const cN$6 = "NutSignature";
const _sfc_main$e = create$e({
  props: {
    customClass: {
      type: String,
      default: ""
    },
    lineWidth: {
      type: Number,
      default: 2
    },
    strokeStyle: {
      type: String,
      default: () => {
        let bodyDom = document.getElementsByTagName("body");
        let clsName = bodyDom[0]["className"];
        if (clsName.indexOf("nut-theme-dark") == -1) {
          return "#000";
        } else {
          return "#fff";
        }
      }
    },
    type: {
      type: String,
      default: "png"
    },
    unSupportTpl: {
      type: String,
      default: ""
    }
  },
  components: {
    NutButton: _sfc_main$1G
  },
  emits: ["start", "end", "signing", "confirm", "clear"],
  setup(props, { emit: emit2 }) {
    const translate = useLocale(cN$6);
    const canvas = ref(null);
    const wrap = ref(null);
    const classes = computed(() => {
      const prefixCls2 = "nut-signature";
      return {
        [prefixCls2]: true,
        [`${props.customClass}`]: props.customClass
      };
    });
    const state = reactive({
      canvasHeight: 0,
      canvasWidth: 0,
      ctx: null,
      isSupportTouch: "ontouchstart" in window,
      events: "ontouchstart" in window ? ["touchstart", "touchmove", "touchend", "touchleave"] : ["mousedown", "mousemove", "mouseup", "mouseleave"]
    });
    const isCanvasSupported = () => {
      let elem = document.createElement("canvas");
      return !!(elem.getContext && elem.getContext("2d"));
    };
    const addEvent = () => {
      canvas.value.addEventListener(state.events[0], startEventHandler, false);
    };
    const startEventHandler = (event) => {
      event.preventDefault();
      state.ctx.beginPath();
      state.ctx.lineWidth = props.lineWidth;
      state.ctx.strokeStyle = props.strokeStyle;
      emit2("start");
      canvas.value.addEventListener(state.events[1], moveEventHandler, false);
      canvas.value.addEventListener(state.events[2], endEventHandler, false);
      canvas.value.addEventListener(state.events[3], leaveEventHandler, false);
    };
    const moveEventHandler = (event) => {
      event.preventDefault();
      let evt = state.isSupportTouch ? event.touches[0] : event;
      emit2("signing", evt);
      let coverPos = canvas.value.getBoundingClientRect();
      let mouseX = evt.clientX - coverPos.left;
      let mouseY = evt.clientY - coverPos.top;
      state.ctx.lineTo(mouseX, mouseY);
      state.ctx.stroke();
    };
    const endEventHandler = (event) => {
      event.preventDefault();
      emit2("end");
      canvas.value.removeEventListener(state.events[1], moveEventHandler, false);
      canvas.value.removeEventListener(state.events[2], endEventHandler, false);
    };
    const leaveEventHandler = (event) => {
      event.preventDefault();
      canvas.value.removeEventListener(state.events[1], moveEventHandler, false);
      canvas.value.removeEventListener(state.events[2], endEventHandler, false);
    };
    const clear = () => {
      canvas.value.addEventListener(state.events[2], endEventHandler, false);
      state.ctx.clearRect(0, 0, state.canvasWidth, state.canvasHeight);
      state.ctx.closePath();
      emit2("clear");
    };
    const confirm = () => {
      onSave(canvas.value);
    };
    const isCanvasBlank = (canvas2) => {
      if (!canvas2) {
        return true;
      }
      var blank = document.createElement("canvas");
      blank.width = canvas2.width;
      blank.height = canvas2.height;
      return (canvas2 == null ? void 0 : canvas2.toDataURL()) == blank.toDataURL();
    };
    const onSave = (canvas2) => {
      let dataurl;
      switch (props.type) {
        case "png":
          dataurl = canvas2.toDataURL("image/png");
          break;
        case "jpg":
          dataurl = canvas2.toDataURL("image/jpeg", 0.8);
          break;
      }
      const _canvas = isCanvasBlank(canvas2) ? "请绘制签名" : canvas2;
      const _filePath = isCanvasBlank(canvas2) ? "" : dataurl;
      emit2("confirm", _canvas, _filePath);
    };
    onMounted(() => {
      if (isCanvasSupported()) {
        state.ctx = canvas.value.getContext("2d");
        state.canvasWidth = wrap.value.offsetWidth;
        state.canvasHeight = wrap.value.offsetHeight;
        addEvent();
      }
    });
    return __spreadProps$4(__spreadValues$4({}, toRefs(state)), { canvas, wrap, isCanvasSupported, confirm, clear, classes, translate });
  }
});
const _hoisted_1$d = {
  ref: "wrap",
  class: "nut-signature-inner"
};
const _hoisted_2$d = ["height", "width"];
const _hoisted_3$d = {
  key: 0,
  class: "nut-signature-unsopport"
};
function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_button = resolveComponent("nut-button");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classes)
  }, [
    createBaseVNode("div", _hoisted_1$d, [
      withDirectives(createBaseVNode("canvas", {
        ref: "canvas",
        height: _ctx.canvasHeight,
        width: _ctx.canvasWidth
      }, null, 8, _hoisted_2$d), [
        [vShow, _ctx.isCanvasSupported()]
      ]),
      !_ctx.isCanvasSupported() ? (openBlock(), createElementBlock("p", _hoisted_3$d, toDisplayString(_ctx.unSupportTpl || _ctx.translate("unSupportTpl")), 1)) : createCommentVNode("", true)
    ], 512),
    createVNode(_component_nut_button, {
      class: "nut-signature-btn",
      type: "default",
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.clear())
    }, {
      default: withCtx(() => [
        createTextVNode(toDisplayString(_ctx.translate("reSign")), 1)
      ]),
      _: 1
    }),
    createVNode(_component_nut_button, {
      class: "nut-signature-btn",
      type: "primary",
      onClick: _cache[1] || (_cache[1] = ($event) => _ctx.confirm())
    }, {
      default: withCtx(() => [
        createTextVNode(toDisplayString(_ctx.translate("confirm")), 1)
      ]),
      _: 1
    })
  ], 2);
}
const index$b = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$e]]);
const { create: create$d } = createComponent("time-select");
const cN$5 = "NutTimeSelect";
const _sfc_main$d = create$d({
  components: {
    NutPopup
  },
  props: {
    visible: {
      type: Boolean,
      defalut: false
    },
    height: {
      type: [String],
      default: "20%"
    },
    title: {
      type: String,
      default: ""
    },
    currentKey: {
      type: [Number, String],
      default: 0
    },
    currentTime: {
      type: Array,
      default: () => {
        return [];
      }
    },
    lockScroll: {
      type: [Boolean],
      default: true
    },
    teleportDisable: {
      type: Boolean,
      default: false
    }
  },
  emits: ["update:visible", "select"],
  setup: (props, { emit: emit2 }) => {
    const translate = useLocale(cN$5);
    const popStyle = computed(() => {
      return {
        width: "100%",
        height: props.height
      };
    });
    const currentKey = computed(() => props.currentKey);
    const currentTime = computed(() => props.currentTime);
    const close = () => {
      emit2("update:visible", false);
      emit2("select", currentTime.value);
    };
    provide("currentKey", currentKey);
    provide("currentTime", currentTime);
    return {
      popStyle,
      close,
      translate
    };
  }
});
const _hoisted_1$c = { class: "nut-time-select" };
const _hoisted_2$c = { class: "nut-time-select__title" };
const _hoisted_3$c = { class: "nut-time-select__title__fixed" };
const _hoisted_4$c = { key: 0 };
const _hoisted_5$6 = { class: "nut-time-select__content" };
const _hoisted_6$5 = { class: "nut-time-select__content__pannel" };
const _hoisted_7$4 = { class: "nut-time-select__content__detail" };
function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_popup = resolveComponent("nut-popup");
  return openBlock(), createBlock(_component_nut_popup, {
    position: "bottom",
    closeable: "",
    round: "",
    "teleport-disable": _ctx.teleportDisable,
    visible: _ctx.visible,
    style: normalizeStyle(_ctx.popStyle),
    "lock-scroll": _ctx.lockScroll,
    onClickOverlay: _ctx.close,
    onClickCloseIcon: _ctx.close
  }, {
    default: withCtx(() => [
      createBaseVNode("view", _hoisted_1$c, [
        createBaseVNode("view", _hoisted_2$c, [
          createBaseVNode("view", _hoisted_3$c, [
            !_ctx.$slots.title ? (openBlock(), createElementBlock("span", _hoisted_4$c, toDisplayString(_ctx.title || _ctx.translate("pickupTime")), 1)) : renderSlot(_ctx.$slots, "title", { key: 1 })
          ])
        ]),
        createBaseVNode("view", _hoisted_5$6, [
          createBaseVNode("view", _hoisted_6$5, [
            renderSlot(_ctx.$slots, "pannel")
          ]),
          createBaseVNode("view", _hoisted_7$4, [
            renderSlot(_ctx.$slots, "detail")
          ])
        ])
      ])
    ]),
    _: 3
  }, 8, ["teleport-disable", "visible", "style", "lock-scroll", "onClickOverlay", "onClickCloseIcon"]);
}
const index$a = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$d]]);
var __defProp$3 = Object.defineProperty;
var __defProps$3 = Object.defineProperties;
var __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$3 = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$3.call(b, prop))
      __defNormalProp$3(a2, prop, b[prop]);
  if (__getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(b)) {
      if (__propIsEnum$3.call(b, prop))
        __defNormalProp$3(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$3 = (a2, b) => __defProps$3(a2, __getOwnPropDescs$3(b));
const { componentName, create: create$c } = createComponent("time-pannel");
const _sfc_main$c = create$c({
  name: "timepannel",
  props: {
    name: {
      type: String,
      default: ""
    },
    pannelKey: {
      type: [Number, String],
      default: 0
    }
  },
  emits: ["change"],
  setup: (props, { emit: emit2 }) => {
    const currentKey = inject("currentKey");
    const state = reactive({
      currentKey
    });
    const classes = computed(() => {
      const prefixCls2 = componentName;
      return {
        [prefixCls2]: true,
        "nut-time-pannel--curr": state.currentKey == props.pannelKey
      };
    });
    const handlePannel = (pannelKey) => {
      emit2("change", pannelKey);
    };
    return __spreadProps$3(__spreadValues$3({}, toRefs(state)), {
      classes,
      handlePannel
    });
  }
});
function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(_ctx.classes),
    onClick: _cache[0] || (_cache[0] = ($event) => _ctx.handlePannel(_ctx.pannelKey))
  }, toDisplayString(_ctx.name), 3);
}
const index$9 = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$c]]);
var __defProp$2 = Object.defineProperty;
var __defProps$2 = Object.defineProperties;
var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$2 = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2.call(b, prop))
      __defNormalProp$2(a2, prop, b[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b)) {
      if (__propIsEnum$2.call(b, prop))
        __defNormalProp$2(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$2 = (a2, b) => __defProps$2(a2, __getOwnPropDescs$2(b));
const { create: create$b } = createComponent("time-detail");
const _sfc_main$b = create$b({
  name: "timedetail",
  props: {
    times: {
      type: Array,
      default: () => []
    }
  },
  emits: ["select"],
  setup: (props, { emit: emit2 }) => {
    const currentKey = inject("currentKey");
    const currentTime = inject("currentTime");
    const state = reactive({
      currentKey,
      currentTime
    });
    const getClass = (item) => {
      let find = state.currentTime.find((item2) => item2.key == state.currentKey);
      if (find) {
        return {
          "nut-time-detail__detail__list__item": true,
          "nut-time-detail__detail__list__item--curr": find.list.filter((value) => value === item).length > 0
        };
      }
    };
    const renderData = computed(() => {
      return props.times.find((time) => time.key == state.currentKey)["list"];
    });
    const handleTime = (time) => {
      emit2("select", time);
    };
    return __spreadProps$2(__spreadValues$2({}, toRefs(state)), {
      getClass,
      renderData,
      handleTime
    });
  }
});
const _hoisted_1$b = { class: "nut-time-detail" };
const _hoisted_2$b = { class: "nut-time-detail__detail nut-time-detail__detail--moring" };
const _hoisted_3$b = { class: "nut-time-detail__detail__list" };
const _hoisted_4$b = ["onClick"];
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", _hoisted_1$b, [
    createBaseVNode("view", _hoisted_2$b, [
      createBaseVNode("view", _hoisted_3$b, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.renderData, (item) => {
          return openBlock(), createElementBlock("view", {
            key: item,
            class: normalizeClass(_ctx.getClass(item)),
            onClick: ($event) => _ctx.handleTime(item)
          }, toDisplayString(item), 11, _hoisted_4$b);
        }), 128))
      ])
    ])
  ]);
}
const index$8 = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$b]]);
const { create: create$4$1 } = createComponent("sku-header");
const cN$1$2 = "NutSkuHeader";
const _sfc_main$4$1 = create$4$1({
  props: {
    goods: {
      type: Object,
      default: {}
    }
  },
  components: {
    NutPrice: _sfc_main$v
  },
  setup(props, { slots }) {
    const translate = useLocale(cN$1$2);
    const getSlots = (name) => slots[name];
    return {
      getSlots,
      translate
    };
  }
});
const _hoisted_1$4$1 = { class: "nut-sku-header" };
const _hoisted_2$4$1 = ["src"];
const _hoisted_3$3$1 = { class: "nut-sku-header-right" };
const _hoisted_4$3$1 = {
  key: 3,
  class: "nut-sku-header-right-extra"
};
function _sfc_render$4$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_price = resolveComponent("nut-price");
  return openBlock(), createElementBlock("view", _hoisted_1$4$1, [
    createBaseVNode("img", {
      class: "nut-sku-header-img",
      src: _ctx.goods.imagePath
    }, null, 8, _hoisted_2$4$1),
    createBaseVNode("view", _hoisted_3$3$1, [
      _ctx.getSlots("sku-header-price") ? renderSlot(_ctx.$slots, "sku-header-price", { key: 0 }) : (openBlock(), createBlock(_component_nut_price, {
        key: 1,
        price: _ctx.goods.price,
        "need-symbol": true,
        thousands: false
      }, null, 8, ["price"])),
      _ctx.getSlots("sku-header-extra") ? renderSlot(_ctx.$slots, "sku-header-extra", { key: 2 }) : createCommentVNode("", true),
      _ctx.goods.skuId && !_ctx.getSlots("sku-header-extra") ? (openBlock(), createElementBlock("view", _hoisted_4$3$1, toDisplayString(_ctx.translate("skuId")) + " : " + toDisplayString(_ctx.goods.skuId), 1)) : createCommentVNode("", true)
    ])
  ]);
}
const SkuHeader = /* @__PURE__ */ _export_sfc(_sfc_main$4$1, [["render", _sfc_render$4$1]]);
const { create: create$3$1 } = createComponent("sku-select");
const _sfc_main$3$1 = create$3$1({
  props: {
    sku: {
      type: Array,
      default: () => []
    }
  },
  emits: ["selectSku"],
  setup(props, { emit: emit2 }) {
    const skuInfo = ref([]);
    watch(
      () => props.sku,
      (value) => {
        skuInfo.value = [].slice.call(value);
      },
      { deep: true }
    );
    onMounted(() => {
      if (props.sku.length > 0) {
        skuInfo.value = [].slice.call(props.sku);
      }
    });
    const changeSaleChild = (attrItem, index2, parentItem, parentIndex) => {
      if (attrItem.checkFlag || attrItem.disable) {
        return;
      }
      emit2("selectSku", {
        sku: attrItem,
        skuIndex: index2,
        parentSku: parentItem,
        parentIndex
      });
    };
    return {
      skuInfo,
      changeSaleChild
    };
  }
});
const _hoisted_1$3$1 = { class: "nut-sku-select" };
const _hoisted_2$3$1 = { class: "nut-sku-select-item-title" };
const _hoisted_3$2$1 = { class: "nut-sku-select-item-skus" };
const _hoisted_4$2$1 = ["onClick"];
function _sfc_render$3$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("view", _hoisted_1$3$1, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.skuInfo, (item, index2) => {
      return openBlock(), createElementBlock("view", {
        key: item.id,
        class: "nut-sku-select-item"
      }, [
        createBaseVNode("view", _hoisted_2$3$1, toDisplayString(item.name), 1),
        createBaseVNode("view", _hoisted_3$2$1, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(item.list, (itemAttr, itemAttrIndex) => {
            return openBlock(), createElementBlock("view", {
              key: itemAttr.name,
              class: normalizeClass(["nut-sku-select-item-skus-sku", [{ active: !itemAttr.disable && itemAttr.active }, { disable: itemAttr.disable }]]),
              onClick: ($event) => _ctx.changeSaleChild(itemAttr, itemAttrIndex, item, index2)
            }, toDisplayString(itemAttr.name), 11, _hoisted_4$2$1);
          }), 128))
        ])
      ]);
    }), 128))
  ]);
}
const SkuSelect = /* @__PURE__ */ _export_sfc(_sfc_main$3$1, [["render", _sfc_render$3$1]]);
const { create: create$2$2 } = createComponent("sku-stepper");
const _sfc_main$2$2 = create$2$2({
  props: {
    // 购买数量最大值
    stepperMax: {
      type: [Number, String],
      default: 99999
    },
    stepperMin: {
      type: [Number, String],
      default: 1
    },
    // stepper 前文案提示
    stepperExtraText: {
      type: [Function, Boolean],
      default: false
    },
    // 数量选择左侧文案
    stepperTitle: {
      type: String,
      default: "购买数量"
    }
  },
  emits: ["click", "changeSku", "changeStepper", "clickBtnOptions", "overLimit", "reduce", "add"],
  components: {
    NutInputNumber: _sfc_main$13
  },
  setup(props, { emit: emit2 }) {
    const goodsCount = ref(props.stepperMin);
    onMounted(() => {
      goodsCount.value = props.stepperMin;
    });
    const getExtraText = () => {
      const { stepperExtraText } = props;
      if (stepperExtraText) {
        if (stepperExtraText === true) {
          return "";
        }
        return stepperExtraText == null ? void 0 : stepperExtraText();
      }
    };
    const add = (value) => {
      emit2("add", value);
    };
    const reduce2 = (value) => {
      emit2("reduce", value);
    };
    const overlimit = (e, action) => {
      emit2("overLimit", {
        action,
        value: parseInt(goodsCount.value + "")
      });
    };
    const changeStepper = (value) => {
      goodsCount.value = value;
      emit2("changeStepper", value);
    };
    return {
      goodsCount,
      add,
      reduce: reduce2,
      overlimit,
      getExtraText,
      changeStepper
    };
  }
});
const _hoisted_1$2$2 = { class: "nut-sku-stepper" };
const _hoisted_2$2$1 = { class: "nut-sku-stepper-title" };
const _hoisted_3$1$1 = ["innerHTML"];
const _hoisted_4$1$1 = { class: "nut-sku-stepper-count" };
function _sfc_render$2$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_input_number = resolveComponent("nut-input-number");
  return openBlock(), createElementBlock("view", _hoisted_1$2$2, [
    createBaseVNode("view", _hoisted_2$2$1, toDisplayString(_ctx.stepperTitle), 1),
    createBaseVNode("view", {
      class: "nut-sku-stepper-limit",
      innerHTML: _ctx.getExtraText()
    }, null, 8, _hoisted_3$1$1),
    createBaseVNode("view", _hoisted_4$1$1, [
      createVNode(_component_nut_input_number, {
        modelValue: _ctx.goodsCount,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.goodsCount = $event),
        min: _ctx.stepperMin,
        max: _ctx.stepperMax,
        onAdd: _ctx.add,
        onReduce: _ctx.reduce,
        onOverlimit: _ctx.overlimit,
        onChange: _ctx.changeStepper
      }, null, 8, ["modelValue", "min", "max", "onAdd", "onReduce", "onOverlimit", "onChange"])
    ])
  ]);
}
const SkuStepper = /* @__PURE__ */ _export_sfc(_sfc_main$2$2, [["render", _sfc_render$2$2]]);
const { create: create$1$2 } = createComponent("sku-operate");
const _sfc_main$1$3 = create$1$2({
  props: {
    // 底部按钮配置  confirm cart  buy
    btnOptions: {
      type: Array,
      default: () => ["confirm"]
    },
    btnExtraText: {
      type: String,
      default: ""
    },
    // 立即购买文案
    buyText: {
      type: String,
      default: "立即购买"
    },
    // 加入购物车文案
    addCartText: {
      type: String,
      default: "加入购物车"
    },
    confirmText: {
      type: String,
      default: "确定"
    }
  },
  emits: ["click", "changeSku", "changeBuyCount", "clickBtnOperate"],
  setup(props, { emit: emit2, slots }) {
    const getBtnDesc = (type) => {
      let mapD = {
        confirm: props.confirmText,
        cart: props.addCartText,
        buy: props.buyText
      };
      return mapD[type];
    };
    const getSlots = (name) => slots[name];
    const clickBtnOperate = (btn) => {
      emit2("clickBtnOperate", btn);
    };
    return {
      getBtnDesc,
      clickBtnOperate,
      getSlots
    };
  }
});
const _hoisted_1$1$3 = {
  key: 0,
  class: "nut-sku-operate"
};
const _hoisted_2$1$3 = {
  key: 0,
  class: "nut-sku-operate-desc"
};
const _hoisted_3$a = {
  key: 1,
  class: "nut-sku-operate-btn"
};
const _hoisted_4$a = ["onClick"];
function _sfc_render$1$2(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.btnOptions.length > 0 ? (openBlock(), createElementBlock("view", _hoisted_1$1$3, [
    _ctx.btnExtraText ? (openBlock(), createElementBlock("view", _hoisted_2$1$3, toDisplayString(_ctx.btnExtraText), 1)) : createCommentVNode("", true),
    renderSlot(_ctx.$slots, "operate-btn"),
    !_ctx.getSlots("operate-btn") ? (openBlock(), createElementBlock("view", _hoisted_3$a, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.btnOptions, (btn, i2) => {
        return openBlock(), createElementBlock("view", {
          key: i2,
          class: normalizeClass([`nut-sku-operate-btn-${btn}`, "nut-sku-operate-btn-item"]),
          onClick: ($event) => _ctx.clickBtnOperate(btn)
        }, toDisplayString(_ctx.getBtnDesc(btn)), 11, _hoisted_4$a);
      }), 128))
    ])) : createCommentVNode("", true)
  ])) : createCommentVNode("", true);
}
const SkuOperate = /* @__PURE__ */ _export_sfc(_sfc_main$1$3, [["render", _sfc_render$1$2]]);
const { create: create$a } = createComponent("sku");
const cN$4 = "NutSku";
const _sfc_main$a = create$a({
  props: {
    visible: {
      type: Boolean,
      default: false
    },
    sku: {
      type: Array,
      default: []
    },
    goods: {
      type: Object,
      default: {}
    },
    // stepper 最大值
    stepperMax: {
      type: [Number, String],
      default: 99999
    },
    // stepper 最小值
    stepperMin: {
      type: [Number, String],
      default: 1
    },
    // 底部按钮配置  confirm cart  buy
    btnOptions: {
      type: Array,
      default: () => ["confirm"]
    },
    // 数量选择左侧文案
    stepperTitle: {
      type: String,
      default: ""
    },
    // stepper 前面文案
    stepperExtraText: {
      type: [Function, Boolean],
      default: false
    },
    btnExtraText: {
      type: String,
      default: ""
    },
    // 立即购买文案
    buyText: {
      type: String,
      default: ""
    },
    // 加入购物车文案
    addCartText: {
      type: String,
      default: ""
    },
    // 确定文案
    confirmText: {
      type: String,
      default: ""
    },
    lockScroll: {
      type: Boolean,
      default: true
    }
  },
  emits: [
    "update:visible",
    "selectSku",
    "changeStepper",
    "clickBtnOperate",
    "clickCloseIcon",
    "clickOverlay",
    "close",
    "reduce",
    "add",
    "overLimit"
  ],
  components: {
    SkuHeader,
    SkuSelect,
    SkuStepper,
    SkuOperate,
    NutPopup
  },
  setup(props, { emit: emit2, slots }) {
    const translate = useLocale(cN$4);
    const showPopup = ref(props.visible);
    const goodsCount = ref(props.stepperMin);
    watch(
      () => props.visible,
      (value) => {
        showPopup.value = value;
      }
    );
    watch(
      () => showPopup.value,
      (value) => {
        if (value == false) {
          close();
        }
      }
    );
    const getSlots = (name) => slots[name];
    const selectSku = (skus) => {
      emit2("selectSku", skus);
    };
    const changeStepper = (value) => {
      goodsCount.value = value;
      emit2("changeStepper", value);
    };
    const add = (value) => {
      emit2("add", value);
    };
    const reduce2 = (value) => {
      emit2("reduce", value);
    };
    const stepperOverLimit = (count2) => {
      emit2("overLimit", count2);
    };
    const clickBtnOperate = (btn) => {
      emit2("clickBtnOperate", {
        type: btn,
        value: goodsCount.value
      });
    };
    const closePopup = (type) => {
      if (type == "icon") {
        emit2("clickCloseIcon");
      }
      if (type == "overlay") {
        emit2("clickOverlay");
      }
      if (type == "close") {
        emit2("close");
      }
      showPopup.value = false;
    };
    const close = () => {
      emit2("update:visible", false);
    };
    return {
      showPopup,
      closePopup,
      selectSku,
      changeStepper,
      stepperOverLimit,
      clickBtnOperate,
      add,
      reduce: reduce2,
      getSlots,
      translate
    };
  }
});
const _hoisted_1$a = { class: "nut-sku" };
const _hoisted_2$a = { class: "nut-sku-content" };
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_sku_header = resolveComponent("sku-header");
  const _component_SkuSelect = resolveComponent("SkuSelect");
  const _component_sku_stepper = resolveComponent("sku-stepper");
  const _component_sku_operate = resolveComponent("sku-operate");
  const _component_nut_popup = resolveComponent("nut-popup");
  return openBlock(), createBlock(_component_nut_popup, {
    visible: _ctx.showPopup,
    "onUpdate:visible": _cache[0] || (_cache[0] = ($event) => _ctx.showPopup = $event),
    position: "bottom",
    closeable: "",
    round: "",
    style: { "height": "75%" },
    "lock-scroll": _ctx.lockScroll,
    "catch-move": _ctx.lockScroll,
    onClickCloseIcon: _cache[1] || (_cache[1] = ($event) => _ctx.closePopup("icon")),
    onClickOverlay: _cache[2] || (_cache[2] = ($event) => _ctx.closePopup("overlay")),
    onClose: _cache[3] || (_cache[3] = ($event) => _ctx.closePopup("close"))
  }, {
    default: withCtx(() => [
      createBaseVNode("view", _hoisted_1$a, [
        renderSlot(_ctx.$slots, "sku-header"),
        !_ctx.getSlots("sku-header") ? (openBlock(), createBlock(_component_sku_header, {
          key: 0,
          goods: _ctx.goods
        }, createSlots({ _: 2 }, [
          _ctx.getSlots("sku-header-price") ? {
            name: "sku-header-price",
            fn: withCtx(() => [
              renderSlot(_ctx.$slots, "sku-header-price")
            ]),
            key: "0"
          } : void 0,
          _ctx.getSlots("sku-header-extra") ? {
            name: "sku-header-extra",
            fn: withCtx(() => [
              renderSlot(_ctx.$slots, "sku-header-extra")
            ]),
            key: "1"
          } : void 0
        ]), 1032, ["goods"])) : createCommentVNode("", true),
        createBaseVNode("view", _hoisted_2$a, [
          renderSlot(_ctx.$slots, "sku-select-top"),
          renderSlot(_ctx.$slots, "sku-select"),
          !_ctx.getSlots("sku-select") ? (openBlock(), createBlock(_component_SkuSelect, {
            key: 0,
            sku: _ctx.sku,
            onSelectSku: _ctx.selectSku
          }, null, 8, ["sku", "onSelectSku"])) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "sku-stepper"),
          !_ctx.getSlots("sku-stepper") ? (openBlock(), createBlock(_component_sku_stepper, {
            key: 1,
            goods: _ctx.goods,
            "stepper-title": _ctx.stepperTitle || _ctx.translate("buyNumber"),
            "stepper-max": _ctx.stepperMax,
            "stepper-min": _ctx.stepperMin,
            "stepper-extra-text": _ctx.stepperExtraText,
            onAdd: _ctx.add,
            onReduce: _ctx.reduce,
            onChangeStepper: _ctx.changeStepper,
            onOverLimit: _ctx.stepperOverLimit
          }, null, 8, ["goods", "stepper-title", "stepper-max", "stepper-min", "stepper-extra-text", "onAdd", "onReduce", "onChangeStepper", "onOverLimit"])) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "sku-stepper-bottom")
        ]),
        createVNode(_component_sku_operate, {
          "btn-extra-text": _ctx.btnExtraText,
          "btn-options": _ctx.btnOptions,
          "buy-text": _ctx.buyText || _ctx.translate("buyNow"),
          "add-cart-text": _ctx.addCartText || _ctx.translate("addToCart"),
          "confirm-text": _ctx.confirmText || _ctx.translate("confirm"),
          onClickBtnOperate: _ctx.clickBtnOperate
        }, createSlots({ _: 2 }, [
          _ctx.getSlots("sku-operate") ? {
            name: "operate-btn",
            fn: withCtx(() => [
              renderSlot(_ctx.$slots, "sku-operate")
            ]),
            key: "0"
          } : void 0
        ]), 1032, ["btn-extra-text", "btn-options", "buy-text", "add-cart-text", "confirm-text", "onClickBtnOperate"])
      ])
    ]),
    _: 3
  }, 8, ["visible", "lock-scroll", "catch-move"]);
}
const index$7 = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$a]]);
const { create: create$9 } = createComponent("card");
const _sfc_main$9 = create$9({
  components: {
    NutPrice: _sfc_main$v,
    NutTag: _sfc_main$r
  },
  props: {
    imgUrl: {
      type: String,
      default: ""
    },
    title: {
      type: String,
      default: ""
    },
    price: {
      type: String,
      default: ""
    },
    vipPrice: {
      type: String,
      default: ""
    },
    shopDesc: {
      type: String,
      default: ""
    },
    delivery: {
      type: String,
      default: ""
    },
    shopName: {
      type: String,
      default: ""
    },
    isNeedPrice: {
      type: Boolean,
      default: true
    }
  }
});
const _hoisted_1$9 = { class: "nut-card" };
const _hoisted_2$9 = { class: "nut-card__left" };
const _hoisted_3$9 = ["src"];
const _hoisted_4$9 = { class: "nut-card__right" };
const _hoisted_5$5 = { class: "nut-card__right__title" };
const _hoisted_6$4 = {
  key: 0,
  class: "nut-card__right__price"
};
const _hoisted_7$3 = { class: "nut-card__right__other" };
const _hoisted_8$1 = { class: "nut-card__right__shop" };
const _hoisted_9$1 = { class: "nut-card__right__shop__name" };
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_price = resolveComponent("nut-price");
  const _component_nut_tag = resolveComponent("nut-tag");
  return openBlock(), createElementBlock("div", _hoisted_1$9, [
    createBaseVNode("div", _hoisted_2$9, [
      createBaseVNode("img", {
        src: _ctx.imgUrl,
        alt: ""
      }, null, 8, _hoisted_3$9)
    ]),
    createBaseVNode("div", _hoisted_4$9, [
      createBaseVNode("div", _hoisted_5$5, toDisplayString(_ctx.title), 1),
      renderSlot(_ctx.$slots, "prolist"),
      _ctx.isNeedPrice ? (openBlock(), createElementBlock("div", _hoisted_6$4, [
        renderSlot(_ctx.$slots, "price", {}, () => [
          createVNode(_component_nut_price, { price: _ctx.price }, null, 8, ["price"])
        ]),
        renderSlot(_ctx.$slots, "origin", {}, () => [
          createVNode(_component_nut_price, {
            class: "nut-card__right__price__origin",
            price: _ctx.vipPrice
          }, null, 8, ["price"])
        ])
      ])) : createCommentVNode("", true),
      createBaseVNode("div", _hoisted_7$3, [
        renderSlot(_ctx.$slots, "shop-tag", {}, () => [
          createVNode(_component_nut_tag, { type: "danger" }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(_ctx.shopDesc), 1)
            ]),
            _: 1
          }),
          createVNode(_component_nut_tag, { plain: "" }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(_ctx.delivery), 1)
            ]),
            _: 1
          })
        ])
      ]),
      createBaseVNode("div", _hoisted_8$1, [
        createBaseVNode("div", _hoisted_9$1, toDisplayString(_ctx.shopName), 1),
        renderSlot(_ctx.$slots, "footer")
      ])
    ])
  ]);
}
const index$6 = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$9]]);
const { create: create$8 } = createComponent("ecard");
const cN$3 = "NutEcard";
const _sfc_main$8 = create$8({
  components: {
    NutInputNumber: _sfc_main$13
  },
  props: {
    chooseText: {
      type: String,
      default: ""
    },
    otherValueText: {
      type: String,
      default: ""
    },
    dataList: {
      type: Array,
      default: () => []
    },
    cardAmountMin: {
      type: Number,
      default: 1
    },
    cardAmountMax: {
      type: Number,
      default: 9999
    },
    cardBuyMin: {
      type: Number,
      default: 1
    },
    cardBuyMax: {
      type: Number,
      default: 9999
    },
    modelValue: {
      type: [Number, String],
      default: 0
    },
    placeholder: {
      type: String,
      default: ""
    },
    suffix: {
      type: String,
      default: "¥"
    }
  },
  emits: ["inputChange", "changeStep", "inputClick", "change", "update:modelValue"],
  setup(props, { emit: emit2 }) {
    const translate = useLocale(cN$3);
    const currentIndex = ref(null);
    const currentValue = ref(null);
    const inputValue = ref("");
    const stepValue = ref(props.cardAmountMin);
    const money = ref(props.modelValue);
    const handleClick = (item, index2) => {
      currentIndex.value = index2;
      stepValue.value = props.cardAmountMin;
      currentValue.value = item.price;
      emit2("change", item);
      emit2("update:modelValue", item.price);
    };
    const change = (event) => {
      let input = event.target;
      let val = input.value.replace(/[^\d]/g, "");
      inputValue.value = val;
      currentValue.value = val;
      if (Number(val) > props.cardAmountMax) {
        inputValue.value = props.cardAmountMax;
        currentValue.value = props.cardAmountMax;
      }
      if (Number(val) < props.cardAmountMin) {
        inputValue.value = props.cardAmountMin;
        currentValue.value = props.cardAmountMin;
      }
      emit2("inputChange", Number(inputValue.value));
      emit2("update:modelValue", Number(inputValue.value));
    };
    const inputClick = () => {
      currentIndex.value = "input";
      stepValue.value = props.cardAmountMin;
      currentValue.value = inputValue.value;
      emit2("update:modelValue", inputValue.value);
      emit2("inputClick");
    };
    const changeStep = (value) => {
      stepValue.value = value;
      emit2("changeStep", stepValue.value, currentValue.value);
    };
    watch(
      () => props.modelValue,
      (value) => {
        money.value = value;
      }
    );
    return {
      handleClick,
      changeStep,
      change,
      inputClick,
      stepValue,
      currentIndex,
      inputValue,
      money,
      translate
    };
  }
});
const _hoisted_1$8 = { class: "nut-ecard" };
const _hoisted_2$8 = { class: "nut-ecard__title" };
const _hoisted_3$8 = { class: "nut-ecard__list" };
const _hoisted_4$8 = ["onClick"];
const _hoisted_5$4 = { class: "nut-ecard__list__input--con" };
const _hoisted_6$3 = ["placeholder"];
const _hoisted_7$2 = { class: "nut-ecard__list__step" };
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_input_number = resolveComponent("nut-input-number");
  return openBlock(), createElementBlock("view", _hoisted_1$8, [
    createBaseVNode("view", _hoisted_2$8, toDisplayString(_ctx.chooseText || _ctx.translate("chooseText")), 1),
    createBaseVNode("view", _hoisted_3$8, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.dataList, (item, index2) => {
        return openBlock(), createElementBlock("view", {
          key: index2,
          class: normalizeClass(["nut-ecard__list__item", _ctx.currentIndex == index2 ? "active" : ""]),
          onClick: ($event) => _ctx.handleClick(item, index2)
        }, toDisplayString(item.price), 11, _hoisted_4$8);
      }), 128)),
      createBaseVNode("view", {
        class: normalizeClass(["nut-ecard__list__input", _ctx.currentIndex == "input" ? "active" : ""]),
        onClick: _cache[2] || (_cache[2] = (...args) => _ctx.inputClick && _ctx.inputClick(...args))
      }, [
        createBaseVNode("view", null, toDisplayString(_ctx.otherValueText || _ctx.translate("otherValueText")), 1),
        createBaseVNode("view", _hoisted_5$4, [
          withDirectives(createBaseVNode("input", {
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.inputValue = $event),
            class: "nut-ecard__list__input--input",
            type: "text",
            placeholder: _ctx.placeholder || _ctx.translate("placeholder"),
            onInput: _cache[1] || (_cache[1] = (...args) => _ctx.change && _ctx.change(...args))
          }, null, 40, _hoisted_6$3), [
            [vModelText, _ctx.inputValue]
          ]),
          createTextVNode(" " + toDisplayString(_ctx.suffix), 1)
        ])
      ], 2),
      createBaseVNode("view", _hoisted_7$2, [
        createBaseVNode("view", null, toDisplayString(_ctx.suffix) + toDisplayString(_ctx.money), 1),
        createVNode(_component_nut_input_number, {
          modelValue: _ctx.stepValue,
          "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.stepValue = $event),
          min: _ctx.cardBuyMin,
          max: _ctx.cardBuyMax,
          onChange: _ctx.changeStep
        }, null, 8, ["modelValue", "min", "max", "onChange"])
      ])
    ])
  ]);
}
const index$5 = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$8]]);
const { create: create$2$1 } = createComponent("address-list-item");
const cN$1$1 = "NutAddressList";
const _sfc_main$2$1 = create$2$1({
  components: { Del: w$9, Edit: g$2 },
  props: {
    item: {
      type: Object,
      default: {}
    }
  },
  emits: ["delIcon", "editIcon", "clickItem"],
  setup(props, { emit: emit2 }) {
    const translate = useLocale(cN$1$1);
    const delClick = (event) => {
      emit2("delIcon", event, props.item);
      event.stopPropagation();
    };
    const editClick = (event) => {
      emit2("editIcon", event, props.item);
      event.stopPropagation();
    };
    const contentsClick = (event) => {
      emit2("clickItem", event, props.item);
      event.stopPropagation();
    };
    return {
      delClick,
      editClick,
      contentsClick,
      translate
    };
  }
});
const _hoisted_1$2$1 = { class: "nut-address-list-item__info" };
const _hoisted_2$1$2 = { class: "nut-address-list-item__info-contact" };
const _hoisted_3$7 = { class: "nut-address-list-item__info-contact-name" };
const _hoisted_4$7 = { class: "nut-address-list-item__info-contact-tel" };
const _hoisted_5$3 = {
  key: 0,
  class: "nut-address-list-item__info-contact-default"
};
const _hoisted_6$2 = { class: "nut-address-list-item__info-handle" };
const _hoisted_7$1 = { class: "nut-address-list-item__addr" };
function _sfc_render$2$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Del = resolveComponent("Del");
  const _component_Edit = resolveComponent("Edit");
  return openBlock(), createElementBlock("div", {
    class: "nut-address-list-item",
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.contentsClick && _ctx.contentsClick(...args))
  }, [
    createBaseVNode("div", _hoisted_1$2$1, [
      createBaseVNode("div", _hoisted_2$1$2, [
        renderSlot(_ctx.$slots, "content-top", {}, () => [
          createBaseVNode("div", _hoisted_3$7, toDisplayString(_ctx.item.addressName), 1),
          createBaseVNode("div", _hoisted_4$7, toDisplayString(_ctx.item.phone), 1),
          _ctx.item.defaultAddress ? (openBlock(), createElementBlock("div", _hoisted_5$3, toDisplayString(_ctx.translate("default")), 1)) : createCommentVNode("", true)
        ])
      ]),
      createBaseVNode("div", _hoisted_6$2, [
        renderSlot(_ctx.$slots, "content-icon", {}, () => [
          createVNode(_component_Del, {
            name: "del",
            class: "nut-address-list-item__info-handle-del",
            onClick: _ctx.delClick
          }, null, 8, ["onClick"]),
          createVNode(_component_Edit, {
            name: "edit",
            class: "nut-address-list-item__info-handle-edit",
            onClick: _ctx.editClick
          }, null, 8, ["onClick"])
        ])
      ])
    ]),
    createBaseVNode("div", _hoisted_7$1, [
      renderSlot(_ctx.$slots, "content-addr", {}, () => [
        createTextVNode(toDisplayString(_ctx.item.fullAddress), 1)
      ])
    ])
  ]);
}
const ItemContents = /* @__PURE__ */ _export_sfc(_sfc_main$2$1, [["render", _sfc_render$2$1]]);
const { create: create$1$1 } = createComponent("address-list-general");
const _sfc_main$1$2 = create$1$1({
  props: {
    item: {
      type: Object,
      default: {}
    },
    longPress: {
      type: Boolean,
      default: false
    },
    swipeEdition: {
      type: Boolean,
      default: false
    }
  },
  emits: ["delIcon", "editIcon", "clickItem", "longDown", "longCopy", "longSet", "longDel", "swipeDel"],
  components: {
    ItemContents,
    NutButton: _sfc_main$1G,
    NutSwipe: _sfc_main$T
  },
  setup(props, { emit: emit2 }) {
    const renderCompontent = () => {
      return h$2(ItemContents, {
        item: props.item,
        onDelIcon(event) {
          delClick(event);
        },
        onEditIcon(event) {
          editClick(event);
        },
        onClickItem(event) {
          clickItem(event);
        }
      });
    };
    let loop = null;
    const moveRef = ref(false);
    const showMaskRef = ref(false);
    const delClick = (event) => {
      emit2("delIcon", event, props.item);
      event.stopPropagation();
    };
    const editClick = (event) => {
      emit2("editIcon", event, props.item);
      event.stopPropagation();
    };
    const clickItem = (event) => {
      if (moveRef.value) return;
      emit2("clickItem", event, props.item);
      event.stopPropagation();
    };
    const delLongClick = (event) => {
      emit2("longDel", event, props.item);
      event.stopPropagation();
    };
    const holdingFunc = (event) => {
      loop = 0;
      showMaskRef.value = true;
      emit2("longDown", event, props.item);
    };
    const holddownstart = (event) => {
      loop = setTimeout(() => {
        holdingFunc(event);
      }, 300);
    };
    const holddownmove = () => {
      clearTimeout(loop);
    };
    const holddownend = () => {
      clearTimeout(loop);
    };
    const hideMaskClick = () => {
      showMaskRef.value = false;
    };
    const copyCLick = (event) => {
      emit2("longCopy", event, props.item);
      event.stopPropagation();
    };
    const setDefault = (event) => {
      emit2("longSet", event, props.item);
      event.stopPropagation();
    };
    const maskClick = (event) => {
      if (loop != 0) {
        showMaskRef.value = false;
      }
      event.stopPropagation();
      event.preventDefault();
    };
    const swipeDelClick = (event) => {
      emit2("swipeDel", event, props.item);
      event.stopPropagation();
    };
    const swipestart = () => {
      moveRef.value = false;
    };
    const swipemove = () => {
      moveRef.value = true;
    };
    return {
      renderCompontent,
      showMaskRef,
      clickItem,
      editClick,
      delClick,
      delLongClick,
      holddownstart,
      holddownmove,
      holddownend,
      copyCLick,
      hideMaskClick,
      setDefault,
      maskClick,
      swipeDelClick,
      swipestart,
      swipemove
    };
  }
});
const _hoisted_1$1$2 = {
  key: 0,
  class: "nut-address-list-general"
};
const _hoisted_2$7 = { class: "nut-address-list-swipe" };
function _sfc_render$1$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_button = resolveComponent("nut-button");
  const _component_nut_swipe = resolveComponent("nut-swipe");
  return !_ctx.swipeEdition ? (openBlock(), createElementBlock("div", _hoisted_1$1$2, [
    (openBlock(), createBlock(resolveDynamicComponent(_ctx.renderCompontent()), {
      onTouchstart: _ctx.holddownstart,
      onTouchend: _ctx.holddownend,
      onTouchmove: _ctx.holddownmove
    }, {
      "content-top": withCtx(() => [
        renderSlot(_ctx.$slots, "content-info")
      ]),
      "content-icon": withCtx(() => [
        renderSlot(_ctx.$slots, "content-icons")
      ]),
      "content-addr": withCtx(() => [
        renderSlot(_ctx.$slots, "content-addrs")
      ]),
      _: 3
    }, 40, ["onTouchstart", "onTouchend", "onTouchmove"])),
    _ctx.longPress && _ctx.showMaskRef ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: "nut-address-list-general__mask",
      onClick: _cache[3] || (_cache[3] = (...args) => _ctx.maskClick && _ctx.maskClick(...args))
    }, [
      renderSlot(_ctx.$slots, "longpress-all", {}, () => [
        createBaseVNode("div", {
          class: "nut-address-list-general__mask-copy",
          onClick: _cache[0] || (_cache[0] = (...args) => _ctx.copyCLick && _ctx.copyCLick(...args))
        }, " 复制地址 "),
        createBaseVNode("div", {
          class: "nut-address-list-general__mask-set",
          onClick: _cache[1] || (_cache[1] = (...args) => _ctx.setDefault && _ctx.setDefault(...args))
        }, " 设置默认 "),
        createBaseVNode("div", {
          class: "nut-address-list-general__mask-del",
          onClick: _cache[2] || (_cache[2] = (...args) => _ctx.delLongClick && _ctx.delLongClick(...args))
        }, " 删除地址 ")
      ])
    ])) : createCommentVNode("", true),
    _ctx.showMaskRef ? (openBlock(), createElementBlock("div", {
      key: 1,
      class: "nut-address-list__mask-bottom",
      onClick: _cache[4] || (_cache[4] = (...args) => _ctx.hideMaskClick && _ctx.hideMaskClick(...args))
    })) : createCommentVNode("", true)
  ])) : (openBlock(), createBlock(_component_nut_swipe, { key: 1 }, {
    right: withCtx(() => [
      renderSlot(_ctx.$slots, "swipe-right-btn", {}, () => [
        createVNode(_component_nut_button, {
          shape: "square",
          style: { "height": "100%" },
          type: "danger",
          onClick: _ctx.swipeDelClick
        }, {
          default: withCtx(() => [
            createTextVNode("删除")
          ]),
          _: 1
        }, 8, ["onClick"])
      ])
    ]),
    default: withCtx(() => [
      createBaseVNode("div", _hoisted_2$7, [
        (openBlock(), createBlock(resolveDynamicComponent(_ctx.renderCompontent()), {
          onTouchmove: _ctx.swipemove,
          onTouchstart: _ctx.swipestart
        }, {
          "content-top": withCtx(() => [
            renderSlot(_ctx.$slots, "content-info")
          ]),
          "content-icon": withCtx(() => [
            renderSlot(_ctx.$slots, "content-icons")
          ]),
          "content-addr": withCtx(() => [
            renderSlot(_ctx.$slots, "content-addrs")
          ]),
          _: 3
        }, 40, ["onTouchmove", "onTouchstart"]))
      ])
    ]),
    _: 3
  }));
}
const GeneralShell = /* @__PURE__ */ _export_sfc(_sfc_main$1$2, [["render", _sfc_render$1$1]]);
const { create: create$7 } = createComponent("address-list");
const cN$2 = "NutAddressList";
const _sfc_main$7 = create$7({
  props: {
    data: {
      type: Array,
      default: []
    },
    longPress: {
      type: Boolean,
      default: false
    },
    swipeEdition: {
      type: Boolean,
      default: false
    },
    showBottomButton: {
      type: Boolean,
      default: true
    },
    dataOptions: {
      type: Object,
      default: {}
    }
  },
  components: {
    GeneralShell,
    NutButton: _sfc_main$1G
  },
  emits: ["delIcon", "editIcon", "clickItem", "longCopy", "longSet", "longDel", "swipeDel", "add"],
  setup(props, { emit: emit2 }) {
    const translate = useLocale(cN$2);
    const dataArray = ref([]);
    const dataInfo = reactive({
      id: 2,
      addressName: "姓名",
      phone: "123****4567",
      defaultAddress: false,
      fullAddress: "北京市通州区测试测试测试测试测试测试测试测试测试"
    });
    const trowelData = () => {
      if (Object.keys(props.dataOptions).length > 0) {
        dataArray.value = props.data.map((item) => {
          return floatData(dataInfo, item, props.dataOptions);
        });
      }
    };
    watch(
      () => props.data,
      () => trowelData(),
      { deep: true }
    );
    const clickDelIcon = (event, item) => {
      emit2("delIcon", event, item);
      event.stopPropagation();
    };
    const clickEditIcon = (event, item) => {
      emit2("editIcon", event, item);
      event.stopPropagation();
    };
    const clickContentItem = (event, item) => {
      emit2("clickItem", event, item);
      event.stopPropagation();
    };
    const clickLongCopy = (event, item) => {
      emit2("longCopy", event, item);
      event.stopPropagation();
    };
    const clickLongSet = (event, item) => {
      emit2("longSet", event, item);
      event.stopPropagation();
    };
    const clickLongDel = (event, item) => {
      emit2("longDel", event, item);
      event.stopPropagation();
    };
    const clickSwipeDel = (event, item) => {
      emit2("swipeDel", event, item);
      event.stopPropagation();
    };
    const addAddress = (event) => {
      emit2("add", event);
      event.stopPropagation();
    };
    onMounted(() => {
      trowelData();
    });
    return {
      clickDelIcon,
      clickEditIcon,
      clickContentItem,
      clickLongCopy,
      clickLongSet,
      clickLongDel,
      clickSwipeDel,
      addAddress,
      dataArray,
      translate
    };
  }
});
const _hoisted_1$7 = { class: "nut-address-list" };
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_general_shell = resolveComponent("general-shell");
  const _component_nut_button = resolveComponent("nut-button");
  return openBlock(), createElementBlock("div", _hoisted_1$7, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.dataArray, (item, index2) => {
      return openBlock(), createBlock(_component_general_shell, {
        key: index2,
        item,
        "long-press": _ctx.longPress,
        "swipe-edition": _ctx.swipeEdition,
        onDelIcon: _ctx.clickDelIcon,
        onEditIcon: _ctx.clickEditIcon,
        onClickItem: _ctx.clickContentItem,
        onSwipeDel: _ctx.clickSwipeDel,
        onLongCopy: _ctx.clickLongCopy,
        onLongSet: _ctx.clickLongSet,
        onLongDel: _ctx.clickLongDel
      }, createSlots({
        "content-info": withCtx(() => [
          renderSlot(_ctx.$slots, "item-infos", { item })
        ]),
        "content-icons": withCtx(() => [
          renderSlot(_ctx.$slots, "item-icon", { item })
        ]),
        "content-addrs": withCtx(() => [
          renderSlot(_ctx.$slots, "item-addr", { item })
        ]),
        _: 2
      }, [
        _ctx.longPress ? {
          name: "longpress-all",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "longpress-btns", { item })
          ]),
          key: "0"
        } : void 0,
        _ctx.swipeEdition ? {
          name: "swipe-right-btn",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "swipe-right", { item })
          ]),
          key: "1"
        } : void 0
      ]), 1032, ["item", "long-press", "swipe-edition", "onDelIcon", "onEditIcon", "onClickItem", "onSwipeDel", "onLongCopy", "onLongSet", "onLongDel"]);
    }), 128)),
    _ctx.showBottomButton ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: "nut-address-list__bottom",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.addAddress && _ctx.addAddress(...args))
    }, [
      createVNode(_component_nut_button, {
        block: "",
        type: "danger"
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.translate("addAddress")), 1)
        ]),
        _: 1
      })
    ])) : createCommentVNode("", true)
  ]);
}
const index$4 = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7]]);
const { create: create$6 } = createComponent("category");
const _sfc_main$6 = create$6({
  props: {
    // 分类模式
    type: {
      type: String,
      default: "classify"
    },
    // 左侧导航栏
    category: {
      type: Array,
      default: []
    }
  },
  setup(props, { emit: emit2 }) {
    const checkIndex = ref(0);
    const categoryLeft = ref(false);
    const getChildList = (index2) => {
      checkIndex.value = index2;
      emit2("change", index2);
    };
    return {
      getChildList,
      checkIndex,
      categoryLeft
    };
  }
});
const _hoisted_1$6 = { class: "nut-category" };
const _hoisted_2$6 = { class: "nut-category__cateList" };
const _hoisted_3$6 = { key: 0 };
const _hoisted_4$6 = ["onClick"];
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$6, [
    createBaseVNode("div", _hoisted_2$6, [
      _ctx.type == "classify" || _ctx.type == "text" ? (openBlock(), createElementBlock("div", _hoisted_3$6, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.category, (item, index2) => {
          return openBlock(), createElementBlock("div", {
            key: index2,
            class: "nut-category__cateListLeft"
          }, [
            createBaseVNode("div", {
              class: normalizeClass([_ctx.checkIndex == index2 ? "nut-category__cateListItemChecked" : "nut-category__cateListItem"]),
              onClick: ($event) => _ctx.getChildList(index2)
            }, toDisplayString(item.catName), 11, _hoisted_4$6)
          ]);
        }), 128))
      ])) : createCommentVNode("", true),
      renderSlot(_ctx.$slots, "default")
    ])
  ]);
}
const index$3 = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6]]);
const { create: create$5 } = createComponent("category-pane");
const _sfc_main$5 = create$5({
  props: {
    // 分类模式
    type: {
      type: String,
      default: "classify"
    },
    // 右侧导航数据
    categoryChild: {
      type: Array,
      default: () => []
    },
    // 模式传入自定义数据
    customCategory: {
      type: Array,
      default: () => []
    }
  },
  setup(props, { emit: emit2 }) {
    const onChange = (sku) => {
      emit2("onChange", sku);
    };
    return {
      onChange
    };
  }
});
const _hoisted_1$5 = { class: "nut-category-pane" };
const _hoisted_2$5 = {
  key: 0,
  class: "nut-category-pane__cateListRight"
};
const _hoisted_3$5 = { class: "nut-category-pane__childTitle" };
const _hoisted_4$5 = {
  key: 0,
  class: "nut-category-pane__childItemList"
};
const _hoisted_5$2 = ["onClick"];
const _hoisted_6$1 = ["src"];
const _hoisted_7 = { class: "nut-category-pane__skuImg" };
const _hoisted_8 = {
  key: 1,
  class: "nut-category-pane__cateListRight"
};
const _hoisted_9 = { class: "nut-category-pane__childTitle" };
const _hoisted_10 = {
  key: 0,
  class: "nut-category-pane__childItemList"
};
const _hoisted_11 = ["onClick"];
const _hoisted_12 = { class: "nut-category-pane__skuName" };
const _hoisted_13 = {
  key: 2,
  class: "nut-category-pane__selfItemList"
};
const _hoisted_14 = ["onClick"];
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$5, [
    _ctx.type == "classify" ? (openBlock(), createElementBlock("div", _hoisted_2$5, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.categoryChild, (item, index2) => {
        return openBlock(), createElementBlock("div", { key: index2 }, [
          createBaseVNode("div", _hoisted_3$5, toDisplayString(item == null ? void 0 : item.catName), 1),
          (item == null ? void 0 : item.catType) == 1 ? (openBlock(), createElementBlock("div", _hoisted_4$5, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(item.childCateList, (sku, key) => {
              return openBlock(), createElementBlock("div", {
                key,
                class: "nut-category-pane__childItem",
                onClick: ($event) => _ctx.onChange(sku)
              }, [
                createBaseVNode("img", {
                  class: "nut-category-pane__childImg",
                  src: sku.backImg
                }, null, 8, _hoisted_6$1),
                createBaseVNode("div", _hoisted_7, toDisplayString(sku == null ? void 0 : sku.catName), 1)
              ], 8, _hoisted_5$2);
            }), 128))
          ])) : createCommentVNode("", true)
        ]);
      }), 128))
    ])) : createCommentVNode("", true),
    _ctx.type == "text" ? (openBlock(), createElementBlock("div", _hoisted_8, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.categoryChild, (item, index2) => {
        return openBlock(), createElementBlock("div", { key: index2 }, [
          createBaseVNode("div", _hoisted_9, toDisplayString(item == null ? void 0 : item.catName), 1),
          (item == null ? void 0 : item.catType) == 1 ? (openBlock(), createElementBlock("div", _hoisted_10, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(item.childCateList, (sku, key) => {
              return openBlock(), createElementBlock("div", {
                key,
                class: "nut-category-pane__childItem",
                onClick: ($event) => _ctx.onChange(sku)
              }, [
                createBaseVNode("div", _hoisted_12, toDisplayString(sku == null ? void 0 : sku.catName), 1)
              ], 8, _hoisted_11);
            }), 128))
          ])) : createCommentVNode("", true)
        ]);
      }), 128))
    ])) : createCommentVNode("", true),
    _ctx.type == "custom" ? (openBlock(), createElementBlock("div", _hoisted_13, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.customCategory, (sku, key) => {
        return openBlock(), createElementBlock("div", {
          key,
          class: "nut-category-pane__skuName",
          onClick: ($event) => _ctx.onChange(sku)
        }, toDisplayString(sku == null ? void 0 : sku.catName), 9, _hoisted_14);
      }), 128))
    ])) : createCommentVNode("", true)
  ]);
}
const index$2 = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5]]);
const { create: create$3 } = createComponent("comment-header");
const _sfc_main$3 = create$3({
  components: {
    NutRate: _sfc_main$$
  },
  props: {
    type: {
      type: String,
      default: "default"
      // default，complex
    },
    info: {
      type: Object,
      default: () => {
      }
    },
    labels: {
      type: Function,
      default: () => ""
    }
  },
  emits: ["handleClick"],
  setup(props, { emit: emit2 }) {
    const handleClick = () => {
      emit2("handleClick");
    };
    return { handleClick };
  }
});
const _hoisted_1$3 = { class: "nut-comment-header__user" };
const _hoisted_2$3 = { class: "nut-comment-header__user-avter" };
const _hoisted_3$3 = ["src"];
const _hoisted_4$3 = { class: "nut-comment-header__user-score" };
const _hoisted_5$1 = {
  key: 0,
  class: "nut-comment-header__time"
};
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_rate = resolveComponent("nut-rate");
  return openBlock(), createElementBlock("view", null, [
    _ctx.info ? (openBlock(), createElementBlock("view", {
      key: 0,
      class: "nut-comment-header",
      onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    }, [
      createBaseVNode("view", _hoisted_1$3, [
        createBaseVNode("view", _hoisted_2$3, [
          _ctx.info.avatar ? (openBlock(), createElementBlock("img", {
            key: 0,
            src: _ctx.info.avatar
          }, null, 8, _hoisted_3$3)) : createCommentVNode("", true)
        ]),
        _ctx.type == "default" ? (openBlock(), createElementBlock("view", {
          key: 0,
          class: normalizeClass([`nut-comment-header__user-${_ctx.type}`])
        }, [
          createBaseVNode("view", {
            class: normalizeClass([`nut-comment-header__user-${_ctx.type}-name`])
          }, [
            createBaseVNode("span", null, toDisplayString(_ctx.info.nickName), 1),
            renderSlot(_ctx.$slots, "labels")
          ], 2),
          createBaseVNode("view", _hoisted_4$3, [
            createVNode(_component_nut_rate, {
              modelValue: _ctx.info.score,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.info.score = $event),
              size: "12",
              spacing: "5",
              readonly: "",
              onChange: _ctx.handleClick
            }, null, 8, ["modelValue", "onChange"])
          ])
        ], 2)) : (openBlock(), createElementBlock("view", {
          key: 1,
          class: normalizeClass([`nut-comment-header__user-${_ctx.type}`])
        }, [
          createBaseVNode("span", {
            class: normalizeClass([`nut-comment-header__user-${_ctx.type}-name`])
          }, toDisplayString(_ctx.info.nickName), 3),
          renderSlot(_ctx.$slots, "labels")
        ], 2))
      ]),
      _ctx.info.time ? (openBlock(), createElementBlock("view", _hoisted_5$1, toDisplayString(_ctx.info.time), 1)) : createCommentVNode("", true)
    ])) : createCommentVNode("", true),
    _ctx.type == "complex" ? (openBlock(), createElementBlock("view", {
      key: 1,
      class: normalizeClass([`nut-comment-header__${_ctx.type}-score`])
    }, [
      createVNode(_component_nut_rate, {
        modelValue: _ctx.info.score,
        "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.info.score = $event),
        size: "12",
        spacing: "3",
        readonly: ""
      }, null, 8, ["modelValue"]),
      createBaseVNode("i", {
        class: normalizeClass([`nut-comment-header__${_ctx.type}-score-i`])
      }, null, 2),
      createBaseVNode("view", {
        class: normalizeClass([`nut-comment-header__${_ctx.type}-score-size`])
      }, toDisplayString(_ctx.info.size), 3)
    ], 2)) : createCommentVNode("", true)
  ]);
}
const CommentHeader = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3]]);
const { create: create$2 } = createComponent("comment-images");
const _sfc_main$2 = create$2({
  props: {
    type: {
      type: String,
      default: "one"
      // one multi
    },
    videos: {
      type: Array,
      default: () => []
    },
    images: {
      type: Array,
      default: () => []
    }
  },
  components: { Right: w$3 },
  emits: ["click", "clickImages"],
  setup(props, { emit: emit2 }) {
    const isShowImage = ref(false);
    const initIndex2 = ref(1);
    const totalImages = ref([]);
    watch(
      () => [props.videos, props.images],
      (value) => {
        if (value[0].length > 0) {
          value[0].forEach((el) => {
            el.type = "video";
          });
        }
        totalImages.value = value[0].concat(value[1]);
      },
      { deep: true }
    );
    onMounted(() => {
      if (props.videos.length > 0) {
        props.videos.forEach((el) => {
          el.type = "video";
        });
      }
      totalImages.value = props.videos.concat(props.images);
    });
    const showImages = (type, index2) => {
      const { videos, images } = props;
      const i2 = type == "img" ? index2 - videos.length : index2;
      emit2("clickImages", {
        type,
        index: i2,
        value: type == "img" ? images[i2] : videos[i2]
      });
    };
    return { isShowImage, initIndex: initIndex2, showImages, totalImages };
  }
});
const _hoisted_1$2 = ["onClick"];
const _hoisted_2$2 = ["src"];
const _hoisted_3$2 = /* @__PURE__ */ createBaseVNode("view", { class: "nut-comment-images__play" }, null, -1);
const _hoisted_4$2 = ["onClick"];
const _hoisted_5 = ["src"];
const _hoisted_6 = {
  key: 0,
  class: "nut-comment-images__mask"
};
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Right = resolveComponent("Right");
  return openBlock(), createElementBlock("view", {
    class: normalizeClass(`nut-comment-images nut-comment-images--${_ctx.type}`)
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.videos, (itV, index2) => {
      return openBlock(), createElementBlock("view", {
        key: itV.id,
        class: "nut-comment-images__item nut-comment-images__item--video",
        onClick: ($event) => _ctx.showImages("video", index2)
      }, [
        createBaseVNode("img", {
          src: itV.mainUrl
        }, null, 8, _hoisted_2$2),
        _hoisted_3$2
      ], 8, _hoisted_1$2);
    }), 128)),
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.images, (itI, index2) => {
      return openBlock(), createElementBlock(Fragment, {
        key: itI.id
      }, [
        _ctx.type == "multi" && _ctx.videos.length + index2 < 9 || _ctx.type != "multi" ? (openBlock(), createElementBlock("view", {
          key: 0,
          class: "nut-comment-images__item nut-comment-images__item--imgbox",
          onClick: ($event) => _ctx.showImages("img", index2 + _ctx.videos.length)
        }, [
          createBaseVNode("img", {
            src: itI.smallImgUrl ? itI.smallImgUrl : itI.imgUrl
          }, null, 8, _hoisted_5),
          _ctx.type == "multi" && _ctx.totalImages.length > 9 && _ctx.videos.length + index2 > 7 ? (openBlock(), createElementBlock("view", _hoisted_6, [
            createBaseVNode("span", null, "共 " + toDisplayString(_ctx.totalImages.length) + " 张", 1),
            createVNode(_component_Right, { style: { "width": "12px" } })
          ])) : createCommentVNode("", true)
        ], 8, _hoisted_4$2)) : createCommentVNode("", true)
      ], 64);
    }), 128))
  ], 2);
}
const CommentImages = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2]]);
const { create: create$1 } = createComponent("comment-bottom");
const cN$1 = "NutComment";
const _sfc_main$1$1 = create$1({
  props: {
    type: {
      type: String,
      default: "base"
      // simple，base，complex
    },
    info: {
      type: Object,
      default: () => ({})
    },
    operation: {
      type: Array,
      default: ["replay", "like", "more"]
    }
  },
  components: { Fabulous: w$8, Comment: w$a, MoreX: v$5 },
  emits: ["clickOperate", "handleClick"],
  setup(props, { emit: emit2 }) {
    const translate = useLocale(cN$1);
    const showPopver = ref(false);
    const mergeOp = ref([]);
    onMounted(() => {
      const deOp = ["replay", "like", "more"];
      if (props.operation) {
        props.operation.forEach((name) => {
          if (deOp.includes(name)) {
            mergeOp.value.push(name);
          }
        });
      }
    });
    const operate = (type) => {
      if (type == "more") {
        showPopver.value = !showPopver.value;
      }
      emit2("clickOperate", type);
    };
    const handleClick = () => {
      emit2("handleClick");
    };
    return { showPopver, operate, mergeOp, handleClick, translate };
  }
});
const _hoisted_1$1$1 = { class: "nut-comment-bottom" };
const _hoisted_2$1$1 = { key: 0 };
const _hoisted_3$1 = { class: "nut-comment-bottom__cpx" };
const _hoisted_4$1 = ["onClick"];
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Fabulous = resolveComponent("Fabulous");
  const _component_Comment = resolveComponent("Comment");
  const _component_MoreX = resolveComponent("MoreX");
  return openBlock(), createElementBlock("view", _hoisted_1$1$1, [
    createBaseVNode("view", {
      class: "nut-comment-bottom__lable",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    }, [
      _ctx.type != "complex" ? (openBlock(), createElementBlock("span", _hoisted_2$1$1, toDisplayString(_ctx.info.size), 1)) : createCommentVNode("", true)
    ]),
    createBaseVNode("view", _hoisted_3$1, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.mergeOp, (name, i2) => {
        return openBlock(), createElementBlock("view", {
          key: i2,
          class: normalizeClass(["nut-comment-bottom__cpx-item", `nut-comment-bottom__cpx-item--${name}`]),
          onClick: ($event) => _ctx.operate(name)
        }, [
          name != "more" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createBaseVNode("span", null, toDisplayString(_ctx.info[name]), 1),
            name == "like" ? (openBlock(), createBlock(_component_Fabulous, { key: 0 })) : (openBlock(), createBlock(_component_Comment, { key: 1 }))
          ], 64)) : createCommentVNode("", true),
          name == "more" ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createVNode(_component_MoreX),
            _ctx.showPopver ? (openBlock(), createElementBlock("view", {
              key: 0,
              class: "nut-comment-bottom__cpx-item-popover",
              onClick: _cache[1] || (_cache[1] = ($event) => _ctx.operate("popover"))
            }, toDisplayString(_ctx.translate("complaintsText")), 1)) : createCommentVNode("", true)
          ], 64)) : createCommentVNode("", true)
        ], 10, _hoisted_4$1);
      }), 128))
    ])
  ]);
}
const CommentBottom = /* @__PURE__ */ _export_sfc(_sfc_main$1$1, [["render", _sfc_render$1]]);
const { create: create$4 } = createComponent("comment");
const cN = "NutComment";
const _sfc_main$4 = create$4({
  props: {
    headerType: {
      type: String,
      default: "default"
      // 头部展示风格 default，complex
    },
    imagesRows: {
      type: String,
      default: "one"
      // 'one'  'multi'
    },
    ellipsis: {
      type: [String, Number, Boolean],
      default: false
    },
    videos: {
      type: Array,
      default: () => []
    },
    images: {
      type: Array,
      default: () => []
    },
    info: {
      type: Object,
      default: () => ({})
    },
    follow: {
      type: Object,
      default: () => ({})
    },
    labels: {
      type: Function,
      default: () => ""
    },
    operation: {
      type: Array,
      default: ["replay", "like", "more"]
    }
  },
  components: {
    CommentHeader,
    CommentImages,
    CommentBottom,
    Right: w$3
  },
  emits: ["click", "clickImages", "clickOperate"],
  setup(props, { emit: emit2 }) {
    const translate = useLocale(cN);
    const conEllipsis = computed(() => {
      if (props.ellipsis) return props.ellipsis;
      return props.headerType == "complex" ? 6 : 2;
    });
    const clickOperate = (t) => {
      emit2("clickOperate", t);
    };
    const handleClick = () => {
      emit2("click", props.info);
    };
    const clickImages = (value) => {
      emit2("clickImages", value);
    };
    return { conEllipsis, clickOperate, handleClick, clickImages, translate };
  }
});
const _hoisted_1$4 = {
  key: 0,
  class: "nut-comment"
};
const _hoisted_2$4 = ["innerHTML"];
const _hoisted_3$4 = { class: "nut-comment__follow-title" };
const _hoisted_4$4 = { class: "nut-comment__follow-com" };
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_comment_header = resolveComponent("comment-header");
  const _component_comment_images = resolveComponent("comment-images");
  const _component_Right = resolveComponent("Right");
  const _component_comment_bottom = resolveComponent("comment-bottom");
  return _ctx.info && Object.keys(_ctx.info) ? (openBlock(), createElementBlock("view", _hoisted_1$4, [
    createVNode(_component_comment_header, {
      type: _ctx.headerType,
      info: _ctx.info,
      labels: _ctx.labels,
      onHandleClick: _ctx.handleClick
    }, {
      labels: withCtx(() => [
        renderSlot(_ctx.$slots, "comment-labels")
      ]),
      _: 3
    }, 8, ["type", "info", "labels", "onHandleClick"]),
    renderSlot(_ctx.$slots, "feature"),
    createBaseVNode("view", {
      class: "nut-comment__main",
      style: normalizeStyle(`-webkit-line-clamp:${_ctx.conEllipsis}`),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args)),
      innerHTML: _ctx.info.content
    }, null, 12, _hoisted_2$4),
    createVNode(_component_comment_images, {
      images: _ctx.images,
      videos: _ctx.videos,
      type: _ctx.imagesRows,
      onClickImages: _ctx.clickImages
    }, null, 8, ["images", "videos", "type", "onClickImages"]),
    _ctx.follow && _ctx.follow.days > 0 ? (openBlock(), createElementBlock("view", {
      key: 0,
      class: "nut-comment__follow",
      onClick: _cache[2] || (_cache[2] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
    }, [
      createBaseVNode("view", _hoisted_3$4, toDisplayString(_ctx.translate("additionalReview", _ctx.follow.days)), 1),
      createBaseVNode("view", _hoisted_4$4, toDisplayString(_ctx.follow.content), 1),
      _ctx.follow.images && _ctx.follow.images.length > 0 ? (openBlock(), createElementBlock("view", {
        key: 0,
        class: "nut-comment__follow-img",
        onClick: _cache[1] || (_cache[1] = ($event) => _ctx.clickImages(_ctx.follow.images))
      }, [
        createTextVNode(toDisplayString(_ctx.translate("additionalImages", _ctx.follow.images.length)) + " ", 1),
        createVNode(_component_Right, { width: "12px" })
      ])) : createCommentVNode("", true)
    ])) : createCommentVNode("", true),
    createVNode(_component_comment_bottom, {
      type: _ctx.headerType,
      info: _ctx.info,
      operation: _ctx.operation,
      onClickOperate: _ctx.clickOperate,
      onHandleClick: _ctx.handleClick
    }, null, 8, ["type", "info", "operation", "onClickOperate", "onHandleClick"]),
    renderSlot(_ctx.$slots, "comment-shop-reply")
  ])) : createCommentVNode("", true);
}
const index$1 = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4]]);
var __defProp$1 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a2, b) => {
  for (var prop in b)
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a2, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps$1 = (a2, b) => __defProps$1(a2, __getOwnPropDescs$1(b));
const _hoisted_1$1 = { class: "nut-invoice" };
const _hoisted_2$1 = {
  key: 0,
  class: "nut-invoice__submit"
};
const _sfc_main$1 = /* @__PURE__ */ defineComponent(__spreadProps$1(__spreadValues$1({}, {
  name: "NutInvoice"
}), {
  __name: "invoice",
  props: {
    data: { default: () => [] },
    formValue: { default: () => {
    } },
    submit: { type: Boolean, default: true }
  },
  emits: ["submit", "scrollBottom"],
  setup(__props, { emit: __emit }) {
    const emit2 = __emit;
    const formRef = ref();
    const submitFun = () => {
      formRef.value.validate().then(({ valid, errors }) => {
        emit2("submit", valid, errors);
      });
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1, [
        createVNode(unref(_sfc_main$V), {
          ref_key: "formRef",
          ref: formRef,
          "model-value": _ctx.formValue
        }, {
          default: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.data, (item, index2) => {
              return openBlock(), createBlock(unref(_sfc_main$U), {
                key: index2,
                label: item.label,
                required: item.required,
                rules: item.rules,
                prop: item.formItemProp
              }, {
                default: withCtx(() => [
                  item.type === "radio" ? (openBlock(), createBlock(unref(_sfc_main$10), {
                    key: 0,
                    modelValue: _ctx.formValue[item.formItemProp],
                    "onUpdate:modelValue": ($event) => _ctx.formValue[item.formItemProp] = $event
                  }, {
                    default: withCtx(() => [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(item.radioLabel, (radioItem, radioIndex) => {
                        return openBlock(), createBlock(unref(_sfc_main$11), {
                          key: radioIndex,
                          shape: "button",
                          label: radioItem.label
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(radioItem.label), 1)
                          ]),
                          _: 2
                        }, 1032, ["label"]);
                      }), 128))
                    ]),
                    _: 2
                  }, 1032, ["modelValue", "onUpdate:modelValue"])) : (openBlock(), createBlock(unref(_sfc_main$12), {
                    key: 1,
                    modelValue: _ctx.formValue[item.formItemProp],
                    "onUpdate:modelValue": ($event) => _ctx.formValue[item.formItemProp] = $event,
                    class: "nut-input-text",
                    placeholder: item.placeholder,
                    type: "text"
                  }, null, 8, ["modelValue", "onUpdate:modelValue", "placeholder"]))
                ]),
                _: 2
              }, 1032, ["label", "required", "rules", "prop"]);
            }), 128))
          ]),
          _: 1
        }, 8, ["model-value"]),
        _ctx.submit ? (openBlock(), createElementBlock("div", _hoisted_2$1, [
          createVNode(unref(_sfc_main$1G), {
            type: "primary",
            block: "",
            onClick: submitFun
          }, {
            default: withCtx(() => [
              createTextVNode("提交审批")
            ]),
            _: 1
          })
        ])) : createCommentVNode("", true)
      ]);
    };
  }
}));
withInstall(_sfc_main$1);
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __pow = Math.pow;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a2, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a2, prop, b[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b) => __defProps(a2, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve2, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve2(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
const { create } = createComponent("avatar-cropper");
const _sfc_main = create({
  components: {
    NutButton: _sfc_main$1G,
    Refresh2: w$4,
    Retweet: V
  },
  props: {
    maxZoom: {
      type: Number,
      default: 3
    },
    space: {
      type: Number,
      default: 10
    },
    toolbarPosition: {
      type: String,
      default: "bottom"
    },
    editText: {
      type: String,
      default: "编辑"
    },
    cancelText: {
      type: String,
      default: "取消"
    },
    confirmText: {
      type: String,
      default: "确定"
    },
    shape: {
      type: String,
      default: "square"
    }
  },
  emits: ["confirm", "cancel"],
  setup(props, { emit: emit2, expose }) {
    const state = reactive({
      visible: false,
      defScale: 1,
      scale: 1,
      angle: 0,
      moveX: 0,
      moveY: 0,
      moving: false,
      zooming: false,
      displayWidth: 0,
      displayHeight: 0
    });
    const defDrawImage = {
      img: new Image(),
      // 规定要使用的图像
      sx: 0,
      // 开始剪切的 x 坐标位置
      sy: 0,
      // 开始剪切的 y 坐标位置
      swidth: 0,
      // 被剪切区域的宽度
      sheight: 0,
      // 被剪切区域的高度
      x: 0,
      // 在画布上x的坐标位置
      y: 0,
      // 在画布上y的坐标位置
      width: 0,
      // 要使用的图像的宽度
      height: 0
      // 要使用的图像的高度
    };
    const drawImage = ref(__spreadValues({}, defDrawImage));
    const cropperPopupRef = ref();
    const canvasRef = ref();
    const inputImageRef = ref();
    const devicePixelRatio = window.devicePixelRatio || 1;
    const touch = useTouch();
    const isAngle = computed(() => {
      return state.angle === 90 || state.angle === 270;
    });
    const highlightStyle = computed(() => {
      const { swidth } = drawImage.value;
      const width = swidth / devicePixelRatio + "px";
      const height = width;
      return {
        width,
        height
      };
    });
    const maxMoveX = computed(() => {
      const { displayWidth, scale } = state;
      const { swidth, height } = drawImage.value;
      if (isAngle.value) {
        return Math.max(0, (height * scale - swidth) / 2);
      }
      return Math.max(0, (displayWidth * scale - swidth) / 2);
    });
    const maxMoveY = computed(() => {
      const { displayWidth, scale } = state;
      const { swidth, height } = drawImage.value;
      if (isAngle.value) {
        return Math.max(0, (displayWidth * scale - swidth) / 2);
      }
      return Math.max(0, (height * scale - swidth) / 2);
    });
    const fileToDataURL = (file) => {
      return new Promise((resolve2) => {
        const reader = new FileReader();
        reader.onloadend = (e) => resolve2(e.target.result);
        reader.readAsDataURL(file);
      });
    };
    const dataURLToImage = (dataURL) => {
      return new Promise((resolve2) => {
        const img = new Image();
        img.onload = () => resolve2(img);
        img.src = dataURL;
      });
    };
    const draw = () => {
      const { img, width, height, x, y: y2, swidth } = drawImage.value;
      const { moveX, moveY, scale } = state;
      const canvas = canvasRef.value;
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      canvas.width = state.displayWidth;
      canvas.height = state.displayHeight;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#666";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#000";
      ctx.fillRect(props.space * devicePixelRatio, (canvas.height - swidth) / 2, swidth, swidth);
      ctx.translate(canvas.width / 2 + moveX, canvas.height / 2 + moveY);
      ctx.rotate(Math.PI / 180 * state.angle);
      ctx.scale(scale, scale);
      ctx.drawImage(img, x, y2, width, height);
    };
    const setDrawImg = (image) => {
      const rect = useRect(cropperPopupRef.value);
      const { width: clientWidth, height: clientHeight } = rect;
      const canvasWidth = state.displayWidth = clientWidth * devicePixelRatio;
      const canvasHeight = state.displayHeight = clientHeight * devicePixelRatio;
      let drawImg = __spreadValues({}, defDrawImage);
      const { width: imgWidth, height: imgHeight } = image;
      drawImg.img = image;
      const isPortrait = imgHeight > imgWidth;
      const rate = isPortrait ? imgWidth / imgHeight : imgHeight / imgWidth;
      drawImg.width = canvasWidth;
      drawImg.height = isPortrait ? canvasWidth / rate : canvasWidth * rate;
      drawImg.x = -drawImg.width / 2;
      drawImg.y = -drawImg.height / 2;
      drawImg.swidth = canvasWidth - props.space * 2 * devicePixelRatio;
      drawImg.sheight = isPortrait ? drawImg.swidth / rate : drawImg.swidth * rate;
      drawImg.sx = props.space * devicePixelRatio;
      drawImg.sy = (canvasHeight - drawImg.swidth) / 2;
      drawImage.value = drawImg;
      state.defScale = drawImg.swidth / (isPortrait ? drawImg.width : drawImg.height);
      resetScale();
    };
    const inputImageChange = (event) => __async(this, null, function* () {
      state.visible = true;
      const $el = event.target;
      let { files } = $el;
      if (!(files == null ? void 0 : files.length)) return;
      const base64 = yield fileToDataURL(files[0]);
      const image = yield dataURLToImage(base64);
      setDrawImg(image);
      draw();
    });
    const resetScale = () => {
      setScale(state.defScale);
      state.moveX = 0;
      state.moveY = 0;
      state.angle = 0;
    };
    const setScale = (scale) => {
      scale = clamp(scale, 0.3, +props.maxZoom + 1);
      if (scale !== state.scale) {
        state.scale = scale;
      }
    };
    const getDistance = (touches) => Math.sqrt(__pow(touches[0].clientX - touches[1].clientX, 2) + __pow(touches[0].clientY - touches[1].clientY, 2));
    let startMoveX;
    let startMoveY;
    let startScale;
    let startDistance;
    let fingerNum;
    const onTouchStart = (event) => {
      const { touches } = event;
      const { offsetX } = touch;
      touch.start(event);
      fingerNum = touches.length;
      startMoveX = state.moveX;
      startMoveY = state.moveY;
      state.moving = fingerNum === 1;
      state.zooming = fingerNum === 2 && !offsetX.value;
      if (state.zooming) {
        startScale = state.scale;
        startDistance = getDistance(event.touches);
      }
    };
    const onTouchMove = (event) => {
      const { touches } = event;
      touch.move(event);
      if (state.moving || state.zooming) {
        preventDefault(event, true);
      }
      if (state.moving) {
        const { deltaX, deltaY } = touch;
        const moveX = deltaX.value * state.scale + startMoveX;
        const moveY = deltaY.value * state.scale + startMoveY;
        state.moveX = clamp(moveX, -maxMoveX.value, maxMoveX.value);
        state.moveY = clamp(moveY, -maxMoveY.value, maxMoveY.value);
      }
      if (state.zooming && touches.length === 2) {
        const distance = getDistance(touches);
        const scale = startScale * distance / startDistance;
        setScale(scale);
      }
    };
    const onTouchEnd = (event) => {
      let stopPropagation = false;
      if (state.moving || state.zooming) {
        stopPropagation = !(state.moving && startMoveX === state.moveX && startMoveY === state.moveY);
        if (!event.touches.length) {
          if (state.zooming) {
            state.moveX = clamp(state.moveX, -maxMoveX.value, maxMoveX.value);
            state.moveY = clamp(state.moveY, -maxMoveY.value, maxMoveY.value);
            state.zooming = false;
          }
          state.moving = false;
          startMoveX = 0;
          startMoveY = 0;
          startScale = state.defScale;
          if (state.scale < state.defScale) {
            resetScale();
          }
          if (state.scale > props.maxZoom) {
            state.scale = +props.maxZoom;
          }
        }
      }
      preventDefault(event, stopPropagation);
      touch.reset();
    };
    const reset = () => {
      state.angle = 0;
    };
    const rotate = () => {
      if (state.angle === 270) {
        state.angle = 0;
        return;
      }
      state.angle += 90;
    };
    const cancel = (isEmit = true) => {
      state.visible = false;
      resetScale();
      inputImageRef.value.value = "";
      isEmit && emit2("cancel");
    };
    const confirm = () => {
      const canvas = canvasRef.value;
      const { sx, sy, swidth } = drawImage.value;
      const width = swidth;
      const height = swidth;
      const croppedCanvas = document.createElement("canvas");
      const croppedCtx = croppedCanvas.getContext("2d");
      croppedCanvas.width = width;
      croppedCanvas.height = height;
      canvas && croppedCtx.drawImage(canvas, sx, sy, width, height, 0, 0, width, height);
      const imageDataURL = croppedCanvas.toDataURL("image/png");
      emit2("confirm", imageDataURL);
      cancel(false);
    };
    watch(
      () => state.scale,
      () => {
        draw();
      }
    );
    watch(
      () => state.angle,
      () => {
        if (Math.abs(state.moveX) > maxMoveX.value) {
          state.moveX = maxMoveX.value;
        }
        if (Math.abs(state.moveY) > maxMoveY.value) {
          state.moveY = maxMoveY.value;
        }
        draw();
      }
    );
    watch(
      () => state.moveX,
      () => {
        draw();
      }
    );
    watch(
      () => state.moveY,
      () => {
        draw();
      }
    );
    expose({
      cancel,
      reset,
      rotate,
      confirm
    });
    return __spreadProps(__spreadValues({}, toRefs(state)), {
      cropperPopupRef,
      canvasRef,
      inputImageRef,
      highlightStyle,
      inputImageChange,
      reset,
      rotate,
      cancel,
      confirm,
      onTouchStart,
      onTouchMove,
      onTouchEnd
    });
  }
});
const _hoisted_1 = ["data-edit-text"];
const _hoisted_2 = {
  ref: "cropperPopupRef",
  class: "nut-cropper-popup"
};
const _hoisted_3 = {
  ref: "canvasRef",
  class: "nut-cropper-popup__canvas"
};
const _hoisted_4 = {
  key: 1,
  class: "flex-sb"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_nut_button = resolveComponent("nut-button");
  const _component_Refresh2 = resolveComponent("Refresh2");
  const _component_Retweet = resolveComponent("Retweet");
  return openBlock(), createElementBlock(Fragment, null, [
    createBaseVNode("div", {
      class: normalizeClass(["nut-avatar-cropper", { round: _ctx.shape === "round" }]),
      "data-edit-text": _ctx.editText
    }, [
      renderSlot(_ctx.$slots, "default"),
      createBaseVNode("input", {
        ref: "inputImageRef",
        type: "file",
        accept: "image/*",
        class: "nut-avatar-cropper__input",
        onChange: _cache[0] || (_cache[0] = (...args) => _ctx.inputImageChange && _ctx.inputImageChange(...args))
      }, null, 544)
    ], 10, _hoisted_1),
    withDirectives(createBaseVNode("div", _hoisted_2, [
      createBaseVNode("canvas", _hoisted_3, null, 512),
      createBaseVNode("div", {
        class: "nut-cropper-popup__highlight",
        onTouchstart: _cache[1] || (_cache[1] = (...args) => _ctx.onTouchStart && _ctx.onTouchStart(...args)),
        onTouchmove: _cache[2] || (_cache[2] = (...args) => _ctx.onTouchMove && _ctx.onTouchMove(...args)),
        onTouchend: _cache[3] || (_cache[3] = (...args) => _ctx.onTouchEnd && _ctx.onTouchEnd(...args)),
        onTouchcancel: _cache[4] || (_cache[4] = (...args) => _ctx.onTouchEnd && _ctx.onTouchEnd(...args))
      }, [
        createBaseVNode("div", {
          class: normalizeClass(["highlight", { highlight__round: _ctx.shape === "round" }]),
          style: normalizeStyle(_ctx.highlightStyle)
        }, null, 6)
      ], 32),
      createBaseVNode("div", {
        class: normalizeClass(["nut-cropper-popup__toolbar", [_ctx.toolbarPosition]])
      }, [
        _ctx.$slots.toolbar ? renderSlot(_ctx.$slots, "toolbar", { key: 0 }) : (openBlock(), createElementBlock("div", _hoisted_4, [
          createBaseVNode("div", {
            class: "nut-cropper-popup__toolbar-item",
            onClick: _cache[5] || (_cache[5] = ($event) => _ctx.cancel())
          }, [
            createVNode(_component_nut_button, { type: "danger" }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.cancelText), 1)
              ]),
              _: 1
            })
          ]),
          createBaseVNode("div", {
            class: "nut-cropper-popup__toolbar-item",
            onClick: _cache[6] || (_cache[6] = (...args) => _ctx.reset && _ctx.reset(...args))
          }, [
            createVNode(_component_Refresh2, { color: "#fff" })
          ]),
          createBaseVNode("div", {
            class: "nut-cropper-popup__toolbar-item",
            onClick: _cache[7] || (_cache[7] = (...args) => _ctx.rotate && _ctx.rotate(...args))
          }, [
            createVNode(_component_Retweet, { color: "#fff" })
          ]),
          createBaseVNode("div", {
            class: "nut-cropper-popup__toolbar-item",
            onClick: _cache[8] || (_cache[8] = (...args) => _ctx.confirm && _ctx.confirm(...args))
          }, [
            createVNode(_component_nut_button, { type: "success" }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.confirmText), 1)
              ]),
              _: 1
            })
          ])
        ]))
      ], 2)
    ], 512), [
      [vShow, _ctx.visible]
    ])
  ], 64);
}
const index = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
function install(app) {
  const packages = [_sfc_main$1G, _sfc_main$1F, _sfc_main$1E, _sfc_main$1D, NutPopup, _sfc_main$1B, _sfc_main$1A, _sfc_main$1z, _sfc_main$1y, _sfc_main$1x, NutSticky, _sfc_main$1v, _sfc_main$1u, _sfc_main$1t, _sfc_main$1s, _sfc_main$1r, index$E, index$D, index$C, _sfc_main$1n, _sfc_main$1l, NutElevator, index$B, NutTabs, NutTabPane, _sfc_main$1g, index$A, index$z, index$y, NutRange, index$x, index$w, index$v, _sfc_main$18, _sfc_main$17, _sfc_main$16, index$u, _sfc_main$13, _sfc_main$12, _sfc_main$11, _sfc_main$10, _sfc_main$$, NutPicker, index$t, _sfc_main$Z, index$s, index$r, _sfc_main$V, _sfc_main$U, _sfc_main$T, _sfc_main$S, index$q, _sfc_main$Q, index$p, Dialog, index$o, index$n, Notify, _sfc_main$K, Toast, index$m, index$l, NutAvatar, index$k, index$j, _sfc_main$Y, _sfc_main$D, index$i, _sfc_main$B, NutVideo, _sfc_main$z, _sfc_main$y, NutSwiper, NutSwiperItem, _sfc_main$v, ImagePreview, index$h, _sfc_main$s, _sfc_main$1m, _sfc_main$r, NutPopover, _sfc_main$p, _sfc_main$o, _sfc_main$n, index$g, _sfc_main$l, index$f, _sfc_main$j, _sfc_main$i, index$e, index$d, index$c, index$b, index$a, index$9, index$8, index$7, index$6, index$5, index$4, index$3, index$2, index$1, _sfc_main$1, index];
  packages.forEach((item) => {
    if (item.install) {
      app.use(item);
    } else if (item.name) {
      app.component(item.name, item);
    }
  });
}
const version = "4.3.13";
const NutUI = {
  install,
  version
};
(function() {
  var checkRule = function(rule) {
    return true;
  };
  var Command = function() {
    function Command2(cmd) {
      this.callbackIdSequence = 0;
      this.callbackMap = {};
      this.eventMap = {};
      this.from = "src";
      this.version = Command2.sVersion;
      if (cmd) {
        this.callbackIdSequence = cmd.callbackIdSequence;
        this.callbackMap = cmd.callbackMap;
        this.eventMap = cmd.eventMap;
      }
    }
    Command2.prototype.test = function() {
      return "test 测试正常";
    };
    Command2.prototype.getNetworkType = function(options) {
      return this.exec("getNetworkType", options);
    };
    Command2.prototype.showNotification = function(options) {
      return this.exec("showNotification", options);
    };
    Command2.prototype.showShareModal = function(options) {
      return this.exec("showShareModal", options);
    };
    Command2.prototype.playVoice = function(options) {
      return this.exec("playVoice", options);
    };
    Command2.prototype.pauseVoice = function(options) {
      return this.exec("pauseVoice", options);
    };
    Command2.prototype.stopVoice = function(options) {
      return this.exec("stopVoice", options);
    };
    Command2.prototype.startRecord = function(options) {
      return this.exec("startRecord", options);
    };
    Command2.prototype.stopRecord = function(options) {
      return this.exec("stopRecord", options);
    };
    Command2.prototype.uploadVoice = function(options) {
      var task = new UploadTask(this);
      this.execTask("uploadVoice", options, task);
      return task;
    };
    Command2.prototype.onVoicePlayEnd = function(callback) {
      if (typeof callback === "function") {
        this.eventMap["onVoicePlayEnd"] = callback;
      }
    };
    Command2.prototype.onVoiceRecordEnd = function(callback) {
      if (typeof callback === "function") {
        this.eventMap["onVoiceRecordEnd"] = callback;
      }
    };
    Command2.prototype.chooseImage = function(options) {
      return this.exec("chooseImage", options);
    };
    Command2.prototype.chooseAttachments = function(options) {
      return this.exec("chooseAttachments", options);
    };
    Command2.prototype.signUp = function(options) {
      return this.exec("signUp", options);
    };
    Command2.prototype.previewImage = function(options) {
      return this.exec("previewImage", options);
    };
    Command2.prototype.getImageInfo = function(options) {
      return this.exec("getImageInfo", options);
    };
    Command2.prototype.saveImageToPhotosAlbum = function(options) {
      return this.exec("saveImageToPhotosAlbum", options);
    };
    Command2.prototype.scanCode = function(options) {
      return this.exec("scanCode", options);
    };
    Command2.prototype.showHikVision = function(options) {
      return this.exec("showHikVision", options);
    };
    Command2.prototype.showHikVisionV2 = function(options) {
      return this.exec("showHikVisionV2", options);
    };
    Command2.prototype.showHikVisionV3 = function(options) {
      return this.exec("showHikVisionV3", options);
    };
    Command2.prototype.checkSession = function(options) {
      return this.exec("checkSession", options);
    };
    Command2.prototype.getUserInfo = function(options) {
      return this.exec("getUserInfo", options);
    };
    Command2.prototype.setNavigationBarTitle = function(options) {
      return this.exec("setNavigationBarTitle", options);
    };
    Command2.prototype.setCameraTemplate = function(options) {
      return this.exec("setCameraTemplate", options);
    };
    Command2.prototype.setNavigationBarConfig = function(options) {
      var allowKeys = ["title", "style", "backgroundColor", "foregroundColor"];
      var usableKeys = [];
      for (var key in options) {
        if (options.hasOwnProperty(key)) {
          if (allowKeys.indexOf(key) >= 0) {
            usableKeys.push(key);
          }
        }
      }
      options.usableKeys = usableKeys;
      return this.exec("setNavigationBarConfig", options);
    };
    Command2.prototype.getNavigationBarConfig = function(options) {
      return this.exec("getNavigationBarConfig", options);
    };
    Command2.prototype.getSystemInfo = function(options) {
      return this.exec("getSystemInfo", options);
    };
    Command2.prototype.navigateToHome = function(options) {
      return this.exec("navigateToHome", options);
    };
    Command2.prototype.getLocation = function(options) {
      return this.exec("getLocation", options);
    };
    Command2.prototype.closeBLEConnection = function(options) {
      return this.exec("closeBLEConnection", options);
    };
    Command2.prototype.createBLEConnection = function(options) {
      return this.exec("createBLEConnection", options);
    };
    Command2.prototype.getBLEDeviceCharacteristics = function(options) {
      return this.exec("getBLEDeviceCharacteristics", options);
    };
    Command2.prototype.getBLEDeviceServices = function(options) {
      return this.exec("getBLEDeviceServices", options);
    };
    Command2.prototype.onBLEConnectionStateChange = function(callback) {
      if (typeof callback === "function") {
        this.eventMap["onBLEConnectionStateChange"] = callback;
      }
    };
    Command2.prototype.writeBLECharacteristicValue = function(options) {
      return this.exec("writeBLECharacteristicValue", options);
    };
    Command2.prototype.closeBluetoothAdapter = function(options) {
      return this.exec("closeBluetoothAdapter", options);
    };
    Command2.prototype.getBluetoothAdapterState = function(options) {
      return this.exec("getBluetoothAdapterState", options);
    };
    Command2.prototype.getBluetoothDevices = function(options) {
      return this.exec("getBluetoothDevices", options);
    };
    Command2.prototype.showModal = function(options) {
      return this.exec("showModal", options);
    };
    Command2.prototype.showToast = function(options) {
      return this.exec("showToast", options);
    };
    Command2.prototype.getClipboardData = function(options) {
      return this.exec("getClipboardData", options);
    };
    Command2.prototype.setClipboardData = function(options) {
      return this.exec("setClipboardData", options);
    };
    Command2.prototype.openRoutePlanning = function(options) {
      return this.exec("openRoutePlanning", options);
    };
    Command2.prototype.triggerAbort = function(callbackId) {
      if (this.callbackMap[callbackId]) {
        this.internalExecWithCallbackId(callbackId, "taskAbort", {});
      }
    };
    Command2.prototype.triggerEvent = function(name, res) {
      if (res === void 0) {
        res = true;
      }
      var callback = this.eventMap[name];
      if (callback && typeof callback === "function") {
        res = this.transParams(name, res);
        callback.call(this, res);
      }
    };
    Command2.prototype.triggerProgress = function(callbackId, progress, totalBytesSent, totalBytesExpectedToSend) {
      var item = this.callbackMap[callbackId];
      if (item && item.task && item.task instanceof CommandProgressTask) {
        item.task.triggerProgress(progress, totalBytesSent, totalBytesExpectedToSend);
      }
    };
    Command2.prototype.triggerSuccess = function(callbackId, data) {
      if (data === void 0) {
        data = true;
      }
      var item = this.callbackMap[callbackId];
      if (item) {
        delete this.callbackMap[callbackId];
        this.transCallbackData(item.cmd, data);
        item.success && item.success.call(this, data);
      } else {
        var msg = `"ERR_COMMAND_EXEC_CALLBACK", [${callbackId}]`;
        window.console.error(msg);
      }
      return "ok";
    };
    Command2.prototype.triggerFail = function(callbackId, key, values, res) {
      var item = this.callbackMap[callbackId];
      if (item) {
        delete this.callbackMap[callbackId];
        var locale_1 = this.getLocaleMessageConfig(key, values);
        item.fail && item.fail.call(this, locale_1.errMsg, locale_1, res);
      } else {
        var msg = this.getLocaleMessageConfig("ERR_COMMAND_EXEC_CALLBACK", [callbackId]);
        window.console.error(msg);
      }
    };
    Command2.prototype.getLocaleMessageConfig = function(key, values) {
      var msgConfig = null;
      key = key || "ERR_COMMAND_INVOKE";
      msgConfig = Command2.locale.getLocaleByKey(key);
      values = values || ["-1"];
      values.unshift(msgConfig.errMsg);
      msgConfig.errMsg = format.apply(this, values);
      return msgConfig;
    };
    Command2.prototype.transCallbackData = function(cmd, data) {
      if (!cmd || !data) {
        return;
      }
      switch (cmd) {
        case "getBluetoothDevices":
          this.transParamToArrayBuffer("advertisData", data.devices);
          break;
      }
    };
    Command2.prototype.transParams = function(cmd, params) {
      if (!cmd) {
        return params;
      }
      var paramsToTrans = params;
      switch (cmd) {
        case "writeBLECharacteristicValue":
          this.tranParamToNumberArray("value", paramsToTrans);
          break;
        case "onBluetoothDeviceFound":
          this.transParamToArrayBuffer("advertisData", paramsToTrans.devices);
          break;
        case "onBLECharacteristicValueChange":
          this.transParamToArrayBuffer("value", paramsToTrans);
      }
      return paramsToTrans;
    };
    Command2.prototype.tranParamToNumberArray = function(key, params) {
      if (!params || !params[key]) {
        return;
      }
      var arr = Array.prototype.slice.call(params[key]);
      params[key] = arr;
    };
    Command2.prototype.transParamToArrayBuffer = function(key, params) {
      if (!params || params === null) {
        return;
      }
      if (params instanceof Array) {
        params.forEach(function(item) {
          if (item[key] && item[key] instanceof Array) {
            var bufferView2 = new Uint8Array(item[key]);
            item[key] = bufferView2;
          }
        });
        return;
      }
      if (params[key] && params[key] instanceof Array) {
        var bufferView = new Uint8Array(params[key]);
        params[key] = bufferView;
      }
    };
    Command2.prototype.check = function(callbackId, cmd, params) {
      return checkRule();
    };
    Command2.prototype.internalExecWithCallbackId = function(callbackId, cmd, params) {
      var win = window;
      if (this.check(callbackId, cmd, params)) {
        params = this.transParams(cmd, params);
        var message = {
          callbackId,
          command: cmd,
          params
        };
        win.SDKCommand.callHandler("command", message);
      }
    };
    Command2.prototype.internalExec = function(cmd, options, task) {
      var id = "callback_" + this.callbackIdSequence++;
      if (task) {
        task.setCallbackId(id);
      }
      this.callbackMap[id] = {
        fail: options && options.fail,
        success: options && options.success,
        task,
        cmd
      };
      delete options.fail;
      delete options.success;
      this.internalExecWithCallbackId(id, cmd, options);
    };
    Command2.prototype.exec = function(cmd, options) {
      this.internalExec(cmd, options, null);
      return this;
    };
    Command2.prototype.execTask = function(cmd, options, task) {
      this.internalExec(cmd, options, task);
    };
    Command2.sVersion = "1.1.1.1";
    return Command2;
  }();
  if (!window.flutterApp) {
    window.flutterApp = new Command(window.flutterApp);
  }
  return Command;
})();
createApp(App).use(NutUI).mount("#app");</script>
    <style rel="stylesheet" crossorigin>html,
body {
  display: block;
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
}
* {
  margin: 0;
  padding: 0;
}
#app {
  width: 100%;
  height: 100%;
  overflow: hidden;
}
.main-page {
  width: 100%;
  height: 100%;
  overflow: hidden;
  position: absolute;
}
.d-none {
  display: none !important;
}
.d-inline {
  display: inline !important;
}
.d-inline-block {
  display: inline-block !important;
}
.d-block {
  display: block !important;
}
.d-table {
  display: table !important;
}
.d-table-row {
  display: table-row !important;
}
.d-table-cell {
  display: table-cell !important;
}
.d-flex {
  display: flex !important;
}
.d-inline-flex {
  display: inline-flex !important;
}
/*浮动相关*/
.float-none {
  float: none !important;
}
.float-left {
  float: left !important;
}
.float-right {
  float: right !important;
}
/*flex布局相关*/
/*flex属性的默认值为：0 1 auto （不放大会缩小）
flex为none：0 0 auto （不放大也不缩小）
flex为auto：1 1 auto （放大且缩小）*/
.flex-fill {
  /*放大且缩小*/
  flex: 1 1 auto !important;
}
.flex-not-fill {
  /*不放大也不缩小*/
  flex: 0 0 auto !important;
}
.flex-1 {
  flex: 1 1 0 !important;
}
.flex-none {
  flex: none !important;
}
.flex-auto {
  flex: 1 1 auto;
}
.flex-initial {
  flex: 0 1 auto !important;
}
.flex-row {
  flex-direction: row !important;
}
.flex-column {
  flex-direction: column !important;
}
.flex-row-reverse {
  flex-direction: row-reverse !important;
}
.flex-column-reverse {
  flex-direction: column-reverse !important;
}
.flex-grow-0 {
  flex-grow: 0 !important;
}
.flex-grow-1 {
  flex-grow: 1 !important;
}
.flex-shrink-0 {
  flex-shrink: 0 !important;
}
.flex-shrink-1 {
  flex-shrink: 1 !important;
}
.flex-wrap {
  flex-wrap: wrap !important;
}
.flex-nowrap {
  flex-wrap: nowrap !important;
}
.flex-wrap-reverse {
  flex-wrap: wrap-reverse !important;
}
.justify-start {
  justify-content: flex-start !important;
}
.justify-end {
  justify-content: flex-end !important;
}
.justify-center {
  justify-content: center !important;
}
.justify-space-between {
  justify-content: space-between !important;
}
.justify-space-around {
  justify-content: space-around !important;
}
.justify-evenly {
  justify-content: space-evenly;
}
.align-start {
  align-items: flex-start !important;
}
.align-end {
  align-items: flex-end !important;
}
.align-center {
  align-items: center !important;
}
.align-baseline {
  align-items: baseline !important;
}
.align-stretch {
  align-items: stretch !important;
}
.align-content-start {
  align-content: flex-start !important;
}
.align-content-end {
  align-content: flex-end !important;
}
.align-content-center {
  align-content: center !important;
}
.align-content-space-between {
  align-content: space-between !important;
}
.align-content-space-around {
  align-content: space-around !important;
}
.align-content-stretch {
  align-content: stretch !important;
}
.align-self-auto {
  align-self: auto !important;
}
.align-self-start {
  align-self: flex-start !important;
}
.align-self-end {
  align-self: flex-end !important;
}
.align-self-center {
  align-self: center !important;
}
.align-self-baseline {
  align-self: baseline !important;
}
.align-self-stretch {
  align-self: stretch !important;
}
/*margin外边距相关*/
.ma-0 {
  margin: 0 !important;
}
.ma-1 {
  margin: 4px !important;
}
.ma-2 {
  margin: 8px !important;
}
.ma-3 {
  margin: 12px !important;
}
.ma-4 {
  margin: 16px !important;
}
.ma-5 {
  margin: 20px !important;
}
.ma-6 {
  margin: 24px !important;
}
.ma-7 {
  margin: 28px !important;
}
.ma-8 {
  margin: 32px !important;
}
.ma-9 {
  margin: 36px !important;
}
.ma-10 {
  margin: 40px !important;
}
.ma-11 {
  margin: 44px !important;
}
.ma-12 {
  margin: 48px !important;
}
.ma-13 {
  margin: 52px !important;
}
.ma-14 {
  margin: 56px !important;
}
.ma-15 {
  margin: 60px !important;
}
.ma-16 {
  margin: 64px !important;
}
.ma-auto {
  margin: auto !important;
}
.mx-0 {
  margin-right: 0 !important;
  margin-left: 0 !important;
}
.mx-1 {
  margin-right: 4px !important;
  margin-left: 4px !important;
}
.mx-2 {
  margin-right: 8px !important;
  margin-left: 8px !important;
}
.mx-3 {
  margin-right: 12px !important;
  margin-left: 12px !important;
}
.mx-4 {
  margin-right: 16px !important;
  margin-left: 16px !important;
}
.mx-5 {
  margin-right: 20px !important;
  margin-left: 20px !important;
}
.mx-6 {
  margin-right: 24px !important;
  margin-left: 24px !important;
}
.mx-7 {
  margin-right: 28px !important;
  margin-left: 28px !important;
}
.mx-8 {
  margin-right: 32px !important;
  margin-left: 32px !important;
}
.mx-9 {
  margin-right: 36px !important;
  margin-left: 36px !important;
}
.mx-10 {
  margin-right: 40px !important;
  margin-left: 40px !important;
}
.mx-11 {
  margin-right: 44px !important;
  margin-left: 44px !important;
}
.mx-12 {
  margin-right: 48px !important;
  margin-left: 48px !important;
}
.mx-13 {
  margin-right: 52px !important;
  margin-left: 52px !important;
}
.mx-14 {
  margin-right: 56px !important;
  margin-left: 56px !important;
}
.mx-15 {
  margin-right: 60px !important;
  margin-left: 60px !important;
}
.mx-16 {
  margin-right: 64px !important;
  margin-left: 64px !important;
}
.mx-auto {
  margin-right: auto !important;
  margin-left: auto !important;
}
.my-0 {
  margin-top: 0 !important;
  margin-bottom: 0 !important;
}
.my-1 {
  margin-top: 4px !important;
  margin-bottom: 4px !important;
}
.my-2 {
  margin-top: 8px !important;
  margin-bottom: 8px !important;
}
.my-3 {
  margin-top: 12px !important;
  margin-bottom: 12px !important;
}
.my-4 {
  margin-top: 16px !important;
  margin-bottom: 16px !important;
}
.my-5 {
  margin-top: 20px !important;
  margin-bottom: 20px !important;
}
.my-6 {
  margin-top: 24px !important;
  margin-bottom: 24px !important;
}
.my-7 {
  margin-top: 28px !important;
  margin-bottom: 28px !important;
}
.my-8 {
  margin-top: 32px !important;
  margin-bottom: 32px !important;
}
.my-9 {
  margin-top: 36px !important;
  margin-bottom: 36px !important;
}
.my-10 {
  margin-top: 40px !important;
  margin-bottom: 40px !important;
}
.my-11 {
  margin-top: 44px !important;
  margin-bottom: 44px !important;
}
.my-12 {
  margin-top: 48px !important;
  margin-bottom: 48px !important;
}
.my-13 {
  margin-top: 52px !important;
  margin-bottom: 52px !important;
}
.my-14 {
  margin-top: 56px !important;
  margin-bottom: 56px !important;
}
.my-15 {
  margin-top: 60px !important;
  margin-bottom: 60px !important;
}
.my-16 {
  margin-top: 64px !important;
  margin-bottom: 64px !important;
}
.my-auto {
  margin-top: auto !important;
  margin-bottom: auto !important;
}
.mt-0 {
  margin-top: 0 !important;
}
.mt-1 {
  margin-top: 4px !important;
}
.mt-2 {
  margin-top: 8px !important;
}
.mt-3 {
  margin-top: 12px !important;
}
.mt-4 {
  margin-top: 16px !important;
}
.mt-5 {
  margin-top: 20px !important;
}
.mt-6 {
  margin-top: 24px !important;
}
.mt-7 {
  margin-top: 28px !important;
}
.mt-8 {
  margin-top: 32px !important;
}
.mt-9 {
  margin-top: 36px !important;
}
.mt-10 {
  margin-top: 40px !important;
}
.mt-11 {
  margin-top: 44px !important;
}
.mt-12 {
  margin-top: 48px !important;
}
.mt-13 {
  margin-top: 52px !important;
}
.mt-14 {
  margin-top: 56px !important;
}
.mt-15 {
  margin-top: 60px !important;
}
.mt-16 {
  margin-top: 64px !important;
}
.mt-auto {
  margin-top: auto !important;
}
.mr-0 {
  margin-right: 0 !important;
}
.mr-1 {
  margin-right: 4px !important;
}
.mr-2 {
  margin-right: 8px !important;
}
.mr-3 {
  margin-right: 12px !important;
}
.mr-4 {
  margin-right: 16px !important;
}
.mr-5 {
  margin-right: 20px !important;
}
.mr-6 {
  margin-right: 24px !important;
}
.mr-7 {
  margin-right: 28px !important;
}
.mr-8 {
  margin-right: 32px !important;
}
.mr-9 {
  margin-right: 36px !important;
}
.mr-10 {
  margin-right: 40px !important;
}
.mr-11 {
  margin-right: 44px !important;
}
.mr-12 {
  margin-right: 48px !important;
}
.mr-13 {
  margin-right: 52px !important;
}
.mr-14 {
  margin-right: 56px !important;
}
.mr-15 {
  margin-right: 60px !important;
}
.mr-16 {
  margin-right: 64px !important;
}
.mr-auto {
  margin-right: auto !important;
}
.mb-0 {
  margin-bottom: 0 !important;
}
.mb-1 {
  margin-bottom: 4px !important;
}
.mb-2 {
  margin-bottom: 8px !important;
}
.mb-3 {
  margin-bottom: 12px !important;
}
.mb-4 {
  margin-bottom: 16px !important;
}
.mb-5 {
  margin-bottom: 20px !important;
}
.mb-6 {
  margin-bottom: 24px !important;
}
.mb-7 {
  margin-bottom: 28px !important;
}
.mb-8 {
  margin-bottom: 32px !important;
}
.mb-9 {
  margin-bottom: 36px !important;
}
.mb-10 {
  margin-bottom: 40px !important;
}
.mb-11 {
  margin-bottom: 44px !important;
}
.mb-12 {
  margin-bottom: 48px !important;
}
.mb-13 {
  margin-bottom: 52px !important;
}
.mb-14 {
  margin-bottom: 56px !important;
}
.mb-15 {
  margin-bottom: 60px !important;
}
.mb-16 {
  margin-bottom: 64px !important;
}
.mb-auto {
  margin-bottom: auto !important;
}
.ml-0 {
  margin-left: 0 !important;
}
.ml-1 {
  margin-left: 4px !important;
}
.ml-2 {
  margin-left: 8px !important;
}
.ml-3 {
  margin-left: 12px !important;
}
.ml-4 {
  margin-left: 16px !important;
}
.ml-5 {
  margin-left: 20px !important;
}
.ml-6 {
  margin-left: 24px !important;
}
.ml-7 {
  margin-left: 28px !important;
}
.ml-8 {
  margin-left: 32px !important;
}
.ml-9 {
  margin-left: 36px !important;
}
.ml-10 {
  margin-left: 40px !important;
}
.ml-11 {
  margin-left: 44px !important;
}
.ml-12 {
  margin-left: 48px !important;
}
.ml-13 {
  margin-left: 52px !important;
}
.ml-14 {
  margin-left: 56px !important;
}
.ml-15 {
  margin-left: 60px !important;
}
.ml-16 {
  margin-left: 64px !important;
}
.ml-auto {
  margin-left: auto !important;
}
/*padding内边距相关*/
.pa-0 {
  padding: 0 !important;
}
.pa-1 {
  padding: 4px !important;
}
.pa-2 {
  padding: 8px !important;
}
.pa-3 {
  padding: 12px !important;
}
.pa-4 {
  padding: 16px !important;
}
.pa-5 {
  padding: 20px !important;
}
.pa-6 {
  padding: 24px !important;
}
.pa-7 {
  padding: 28px !important;
}
.pa-8 {
  padding: 32px !important;
}
.pa-9 {
  padding: 36px !important;
}
.pa-10 {
  padding: 40px !important;
}
.pa-11 {
  padding: 44px !important;
}
.pa-12 {
  padding: 48px !important;
}
.pa-13 {
  padding: 52px !important;
}
.pa-14 {
  padding: 56px !important;
}
.pa-15 {
  padding: 60px !important;
}
.pa-16 {
  padding: 64px !important;
}
.px-0 {
  padding-right: 0 !important;
  padding-left: 0 !important;
}
.px-1 {
  padding-right: 4px !important;
  padding-left: 4px !important;
}
.px-2 {
  padding-right: 8px !important;
  padding-left: 8px !important;
}
.px-3 {
  padding-right: 12px !important;
  padding-left: 12px !important;
}
.px-4 {
  padding-right: 16px !important;
  padding-left: 16px !important;
}
.px-5 {
  padding-right: 20px !important;
  padding-left: 20px !important;
}
.px-6 {
  padding-right: 24px !important;
  padding-left: 24px !important;
}
.px-7 {
  padding-right: 28px !important;
  padding-left: 28px !important;
}
.px-8 {
  padding-right: 32px !important;
  padding-left: 32px !important;
}
.px-9 {
  padding-right: 36px !important;
  padding-left: 36px !important;
}
.px-10 {
  padding-right: 40px !important;
  padding-left: 40px !important;
}
.px-11 {
  padding-right: 44px !important;
  padding-left: 44px !important;
}
.px-12 {
  padding-right: 48px !important;
  padding-left: 48px !important;
}
.px-13 {
  padding-right: 52px !important;
  padding-left: 52px !important;
}
.px-14 {
  padding-right: 56px !important;
  padding-left: 56px !important;
}
.px-15 {
  padding-right: 60px !important;
  padding-left: 60px !important;
}
.px-16 {
  padding-right: 64px !important;
  padding-left: 64px !important;
}
.py-0 {
  padding-top: 0 !important;
  padding-bottom: 0 !important;
}
.py-1 {
  padding-top: 4px !important;
  padding-bottom: 4px !important;
}
.py-2 {
  padding-top: 8px !important;
  padding-bottom: 8px !important;
}
.py-3 {
  padding-top: 12px !important;
  padding-bottom: 12px !important;
}
.py-4 {
  padding-top: 16px !important;
  padding-bottom: 16px !important;
}
.py-5 {
  padding-top: 20px !important;
  padding-bottom: 20px !important;
}
.py-6 {
  padding-top: 24px !important;
  padding-bottom: 24px !important;
}
.py-7 {
  padding-top: 28px !important;
  padding-bottom: 28px !important;
}
.py-8 {
  padding-top: 32px !important;
  padding-bottom: 32px !important;
}
.py-9 {
  padding-top: 36px !important;
  padding-bottom: 36px !important;
}
.py-10 {
  padding-top: 40px !important;
  padding-bottom: 40px !important;
}
.py-11 {
  padding-top: 44px !important;
  padding-bottom: 44px !important;
}
.py-12 {
  padding-top: 48px !important;
  padding-bottom: 48px !important;
}
.py-13 {
  padding-top: 52px !important;
  padding-bottom: 52px !important;
}
.py-14 {
  padding-top: 56px !important;
  padding-bottom: 56px !important;
}
.py-15 {
  padding-top: 60px !important;
  padding-bottom: 60px !important;
}
.py-16 {
  padding-top: 64px !important;
  padding-bottom: 64px !important;
}
.pt-0 {
  padding-top: 0 !important;
}
.pt-1 {
  padding-top: 4px !important;
}
.pt-2 {
  padding-top: 8px !important;
}
.pt-3 {
  padding-top: 12px !important;
}
.pt-4 {
  padding-top: 16px !important;
}
.pt-5 {
  padding-top: 20px !important;
}
.pt-6 {
  padding-top: 24px !important;
}
.pt-7 {
  padding-top: 28px !important;
}
.pt-8 {
  padding-top: 32px !important;
}
.pt-9 {
  padding-top: 36px !important;
}
.pt-10 {
  padding-top: 40px !important;
}
.pt-11 {
  padding-top: 44px !important;
}
.pt-12 {
  padding-top: 48px !important;
}
.pt-13 {
  padding-top: 52px !important;
}
.pt-14 {
  padding-top: 56px !important;
}
.pt-15 {
  padding-top: 60px !important;
}
.pt-16 {
  padding-top: 64px !important;
}
.pr-0 {
  padding-right: 0 !important;
}
.pr-1 {
  padding-right: 4px !important;
}
.pr-2 {
  padding-right: 8px !important;
}
.pr-3 {
  padding-right: 12px !important;
}
.pr-4 {
  padding-right: 16px !important;
}
.pr-5 {
  padding-right: 20px !important;
}
.pr-6 {
  padding-right: 24px !important;
}
.pr-7 {
  padding-right: 28px !important;
}
.pr-8 {
  padding-right: 32px !important;
}
.pr-9 {
  padding-right: 36px !important;
}
.pr-10 {
  padding-right: 40px !important;
}
.pr-11 {
  padding-right: 44px !important;
}
.pr-12 {
  padding-right: 48px !important;
}
.pr-13 {
  padding-right: 52px !important;
}
.pr-14 {
  padding-right: 56px !important;
}
.pr-15 {
  padding-right: 60px !important;
}
.pr-16 {
  padding-right: 64px !important;
}
.pb-0 {
  padding-bottom: 0 !important;
}
.pb-1 {
  padding-bottom: 4px !important;
}
.pb-2 {
  padding-bottom: 8px !important;
}
.pb-3 {
  padding-bottom: 12px !important;
}
.pb-4 {
  padding-bottom: 16px !important;
}
.pb-5 {
  padding-bottom: 20px !important;
}
.pb-6 {
  padding-bottom: 24px !important;
}
.pb-7 {
  padding-bottom: 28px !important;
}
.pb-8 {
  padding-bottom: 32px !important;
}
.pb-9 {
  padding-bottom: 36px !important;
}
.pb-10 {
  padding-bottom: 40px !important;
}
.pb-11 {
  padding-bottom: 44px !important;
}
.pb-12 {
  padding-bottom: 48px !important;
}
.pb-13 {
  padding-bottom: 52px !important;
}
.pb-14 {
  padding-bottom: 56px !important;
}
.pb-15 {
  padding-bottom: 60px !important;
}
.pb-16 {
  padding-bottom: 64px !important;
}
.pl-0 {
  padding-left: 0 !important;
}
.pl-1 {
  padding-left: 4px !important;
}
.pl-2 {
  padding-left: 8px !important;
}
.pl-3 {
  padding-left: 12px !important;
}
.pl-4 {
  padding-left: 16px !important;
}
.pl-5 {
  padding-left: 20px !important;
}
.pl-6 {
  padding-left: 24px !important;
}
.pl-7 {
  padding-left: 28px !important;
}
.pl-8 {
  padding-left: 32px !important;
}
.pl-9 {
  padding-left: 36px !important;
}
.pl-10 {
  padding-left: 40px !important;
}
.pl-11 {
  padding-left: 44px !important;
}
.pl-12 {
  padding-left: 48px !important;
}
.pl-13 {
  padding-left: 52px !important;
}
.pl-14 {
  padding-left: 56px !important;
}
.pl-15 {
  padding-left: 60px !important;
}
.pl-16 {
  padding-left: 64px !important;
}
.select-none {
  user-select: none !important;
}
/*字体大小*/
.text-20 {
  font-size: 20px;
}
.text-18 {
  font-size: 18px;
}
.text-16 {
  font-size: 16px;
}
.text-14 {
  font-size: 14px;
}
.text-12 {
  font-size: 12px;
}
.elevation-3 {
  box-shadow: 0 3px 3px -2px rgba(0, 0, 0, 0.2), 0px 3px 4px 0px rgba(0, 0, 0, 0.14), 0px 1px 8px 0px rgba(0, 0, 0, 0.12) !important;
}
.elevation-2 {
  box-shadow: 0 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12) !important;
}
.elevation-1 {
  box-shadow: 0px 2px 1px -1px rgba(0, 0, 0, 0.2), 0px 1px 1px 0px rgba(0, 0, 0, 0.14), 0px 1px 3px 0px rgba(0, 0, 0, 0.12) !important;
}
.elevation-0 {
  box-shadow: 0px 0px 0px 0px rgba(0, 0, 0, 0.2), 0px 0px 0px 0px rgba(0, 0, 0, 0.14), 0px 0px 0px 0px rgba(0, 0, 0, 0.12) !important;
}
/*文本对齐*/
.text-left {
  text-align: left !important;
}
.text-right {
  text-align: right !important;
}
.text-center {
  text-align: center !important;
}
.text-justify {
  text-align: justify !important;
}
.text-wrap {
  white-space: normal !important;
}
.text-no-wrap {
  white-space: nowrap !important;
}
.text-pre {
  white-space: pre !important;
}
.text-pre-line {
  white-space: pre-line !important;
}
.text-pre-wrap {
  white-space: pre-wrap !important;
}
.text-break {
  overflow-wrap: break-word !important;
  word-break: break-word !important;
}
.text-break-all {
  overflow-wrap: break-word !important;
  word-break: break-all !important;
}
.text-truncate {
  white-space: nowrap !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
}
.text-none {
  text-transform: none !important;
}
.text-capitalize {
  text-transform: capitalize !important;
}
.text-lowercase {
  text-transform: lowercase !important;
}
.text-uppercase {
  text-transform: uppercase !important;
}
.text-weight {
  font-weight: 700 !important;
}
/*定位相关*/
.absolute {
  position: absolute;
}
.absolute-position {
  width: 100%;
  height: 100%;
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
}
.relative {
  position: relative;
}
.fixed {
  position: fixed;
}
.static {
  position: static !important;
}
.sticky {
  position: sticky;
}
/*盒子模型*/
.box-border {
  box-sizing: border-box !important;
}
.box-content {
  box-sizing: content-box !important;
}
/*鼠标样式*/
.cursor-auto {
  cursor: auto;
}
.cursor-default {
  cursor: default;
}
.cursor-pointer {
  cursor: pointer;
}
.cursor-move {
  cursor: move;
}
.cursor-help {
  cursor: help;
}
.cursor-grab {
  cursor: grab;
}
/*Overflow*/
.overflow-auto {
  overflow: auto;
}
.overflow-hidden {
  overflow: hidden;
}
.overflow-visible {
  overflow: visible;
}
.overflow-scroll {
  overflow: scroll;
}
.overflow-x-auto {
  overflow-x: auto;
}
.overflow-y-auto {
  overflow-y: auto;
}
.overflow-x-hidden {
  overflow-x: hidden;
}
.overflow-y-hidden {
  overflow-y: hidden;
}
.overflow-x-visible {
  overflow-x: visible;
}
.overflow-y-visible {
  overflow-y: visible;
}
.overflow-x-scroll {
  overflow-x: scroll;
}
.overflow-y-scroll {
  overflow-y: scroll;
}
.italic {
  font-style: italic;
}
.not-italic {
  font-style: normal;
}
.font-normal {
  font-weight: 400;
}
.font-medium {
  font-weight: 500;
}
.font-semibold {
  font-weight: 600;
}
.font-bold {
  font-weight: 700;
}
.font-extrabold {
  font-weight: 800;
}
.font-black {
  font-weight: 900;
}
.line-through {
  text-decoration-line: line-through;
}
.underline {
  text-decoration: underline;
}
.no-underline {
  text-decoration: none;
}
.decoration-solid {
  text-decoration-style: solid;
}
.decoration-double {
  text-decoration-style: double;
}
.decoration-dotted {
  text-decoration-style: dotted;
}
.decoration-dashed {
  text-decoration-style: dashed;
}
.disabled {
  background-color: rgba(0, 0, 0, 0.12) !important;
  color: #5c5a5a !important;
  pointer-events: none;
  cursor: not-allowed !important;
}
/*border*/
.rounded-none {
  border-radius: 0 !important;
}
.rounded-sm {
  border-radius: 5px !important;
}
/*行高*/
.leading-none {
  line-height: 1;
}
.leading-tight {
  line-height: 1.25;
}
.leading-snug {
  line-height: 1.375;
}
.leading-normal {
  line-height: 1.5;
}
.leading-relaxed {
  line-height: 1.625;
}
.leading-loose {
  line-height: 2;
}
/*文本换行*/
.break-normal {
  overflow-wrap: normal;
  word-break: normal;
}
.break-words {
  overflow-wrap: break-word;
}
.break-all {
  word-break: break-all;
}
/*背景色*/
.bg-black {
  background-color: #000000;
}
.bg-black-500 {
  background-color: rgba(0, 0, 0, 0.5);
}
.bg-black-600 {
  background-color: rgba(0, 0, 0, 0.6);
}
.bg-white {
  background-color: #ffffff;
}
/*Object Fit
用于控制可替换元素的内容如何调整大小的功能类
*/
/*保持原有尺寸比例。内容被缩放。*/
.object-contain {
  object-fit: contain;
}
/*保持原有尺寸比例。但部分内容可能被剪切。*/
.object-cover {
  object-fit: cover;
}
/*默认，不保证保持原有的比例，内容拉伸填充整个内容容器。*/
.object-fill {
  object-fit: fill;
}
/*保留原有元素内容的长度和宽度，也就是说内容不会被重置。*/
.object-none {
  object-fit: none;
}
/*高度*/
.min-h-full {
  min-height: 100%;
}
.min-h-screen {
  min-height: 100vh;
}
.min-w-full {
  min-width: 100%;
}
.w-full {
  width: 100% !important;
}
.w-screen {
  width: 100vw;
}
.h-full {
  height: 100%;
}
.h-screen {
  height: 100vh;
}
.full-container {
  width: 100%;
  height: 100%;
}
.full-screen {
  width: 100vw;
  height: 100vh;
}
/*用于控制定位元素的位置的功能类*/
.inset-0 {
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
}
.inset-y-0 {
  top: 0;
  bottom: 0;
}
.inset-x-0 {
  right: 0;
  left: 0;
}
.top-0 {
  top: 0;
}
.right-0 {
  right: 0;
}
.bottom-0 {
  bottom: 0;
}
.left-0 {
  left: 0;
}
/*边框*/
.border {
  border-width: 1px !important;
}
.border-0 {
  border-width: 0px;
}
.border-2 {
  border-width: 2px;
}
.border-4 {
  border-width: 4px;
}
.border-8 {
  border-width: 8px;
}
.border {
  border-width: 1px;
}
.border-t-0 {
  border-top-width: 0px;
}
.border-t-2 {
  border-top-width: 2px;
}
.border-t-4 {
  border-top-width: 4px;
}
.border-t-8 {
  border-top-width: 8px;
}
.border-t {
  border-top-width: 1px;
}
.border-r-0 {
  border-right-width: 0px;
}
.border-r-2 {
  border-right-width: 2px;
}
.border-r-4 {
  border-right-width: 4px;
}
.border-r-8 {
  border-right-width: 8px;
}
.border-r {
  border-right-width: 1px;
}
.border-b-0 {
  border-bottom-width: 0px;
}
.border-b-2 {
  border-bottom-width: 2px;
}
.border-b-4 {
  border-bottom-width: 4px;
}
.border-b-8 {
  border-bottom-width: 8px;
}
.border-b {
  border-bottom-width: 1px;
}
.border-l-0 {
  border-left-width: 0px;
}
.border-l-2 {
  border-left-width: 2px;
}
.border-l-4 {
  border-left-width: 4px;
}
.border-l-8 {
  border-left-width: 8px;
}
.border-l {
  border-left-width: 1px;
}
.border-primary {
  border-color: #2c82f3;
}
.border-solid {
  border-style: solid !important;
}
.border-dashed {
  border-style: dashed;
}
.border-dotted {
  border-style: dotted;
}
.border-double {
  border-style: double;
}
.border-none {
  border-style: none;
}
/*边框圆角
用于控制元素边框半径的功能类。*/
.rounded-none {
  border-radius: 0;
}
.rounded-2 {
  border-radius: 2px;
}
.rounded-4 {
  border-radius: 4px;
}
.rounded-6 {
  border-radius: 6px;
}
.rounded-8 {
  border-radius: 8px;
}
.rounded-10 {
  border-radius: 10px;
}
/*不规范*/
.red-border {
  border: 1px solid red;
}
.text-red {
  color: red !important;
}
/*.text-primary {
  color: --var(primary) !important;
}*/
.text-transparent {
  color: transparent !important;
}
.text-black {
  color: #000000;
}
.text-white {
  color: #ffffff;
}
textarea::-webkit-input-placeholder {
  font-size: 12px;
}
textarea::-moz-placeholder {
  font-size: 12px;
}

.logo[data-v-e2d7068a] {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo[data-v-e2d7068a]:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.vue[data-v-e2d7068a]:hover {
  filter: drop-shadow(0 0 2em #42b883aa);
}
:root{--nut-icon-height: 16px;--nut-icon-width: 16px;--nut-icon-line-height: 16px;--animate-duration: 1s;--animate-delay: 0s}page{--nut-icon-height: 20px;--nut-icon-width: 20px;--nut-icon-line-height: 20px;--animate-duration: 1s;--animate-delay: 0s}.nut-icon{display:inline-block;position:relative;width:var(--nut-icon-width);height:var(--nut-icon-height);line-height:var(--nut-icon-line-height);text-align:right}.nut-icon:before{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%)}.nut-icon__img{width:var(--nut-icon-width);height:var(--nut-icon-height);object-fit:contain}.nut-icon-loading,.nut-icon-loading1{display:inline-block;animation:rotation 1s infinite linear}.nut-icon-am-infinite{-webkit-animation-iteration-count:infinite;-webkit-animation-direction:alternate;animation-iteration-count:infinite;animation-direction:alternate}.nut-icon-am-jump{-webkit-animation-name:nutJumpOne;-webkit-animation-duration:var(--animate-duration);-webkit-animation-timing-function:ease;-webkit-animation-delay:var(--animate-delay);animation-name:nutJumpOne;animation-duration:var(--animate-duration);animation-timing-function:ease;animation-delay:var(--animate-delay)}.nut-icon-am-jump.nut-icon-am-infinite{-webkit-animation-name:nutJump;animation-name:nutJump}.nut-icon-am-rotate{-webkit-animation-name:rotation;-webkit-animation-duration:var(--animate-duration);-webkit-animation-timing-function:linear;-webkit-animation-delay:var(--animate-delay);animation-name:rotation;animation-duration:var(--animate-duration);animation-timing-function:linear;animation-delay:var(--animate-delay)}.nut-icon-am-rotate.nut-icon-am-infinite{-webkit-animation-direction:normal;animation-direction:normal}.nut-icon-am-blink{-webkit-animation-name:nutBlink;-webkit-animation-duration:var(--animate-duration);-webkit-animation-timing-function:ease-in-out;-webkit-animation-delay:var(--animate-delay);animation-name:nutBlink;animation-duration:var(--animate-duration);animation-timing-function:linear;animation-delay:var(--animate-delay)}.nut-icon-am-breathe{-webkit-animation-name:nutBreathe;-webkit-animation-duration:var(--animate-duration);-webkit-animation-timing-function:ease-in-out;-webkit-animation-delay:var(--animate-delay);animation-name:nutBreathe;animation-duration:var(--animate-duration);animation-timing-function:ease-in-out;animation-delay:var(--animate-delay)}.nut-icon-am-flash{-webkit-animation-name:nutFlash;-webkit-animation-duration:var(--animate-duration);-webkit-animation-timing-function:ease-in-out;-webkit-animation-delay:var(--animate-delay);animation-name:nutFlash;animation-duration:var(--animate-duration);animation-timing-function:ease-in-out;animation-delay:var(--animate-delay)}.nut-icon-am-bounce{-webkit-animation-name:nutBounce;-webkit-animation-duration:var(--animate-duration);-webkit-animation-timing-function:ease-in-out;-webkit-animation-delay:var(--animate-delay);animation-name:nutBounce;animation-duration:var(--animate-duration);animation-timing-function:ease-in-out;animation-delay:var(--animate-delay)}.nut-icon-am-bounce.nut-icon-am-infinite{-webkit-animation-direction:normal;animation-direction:normal}.nut-icon-am-shake{-webkit-animation-name:nutShake;-webkit-animation-duration:var(--animate-duration);-webkit-animation-timing-function:ease-in-out;-webkit-animation-delay:var(--animate-delay);animation-name:nutShake;animation-duration:var(--animate-duration);animation-timing-function:ease-in-out;animation-delay:var(--animate-delay)}@keyframes rotation{0%{-webkit-transform:rotate(0deg)}to{-webkit-transform:rotate(360deg)}}@-webkit-keyframes nutJump{to{transform:scale3d(.8,1,.9) translateY(-10px)}}@keyframes nutJump{to{transform:scale3d(.8,1,.9) translateY(-10px)}}@-webkit-keyframes nutJumpOne{50%{transform:scale3d(.8,1,.9) translateY(-10px)}to{transform:scaleZ(1) translateY(0)}}@keyframes nutJumpOne{50%{transform:scale3d(.8,1,.9) translateY(-10px)}to{transform:scaleZ(1) translateY(0)}}@-webkit-keyframes nutBlink{0%{opacity:0}to{opacity:1}}@keyframes nutBlink{0%{opacity:0}to{opacity:1}}@-webkit-keyframes nutBreathe{0%,to{transform:scale(1)}50%{transform:scale(1.2)}}@keyframes nutBreathe{0%,to{transform:scale(1)}50%{transform:scale(1.2)}}@-webkit-keyframes nutFlash{0%,50%,to{opacity:1}25%,75%{opacity:0}}@keyframes nutFlash{0%,50%,to{opacity:1}25%,75%{opacity:0}}@-webkit-keyframes nutBounce{0%,20%,53%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1);-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}40%,43%{-webkit-animation-timing-function:cubic-bezier(.755,.05,.855,.06);animation-timing-function:cubic-bezier(.755,.05,.855,.06);-webkit-transform:translate3d(0,-30px,0) scaleY(1.1);transform:translate3d(0,-30px,0) scaleY(1.1)}70%{-webkit-animation-timing-function:cubic-bezier(.755,.05,.855,.06);animation-timing-function:cubic-bezier(.755,.05,.855,.06);-webkit-transform:translate3d(0,-15px,0) scaleY(1.05);transform:translate3d(0,-15px,0) scaleY(1.05)}80%{-webkit-transition-timing-function:cubic-bezier(.215,.61,.355,1);transition-timing-function:cubic-bezier(.215,.61,.355,1);-webkit-transform:translate3d(0,0,0) scaleY(.95);transform:translateZ(0) scaleY(.95)}90%{-webkit-transform:translate3d(0,-4px,0) scaleY(1.02);transform:translate3d(0,-4px,0) scaleY(1.02)}}@keyframes nutBounce{0%,20%,53%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1);-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}40%,43%{-webkit-animation-timing-function:cubic-bezier(.755,.05,.855,.06);animation-timing-function:cubic-bezier(.755,.05,.855,.06);-webkit-transform:translate3d(0,-30px,0) scaleY(1.1);transform:translate3d(0,-30px,0) scaleY(1.1)}70%{-webkit-animation-timing-function:cubic-bezier(.755,.05,.855,.06);animation-timing-function:cubic-bezier(.755,.05,.855,.06);-webkit-transform:translate3d(0,-15px,0) scaleY(1.05);transform:translate3d(0,-15px,0) scaleY(1.05)}80%{-webkit-transition-timing-function:cubic-bezier(.215,.61,.355,1);transition-timing-function:cubic-bezier(.215,.61,.355,1);-webkit-transform:translate3d(0,0,0) scaleY(.95);transform:translateZ(0) scaleY(.95)}90%{-webkit-transform:translate3d(0,-4px,0) scaleY(1.02);transform:translate3d(0,-4px,0) scaleY(1.02)}}@-webkit-keyframes nutShake{0%{-webkit-transform:translateX(0);transform:translate(0)}6.5%{-webkit-transform:translateX(-6px) rotateY(-9deg);transform:translate(-6px) rotateY(-9deg)}18.5%{-webkit-transform:translateX(5px) rotateY(7deg);transform:translate(5px) rotateY(7deg)}31.5%{-webkit-transform:translateX(-3px) rotateY(-5deg);transform:translate(-3px) rotateY(-5deg)}43.5%{-webkit-transform:translateX(2px) rotateY(3deg);transform:translate(2px) rotateY(3deg)}50%{-webkit-transform:translateX(0);transform:translate(0)}}@keyframes nutShake{0%{-webkit-transform:translateX(0);transform:translate(0)}6.5%{-webkit-transform:translateX(-6px) rotateY(-9deg);transform:translate(-6px) rotateY(-9deg)}18.5%{-webkit-transform:translateX(5px) rotateY(7deg);transform:translate(5px) rotateY(7deg)}31.5%{-webkit-transform:translateX(-3px) rotateY(-5deg);transform:translate(-3px) rotateY(-5deg)}43.5%{-webkit-transform:translateX(2px) rotateY(3deg);transform:translate(2px) rotateY(3deg)}50%{-webkit-transform:translateX(0);transform:translate(0)}}</style>
  </head>
  <body>
    <div id="app"></div>
  </body>
</html>
